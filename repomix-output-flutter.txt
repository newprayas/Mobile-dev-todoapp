This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: flutter_app/lib/**/*.dart, flutter_app/test/**/*.dart, flutter_app/pubspec.yaml, flutter_app/analysis_options.yaml, flutter_app/android/app/src/main/AndroidManifest.xml, flutter_app/android/app/build.gradle.kts, flutter_app/lib/**/*.dart, flutter_app/test/**/*.dart, flutter_app/pubspec.yaml, flutter_app/analysis_options.yaml, flutter_app/android/app/src/main/AndroidManifest.xml, flutter_app/android/app/build.gradle.kts
- Files matching these patterns are excluded: backend/, **/*.g.dart, **/*.freezed.dart, flutter_app/ios/, flutter_app/linux/, flutter_app/macos/, flutter_app/web/, flutter_app/windows/, flutter_app/android/app/src/main/res/, flutter_app/android/app/src/main/kotlin/, flutter_app/pubspec.lock, flutter_app/.metadata, backend/, **/*.g.dart, **/*.freezed.dart, flutter_app/ios/, flutter_app/linux/, flutter_app/macos/, flutter_app/web/, flutter_app/windows/, flutter_app/android/app/src/main/res/, flutter_app/android/app/src/main/kotlin/, flutter_app/pubspec.lock, flutter_app/.metadata
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
User Provided Header
================================================================
This file contains the core source code for a Flutter productivity app named BETAFLOW. The context also includes unit and widget tests from the 'test/' directory, which serve as executable documentation. The target platform is Android.

================================================================
Directory Structure
================================================================
flutter_app/
  android/
    app/
      src/
        main/
          AndroidManifest.xml
      build.gradle.kts
  lib/
    core/
      bridge/
        notification_action_dispatcher.dart
      constants/
        sound_assets.dart
        timer_defaults.dart
      data/
        app_database.dart
        todo_mutation_service.dart
        todo_repository.dart
        todo_sync_service.dart
      debug/
        notification_sound_tester.dart
      providers/
        notification_action_provider.dart
        notification_provider.dart
      services/
        notifications/
          notification_constants.dart
          notification_permission_manager.dart
          notification_sound_player.dart
          notification_sound_utils.dart
          persistent_notification_manager.dart
        api_service.dart
        auth_service.dart
        mock_api_service.dart
        notification_service.dart
        timer_session_controller.dart
        workmanager_timer_service.dart
      theme/
        app_colors.dart
      utils/
        app_constants.dart
        app_dialogs.dart
        debug_logger.dart
        error_handler.dart
        helpers.dart
      widgets/
        auth_wrapper.dart
        error_display.dart
        progress_bar.dart
    features/
      auth/
        providers/
          auth_provider.dart
        screens/
          login_screen.dart
      pomodoro/
        models/
          timer_state.dart
        notifications/
          persistent_timer_notification_model.dart
        providers/
          timer_provider.dart
        services/
          foreground_ticker.dart
          notification_action_handler.dart
          phase_transition_service.dart
          timer_autosave_service.dart
          timer_background_scheduler.dart
          timer_overdue_service.dart
          timer_persistence_manager.dart
        widgets/
          mini_timer_bar.dart
          pomodoro_action_buttons.dart
          pomodoro_overdue_display.dart
          pomodoro_setup_view.dart
          pomodoro_timer_view.dart
        pomodoro_router.dart
        pomodoro_screen.dart
      todo/
        models/
          todo.dart
        providers/
          todos_provider.dart
        screens/
          todo_list_screen.dart
        widgets/
          inline_task_input.dart
          task_card.dart
          task_list.dart
          todo_list_app_bar.dart
    app.dart
    main.dart
  test/
    notification_action_integration_test.dart
    notification_sound_utils_test.dart
    persistent_timer_notification_model_test.dart
    timer_notifier_smoke_test.dart
    timer_persistence_manager_test.dart
    timer_provider_overdue_test.dart
    timer_service_test.dart
    todo_repository_test.dart
    widget_test.dart
  analysis_options.yaml
  pubspec.yaml

================================================================
Files
================================================================

================
File: flutter_app/lib/core/bridge/notification_action_dispatcher.dart
================
typedef NotificationActionCallback = bool Function(String actionId);
NotificationActionCallback? _notificationActionDispatcher;
void registerNotificationActionDispatcher(NotificationActionCallback cb) {
  _notificationActionDispatcher = cb;
}
void clearNotificationActionDispatcher() {
  _notificationActionDispatcher = null;
}
bool dispatchNotificationActionIfPossible(String actionId) {
  final NotificationActionCallback? cb = _notificationActionDispatcher;
  if (cb == null) return false;
  return cb(actionId);
}

================
File: flutter_app/lib/core/constants/sound_assets.dart
================
enum SoundAsset {
  focusStart('focus_timer_start.wav'),
  breakStart('break_timer_start.wav'),
  sessionComplete('progress_bar_full.wav');
  const SoundAsset(this.fileName);
  final String fileName;
}

================
File: flutter_app/lib/core/constants/timer_defaults.dart
================
class TimerDefaults {
  TimerDefaults._();
  static const int focusSeconds = 25 * 60;
  static const int breakSeconds = 5 * 60;
  static const int minFocusSeconds = 5 * 60;
  static const int maxFocusSeconds = 2 * 60 * 60;
  static const int autoSaveIntervalSeconds = 30;
}

================
File: flutter_app/lib/core/debug/notification_sound_tester.dart
================
import 'package:flutter/foundation.dart';
import '../services/notification_service.dart';
class NotificationSoundTester {
  final NotificationService _service;
  NotificationSoundTester(this._service);
  Future<void> testBreakSound() async {
    if (!kDebugMode) return;
    await _service.playSound('break_timer_start.wav');
  }
  Future<void> testAllCoreSounds() async {
    if (!kDebugMode) return;
    for (final s in const [
      'break_timer_start.wav',
      'focus_timer_start.wav',
      'progress_bar_full.wav',
    ]) {
      await _service.playSound(s);
      await Future.delayed(const Duration(milliseconds: 600));
    }
  }
}

================
File: flutter_app/lib/core/providers/notification_action_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
final notificationActionProvider = StateProvider<String?>((ref) => null);

================
File: flutter_app/lib/core/providers/notification_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/notification_service.dart';
final notificationServiceProvider = Provider<NotificationService>((ref) {
  throw UnimplementedError('notificationServiceProvider must be overridden');
});

================
File: flutter_app/lib/core/services/notifications/notification_constants.dart
================
const int kPersistentTimerNotificationId = 1;
const String kActionPause = 'pause_timer';
const String kActionResume = 'resume_timer';
const String kActionStop = 'stop_timer';
const String kActionMarkComplete = 'mark_complete';
const String kActionContinueWorking = 'continue_working';
const String kPayloadOpenApp = 'open_app';
String mapActionLabel(String id) {
  switch (id) {
    case kActionPause:
      return 'Pause';
    case kActionResume:
      return 'Resume';
    case kActionStop:
      return 'Stop';
    case kActionMarkComplete:
      return 'Complete';
    case kActionContinueWorking:
      return 'Continue';
    default:
      return id;
  }
}

================
File: flutter_app/lib/core/services/notifications/notification_sound_utils.dart
================
String normalizeSoundAsset(String rawPath) {
  if (rawPath.isEmpty) return rawPath;
  String result = rawPath;
  if (result.startsWith('assets/sounds/')) {
    result = result.substring('assets/sounds/'.length);
  } else if (result.startsWith('assets/')) {
    result = result.substring('assets/'.length);
  } else if (result.startsWith('sounds/')) {
    result = result.substring('sounds/'.length);
  }
  return result;
}

================
File: flutter_app/lib/core/services/timer_session_controller.dart
================
import 'package:flutter/foundation.dart';
enum TimerSessionState {
  idle,
  focusActive,
  focusPaused,
  breakActive,
  breakPaused,
  overdue,
  completed,
}
enum TimerSessionEvent {
  start,
  pause,
  resume,
  complete,
  overdueReached,
  reset,
  abort,
}
class TimerSessionController {
  TimerSessionState _currentState = TimerSessionState.idle;
  String? _activeTask;
  int _currentCycle = 1;
  int _totalCycles = 1;
  int _focusSeconds = 0;
  int _breakSeconds = 0;
  int _timeRemaining = 0;
  bool _isOverdue = false;
  final Set<String> _overduePromptShown = {};
  final Set<String> _overdueContinued = {};
  final Map<String, int> _focusedTimeCache = {};
  TimerSessionState get currentState => _currentState;
  String? get activeTask => _activeTask;
  int get currentCycle => _currentCycle;
  int get totalCycles => _totalCycles;
  int get timeRemaining => _timeRemaining;
  bool get isOverdue => _isOverdue;
  Map<String, int> get focusedTimeCache => Map.unmodifiable(_focusedTimeCache);
  bool startSession({
    required String taskName,
    required int focusDurationSeconds,
    required int breakDurationSeconds,
    required int totalCycles,
  }) {
    if (kDebugMode) {
      debugPrint('TIMER_FSM: Starting session for task: $taskName');
    }
    if (_currentState != TimerSessionState.idle) {
      if (kDebugMode) {
        debugPrint('TIMER_FSM: Cannot start - current state: $_currentState');
      }
      return false;
    }
    _activeTask = taskName;
    _focusSeconds = focusDurationSeconds;
    _breakSeconds = breakDurationSeconds;
    _totalCycles = totalCycles;
    _currentCycle = 1;
    _timeRemaining = focusDurationSeconds;
    _isOverdue = false;
    _currentState = TimerSessionState.focusActive;
    if (kDebugMode) {
      debugPrint('TIMER_FSM: Session started - state: $_currentState');
    }
    return true;
  }
  bool handleEvent(TimerSessionEvent event) {
    final previousState = _currentState;
    switch (_currentState) {
      case TimerSessionState.idle:
        break;
      case TimerSessionState.focusActive:
        switch (event) {
          case TimerSessionEvent.pause:
            _currentState = TimerSessionState.focusPaused;
            break;
          case TimerSessionEvent.complete:
            _handleFocusComplete();
            break;
          case TimerSessionEvent.overdueReached:
            _currentState = TimerSessionState.overdue;
            _isOverdue = true;
            break;
          case TimerSessionEvent.abort:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
      case TimerSessionState.focusPaused:
        switch (event) {
          case TimerSessionEvent.resume:
            _currentState = TimerSessionState.focusActive;
            break;
          case TimerSessionEvent.abort:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
      case TimerSessionState.breakActive:
        switch (event) {
          case TimerSessionEvent.pause:
            _currentState = TimerSessionState.breakPaused;
            break;
          case TimerSessionEvent.complete:
            _handleBreakComplete();
            break;
          case TimerSessionEvent.abort:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
      case TimerSessionState.breakPaused:
        switch (event) {
          case TimerSessionEvent.resume:
            _currentState = TimerSessionState.breakActive;
            break;
          case TimerSessionEvent.abort:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
      case TimerSessionState.overdue:
        switch (event) {
          case TimerSessionEvent.reset:
            _resetToIdle();
            break;
          case TimerSessionEvent.abort:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
      case TimerSessionState.completed:
        switch (event) {
          case TimerSessionEvent.reset:
            _resetToIdle();
            break;
          default:
            return false;
        }
        break;
    }
    if (kDebugMode && previousState != _currentState) {
      debugPrint(
        'TIMER_FSM: State transition: $previousState -> $_currentState (event: $event)',
      );
    }
    return previousState != _currentState;
  }
  void _handleFocusComplete() {
    if (_currentCycle >= _totalCycles) {
      _currentState = TimerSessionState.completed;
    } else {
      _currentCycle++;
      _timeRemaining = _breakSeconds;
      _currentState = TimerSessionState.breakActive;
    }
  }
  void _handleBreakComplete() {
    _timeRemaining = _focusSeconds;
    _currentState = TimerSessionState.focusActive;
  }
  void _resetToIdle() {
    _currentState = TimerSessionState.idle;
    _activeTask = null;
    _currentCycle = 1;
    _totalCycles = 1;
    _focusSeconds = 0;
    _breakSeconds = 0;
    _timeRemaining = 0;
    _isOverdue = false;
  }
  void updateTimeRemaining(int seconds) {
    _timeRemaining = seconds;
  }
  void updateFocusedTime(String taskName, int seconds) {
    _focusedTimeCache[taskName] = seconds;
  }
  int getFocusedTime(String taskName) {
    return _focusedTimeCache[taskName] ?? 0;
  }
  void markOverduePromptShown(String taskName) {
    _overduePromptShown.add(taskName);
  }
  void markOverdueContinued(String taskName) {
    _overdueContinued.add(taskName);
  }
  bool wasOverduePromptShown(String taskName) {
    return _overduePromptShown.contains(taskName);
  }
  bool wasOverdueContinued(String taskName) {
    return _overdueContinued.contains(taskName);
  }
  void forceReset() {
    if (kDebugMode) {
      debugPrint(
        'TIMER_FSM: Force resetting session controller from state: $_currentState',
      );
    }
    _resetToIdle();
  }
  Map<String, dynamic> getSessionInfo() {
    return {
      'state': _currentState.toString(),
      'activeTask': _activeTask,
      'currentCycle': _currentCycle,
      'totalCycles': _totalCycles,
      'timeRemaining': _timeRemaining,
      'isOverdue': _isOverdue,
      'isRunning':
          _currentState == TimerSessionState.focusActive ||
          _currentState == TimerSessionState.breakActive,
      'currentMode':
          _currentState == TimerSessionState.focusActive ||
              _currentState == TimerSessionState.focusPaused
          ? 'focus'
          : 'break',
    };
  }
}

================
File: flutter_app/lib/core/services/workmanager_timer_service.dart
================
import 'package:workmanager/workmanager.dart';
import '../utils/app_constants.dart';
class WorkmanagerTimerService {
  Future<void> schedulePomodoroOneOff({
    required Duration delay,
    required Map<String, dynamic> inputData,
  }) async {
    await Workmanager().registerOneOffTask(
      AppConstants.pomodoroTimerTask,
      AppConstants.pomodoroTimerTask,
      initialDelay: delay,
      existingWorkPolicy: ExistingWorkPolicy.replace,
  constraints: Constraints(
        networkType: NetworkType.notRequired,
        requiresCharging: false,
        requiresDeviceIdle: false,
        requiresBatteryNotLow: false,
      ),
      inputData: inputData,
    );
  }
  Future<void> cancelPomodoroTask() async {
    await Workmanager().cancelByUniqueName(AppConstants.pomodoroTimerTask);
  }
}

================
File: flutter_app/lib/core/theme/app_colors.dart
================
import 'package:flutter/material.dart';
class AppColors {
  static const scaffoldBg = Color(0xFF1A1A1A);
  static const cardBg = Color(0xFF2C2C2C);
  static const midGray = Color(0xFF404040);
  static const lightGray = Color(0xFFE0E0E0);
  static const mediumGray = Color(0xFFA0A0A0);
  static const brightYellow = Color(0xFFFFD700);
  static const actionSecondary = Color(0xFFB59A00);
  static const priorityHigh = Color(0xFFE84545);
  static const priorityMedium = Color(0xFFF2A33A);
  static const priorityLow = Color(0xFF6BCB77);
  static const focusBorder = Color(0xFF6FB3FF);
  static const inputFill = Color(0xFF333333);
  static const focusRed = Color(0xFFFF5252);
  static const breakGreen = Color(0xFF69F0AE);
}

================
File: flutter_app/lib/core/utils/app_constants.dart
================
class AppConstants {
  static const String pomodoroTimerTask = 'pomodoroTimerTask';
  static const String prefActiveTaskId = 'activeTaskId';
  static const String prefActiveTaskText =
      'activeTaskText';
  static const String prefTimeRemaining = 'timeRemaining';
  static const String prefIsRunning = 'isRunning';
  static const String prefIsTimerActive = 'isTimerActive';
  static const String prefCurrentMode = 'currentMode';
  static const String prefPlannedDurationSeconds = 'plannedDurationSeconds';
  static const String prefFocusDurationSeconds = 'focusDurationSeconds';
  static const String prefBreakDurationSeconds = 'breakDurationSeconds';
  static const String prefCurrentCycle = 'currentCycle';
  static const String prefTotalCycles = 'totalCycles';
  static const String prefCompletedSessions = 'completedSessions';
  static const String prefIsProgressBarFull = 'isProgressBarFull';
  static const String prefAllSessionsComplete = 'allSessionsComplete';
  static const String prefOverdueSessionsComplete =
      'overdueSessionsComplete';
  static const String prefOverdueCrossedTaskId =
      'overdueCrossedTaskId';
  static const String prefOverdueCrossedTaskName =
      'overdueCrossedTaskName';
  static const String prefOverduePromptShown =
      'overduePromptShown';
  static const String prefOverdueContinued = 'overdueContinued';
  static const String prefFocusedTimeCache =
      'focusedTimeCache';
  static const String prefSuppressNextActivation =
      'suppressNextActivation';
  static const String prefCycleOverflowBlocked = 'cycleOverflowBlocked';
  static const String prefIsPermanentlyOverdue = 'isPermanentlyOverdue';
  static const String prefBackgroundStartTime = 'backgroundStartTime';
  static const String prefPausedTimeTotal = 'pausedTimeTotal';
  static const String prefWasInBackground = 'wasInBackground';
  static const String prefSessionScheduled =
      'sessionScheduled';
  static const String prefApiBaseUrl = 'apiBaseUrl';
  static const String prefIsDebugMode = 'isDebugMode';
  static const String notificationChannelId = 'pomodoro_channel';
  static const String notificationChannelName = 'Pomodoro Notifications';
  static const String notificationChannelDescription =
      'Notifications for Pomodoro timer events';
}

================
File: flutter_app/lib/core/utils/error_handler.dart
================
import 'package:flutter/material.dart';
import 'package:dio/dio.dart';
class ErrorHandler {
  static String getErrorMessage(dynamic error) {
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          return 'Connection timeout. Please check your internet connection.';
        case DioExceptionType.connectionError:
          return 'Cannot connect to server. Please check your internet connection.';
        case DioExceptionType.badResponse:
          final statusCode = error.response?.statusCode;
          if (statusCode == 401) {
            return 'Authentication failed. Please sign in again.';
          } else if (statusCode == 403) {
            return 'Access denied. Please contact support.';
          } else if (statusCode == 404) {
            return 'Resource not found. Please try again.';
          } else if (statusCode == 500) {
            return 'Server error. Please try again later.';
          } else {
            return 'Request failed (Error $statusCode). Please try again.';
          }
        default:
          return 'Network error. Please check your connection.';
      }
    } else if (error.toString().toLowerCase().contains('connection')) {
      return 'Connection failed. Please check your internet connection.';
    } else {
      return 'Something went wrong. Please try again.';
    }
  }
  static void showError(BuildContext context, dynamic error) {
    if (!context.mounted) return;
    final message = getErrorMessage(error);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.redAccent,
        duration: const Duration(seconds: 4),
        action: SnackBarAction(
          label: 'Dismiss',
          textColor: Colors.white,
          onPressed: () {
            ScaffoldMessenger.of(context).hideCurrentSnackBar();
          },
        ),
      ),
    );
  }
  static void showSuccess(BuildContext context, String message) {
    if (!context.mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 2),
      ),
    );
  }
  static void showInfo(BuildContext context, String message) {
    if (!context.mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.blue,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

================
File: flutter_app/lib/core/utils/helpers.dart
================
String formatTime(int seconds) {
  final minutes = (seconds / 60).floor().toString().padLeft(2, '0');
  final remainingSeconds = (seconds % 60).toString().padLeft(2, '0');
  return '$minutes:$remainingSeconds';
}

================
File: flutter_app/lib/core/widgets/auth_wrapper.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/auth/screens/login_screen.dart';
import '../../features/todo/screens/todo_list_screen.dart';
import '../../features/auth/providers/auth_provider.dart';
class AuthWrapper extends ConsumerWidget {
  const AuthWrapper({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    return authState.when(
      data: (authData) {
        if (authData.isAuthenticated) {
          if (kDebugMode) {
            debugPrint('DEBUG: User is authenticated, showing TodoListScreen');
          }
          return const TodoListScreen();
        } else {
          if (kDebugMode) {
            debugPrint('DEBUG: User is not authenticated, showing LoginScreen');
          }
          return const LoginScreen();
        }
      },
      loading: () => Scaffold(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        body: const Center(child: CircularProgressIndicator()),
      ),
      error: (error, stackTrace) {
        if (kDebugMode) debugPrint('DEBUG: Auth error: $error');
        return const LoginScreen();
      },
    );
  }
}

================
File: flutter_app/lib/core/widgets/error_display.dart
================
import 'package:flutter/material.dart';
class ErrorDisplay extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final IconData icon;
  const ErrorDisplay({
    super.key,
    required this.message,
    this.onRetry,
    this.icon = Icons.error_outline,
  });
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 64, color: Theme.of(context).colorScheme.error),
            const SizedBox(height: 16),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
class LoadingDisplay extends StatelessWidget {
  final String message;
  const LoadingDisplay({super.key, this.message = 'Loading...'});
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(message, style: Theme.of(context).textTheme.bodyMedium),
        ],
      ),
    );
  }
}

================
File: flutter_app/lib/features/pomodoro/services/foreground_ticker.dart
================
import 'dart:async';
import '../models/timer_state.dart';
import '../../../core/constants/timer_defaults.dart';
typedef TickCallback = void Function();
typedef PhaseCompleteCallback = void Function();
typedef OverdueCheckCallback = void Function();
class ForegroundTicker {
  Timer? _timer;
  bool get isActive => _timer != null;
  void start({
    required TickCallback onTick,
    required PhaseCompleteCallback onPhaseComplete,
    required OverdueCheckCallback onOverdueCheck,
    required TimerState Function() stateProvider,
  }) {
    stop();
    _timer = Timer.periodic(const Duration(seconds: 1), (_) {
      final TimerState state = stateProvider();
      if (!state.isRunning) return;
      onOverdueCheck();
      if (state.currentMode == 'focus' && state.activeTaskId != null) {
        onTick();
      }
      if (state.timeRemaining > 0) {
        onTick();
      } else {
        onPhaseComplete();
      }
    });
  }
  void stop() {
    _timer?.cancel();
    _timer = null;
  }
}

================
File: flutter_app/lib/features/pomodoro/services/notification_action_handler.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/timer_provider.dart';
import '../../todo/providers/todos_provider.dart';
class NotificationActionHandler {
  final TimerNotifier notifier;
  final Ref ref;
  NotificationActionHandler({required this.notifier, required this.ref});
  Future<void> handle(String actionId) async {
    switch (actionId) {
      case 'pause_timer':
        if (notifier.state.isRunning) notifier.pauseTask();
        break;
      case 'resume_timer':
        if (!notifier.state.isRunning) notifier.resumeTask();
        break;
      case 'stop_timer':
        if (notifier.state.activeTaskId != null) {
          await notifier.stopAndSaveProgress(notifier.state.activeTaskId!);
        } else {
          notifier.clear();
        }
        break;
      case 'mark_complete':
        if (notifier.state.activeTaskId != null) {
          await ref.read(todosProvider.notifier).toggleTodo(notifier.state.activeTaskId!);
          await notifier.stopAndSaveProgress(notifier.state.activeTaskId!);
        }
        break;
      case 'continue_working':
        if (notifier.state.activeTaskId != null) {
          notifier.state = notifier.state.copyWith(
            overdueContinued: Set<int>.from(notifier.state.overdueContinued)
              ..add(notifier.state.activeTaskId!),
            isPermanentlyOverdue: true,
            isProgressBarFull: false,
            plannedDurationSeconds: null,
            focusDurationSeconds: null,
          );
          notifier.update();
        }
        break;
    }
  }
}

================
File: flutter_app/lib/features/pomodoro/services/phase_transition_service.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/constants/sound_assets.dart';
import '../../../core/providers/notification_provider.dart';
import '../models/timer_state.dart';
import '../providers/timer_provider.dart';
import '../../../core/utils/debug_logger.dart';
class PhaseTransitionService {
  final TimerNotifier notifier;
  final Ref ref;
  PhaseTransitionService({required this.notifier, required this.ref});
  void handlePhaseCompletion(TimerState current) {
    if (current.currentMode == 'focus') {
      _handleFocusCompletion(current);
    } else if (current.currentMode == 'break') {
      _handleBreakCompletion(current);
    } else {
      notifier.stop();
    }
  }
  void skipPhase(TimerState state) {
    final notificationService = ref.read(notificationServiceProvider);
    if (state.currentMode == 'focus') {
      if (state.currentCycle >= state.totalCycles) {
        notifier.update(cycleOverflowBlocked: true);
        return;
      }
      notificationService.playSoundWithNotification(
        soundFileName: SoundAsset.breakStart.fileName,
        title: 'Focus Phase Skipped',
        body: 'Moving to break time for "${state.activeTaskName}".',
      );
      final int completed = state.completedSessions + 1;
      final int nextCycle = state.currentCycle + 1;
      notifier.update(
        currentMode: 'break',
        timeRemaining: state.breakDurationSeconds ?? state.timeRemaining,
        completedSessions: completed,
        currentCycle: nextCycle,
      );
    } else if (state.currentMode == 'break') {
      notificationService.playSound(SoundAsset.focusStart.fileName);
      notifier.update(
        currentMode: 'focus',
        timeRemaining: state.focusDurationSeconds ?? state.timeRemaining,
      );
    }
  }
  void _handleFocusCompletion(TimerState state) {
    final int completed = state.completedSessions + 1;
    if (completed >= state.totalCycles) {
      final service = ref.read(notificationServiceProvider);
      if (state.isPermanentlyOverdue && !state.overdueSessionsComplete) {
        service.playSoundWithNotification(
          soundFileName: SoundAsset.sessionComplete.fileName,
          title: 'Session Complete!',
          body: 'Overdue task session completed for "${state.activeTaskName}".',
        );
        notifier.update(
          overdueSessionsComplete: true,
          isRunning: false,
          completedSessions: completed,
        );
        notifier.stopTicker();
      } else if (!state.allSessionsComplete) {
        service.playSoundWithNotification(
          soundFileName: SoundAsset.sessionComplete.fileName,
          title: 'All Sessions Complete!',
          body: 'All planned sessions completed for "${state.activeTaskName}".',
        );
        notifier.update(
          allSessionsComplete: true,
          isRunning: false,
          completedSessions: completed,
        );
        notifier.stopTicker();
      }
      if (!notifier.state.isRunning && notifier.state.timeRemaining == 0) {
        notifier.stopTicker();
        return;
      }
    } else {
      final notificationService = ref.read(notificationServiceProvider);
      notificationService.playSoundWithNotification(
        soundFileName: SoundAsset.breakStart.fileName,
        title: 'Focus Session Complete!',
        body: 'Time for a break for "${state.activeTaskName}".',
      );
      final int nextCycle = (state.currentCycle + 1) <= state.totalCycles
          ? state.currentCycle + 1
          : state.totalCycles;
      notifier.update(
        currentMode: 'break',
        timeRemaining: state.breakDurationSeconds,
        currentCycle: nextCycle,
        completedSessions: completed,
      );
    }
  }
  void _handleBreakCompletion(TimerState state) {
    if (state.focusDurationSeconds != null) {
      final service = ref.read(notificationServiceProvider);
      service.playSound(SoundAsset.focusStart.fileName);
      service.showNotification(
        title: 'Break Complete!',
        body: 'Time to focus on "${state.activeTaskName}" again!',
      );
      notifier.update(
        currentMode: 'focus',
        timeRemaining: state.focusDurationSeconds,
      );
    } else {
      notifier.stop();
    }
  }
}

================
File: flutter_app/test/notification_sound_utils_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:focus_timer_app/core/services/notifications/notification_sound_utils.dart';
void main() {
  group('normalizeSoundAsset', () {
    test('leaves simple filename unchanged', () {
      expect(normalizeSoundAsset('focus_timer_start.wav'), 'focus_timer_start.wav');
    });
    test('strips sounds/ prefix', () {
      expect(normalizeSoundAsset('sounds/focus_timer_start.wav'), 'focus_timer_start.wav');
    });
    test('strips assets/sounds/ prefix', () {
      expect(normalizeSoundAsset('assets/sounds/focus_timer_start.wav'), 'focus_timer_start.wav');
    });
    test('strips assets/ prefix', () {
      expect(normalizeSoundAsset('assets/focus_timer_start.wav'), 'focus_timer_start.wav');
    });
    test('returns empty unchanged', () {
      expect(normalizeSoundAsset(''), '');
    });
  });
}

================
File: flutter_app/test/timer_notifier_smoke_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:focus_timer_app/features/pomodoro/providers/timer_provider.dart';
import 'package:focus_timer_app/features/pomodoro/models/timer_state.dart';
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  test('TimerNotifier startTask sets initial running state', () async {
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final notifier = container.read(timerProvider.notifier);
    final started = notifier.startTask(
      taskId: 1,
      taskName: 'Demo',
      focusDuration: 5,
      breakDuration: 3,
      plannedDuration: 5,
      totalCycles: 1,
    );
    expect(started, true);
    final state = container.read(timerProvider);
    expect(state.isRunning, true);
    expect(state.activeTaskId, 1);
  });
}

================
File: flutter_app/test/timer_persistence_manager_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:focus_timer_app/features/pomodoro/services/timer_persistence_manager.dart';
import 'package:focus_timer_app/features/pomodoro/models/timer_state.dart';
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  group('TimerPersistenceManager', () {
    late SharedPreferences prefs;
    late TimerPersistenceManager manager;
    setUp(() async {
      SharedPreferences.setMockInitialValues({});
      prefs = await SharedPreferences.getInstance();
      manager = TimerPersistenceManager(prefs);
    });
    test('saves and loads timer state roundtrip', () async {
      final state = const TimerState(
        activeTaskId: 1,
        activeTaskName: 'Test',
        timeRemaining: 120,
        isRunning: true,
        currentMode: 'focus',
        totalCycles: 4,
        currentCycle: 2,
        focusedTimeCache: {1: 30},
      );
      await manager.saveTimerState(state);
      final loaded = manager.loadTimerState();
      expect(loaded, isNotNull);
      expect(loaded!.activeTaskId, 1);
      expect(loaded.activeTaskName, 'Test');
      expect(loaded.timeRemaining, 120);
      expect(loaded.isRunning, true);
      expect(loaded.focusedTimeCache[1], 30);
    });
    test('clearTimerState removes persisted keys', () async {
      final state = const TimerState(activeTaskId: 2, activeTaskName: 'Task');
      await manager.saveTimerState(state);
      expect(manager.loadTimerState(), isNotNull);
      await manager.clearTimerState();
      expect(manager.loadTimerState(), isNull);
    });
  });
}

================
File: flutter_app/test/todo_repository_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:focus_timer_app/core/data/todo_repository.dart';
import 'package:focus_timer_app/core/data/app_database.dart';
import 'package:focus_timer_app/core/services/mock_api_service.dart';
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  late AppDatabase db;
  late TodoRepository repo;
  setUp(() {
  db = AppDatabase();
  repo = TodoRepository(db, MockApiService('http://localhost:5000'));
  });
  tearDown(() async {
    await db.close();
  });
  group('TodoRepository', () {
    test('addTodo inserts and syncs (optimistic then replaces)', () async {
      await repo.addTodo('Test Task', 0, 30);
      final todos = await db.select(db.todos).get();
      expect(todos.isNotEmpty, true);
    });
    test('toggleTodo flips completed flag', () async {
      await repo.addTodo('Toggle Task', 0, 25);
      final inserted = await db.select(db.todos).get();
      final id = inserted.first.id;
      await repo.toggleTodo(id);
      final after = await db.getTodoById(id);
      expect(after?.completed, true);
    });
  });
}

================
File: flutter_app/analysis_options.yaml
================
include: package:flutter_lints/flutter.yaml
linter:
  rules:

================
File: flutter_app/lib/core/data/app_database.dart
================
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import '../../features/todo/models/todo.dart'
    as todo_model;
part 'app_database.g.dart';
@DataClassName(
  'TodoEntry',
)
class Todos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get userId => text()();
  TextColumn get taskText =>
      text()();
  BoolColumn get completed => boolean().withDefault(const Constant(false))();
  IntColumn get durationHours => integer().withDefault(const Constant(0))();
  IntColumn get durationMinutes => integer().withDefault(const Constant(0))();
  IntColumn get focusedTime => integer().withDefault(const Constant(0))();
  IntColumn get wasOverdue => integer().withDefault(const Constant(0))();
  IntColumn get overdueTime => integer().withDefault(const Constant(0))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}
@DriftDatabase(tables: [Todos])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());
  AppDatabase.memory() : super(NativeDatabase.memory());
  @override
  int get schemaVersion => 1;
  Stream<List<todo_model.Todo>> watchAllTodos() {
    return (select(todos)..orderBy([
          (t) => OrderingTerm(expression: t.createdAt, mode: OrderingMode.desc),
        ]))
        .watch()
        .map((rows) => rows.map(mapTodoEntryToTodoModel).toList());
  }
  Future<todo_model.Todo?> getTodoById(int id) {
    return (select(todos)..where((t) => t.id.equals(id)))
        .getSingleOrNull()
        .then((entry) => entry != null ? mapTodoEntryToTodoModel(entry) : null);
  }
  Future<todo_model.Todo> insertTodo(TodosCompanion entry) async {
    final id = await into(todos).insert(entry);
    return (await getTodoById(id))!;
  }
  Future<bool> updateTodo(int id, TodosCompanion entry) {
    return (update(todos)..where((t) => t.id.equals(id)))
        .write(entry)
        .then((affectedRows) => affectedRows > 0);
  }
  Future<int> deleteTodo(int id) {
    return (delete(todos)..where((t) => t.id.equals(id))).go();
  }
  Future<void> clearCompletedTodos() {
    return (delete(todos)..where((t) => t.completed.equals(true))).go();
  }
  todo_model.Todo mapTodoEntryToTodoModel(TodoEntry entry) {
    return todo_model.Todo(
      id: entry.id,
      userId: entry.userId,
      text: entry.taskText,
      completed: entry.completed,
      durationHours: entry.durationHours,
      durationMinutes: entry.durationMinutes,
      focusedTime: entry.focusedTime,
      wasOverdue: entry.wasOverdue,
      overdueTime: entry.overdueTime,
      createdAt: entry.createdAt,
    );
  }
  static TodosCompanion toTodosCompanion(
    todo_model.Todo todo, {
    bool isInsert = false,
  }) {
    return TodosCompanion(
      id: Value(todo.id),
      userId: Value(todo.userId),
      taskText: Value(todo.text),
      completed: Value(todo.completed),
      durationHours: Value(todo.durationHours),
      durationMinutes: Value(todo.durationMinutes),
      focusedTime: Value(todo.focusedTime),
      wasOverdue: Value(todo.wasOverdue),
      overdueTime: Value(todo.overdueTime),
      createdAt: isInsert
          ? Value.absent()
          : Value(todo.createdAt),
    );
  }
}
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    return NativeDatabase(file);
  });
}

================
File: flutter_app/lib/core/data/todo_mutation_service.dart
================
import 'package:drift/drift.dart';
import 'package:logger/logger.dart';
import '../../features/todo/models/todo.dart';
import 'app_database.dart';
import '../services/api_service.dart';
class TodoMutationService {
  final AppDatabase _db;
  final ApiService _api;
  final Logger logger = Logger();
  TodoMutationService(this._db, this._api);
  Future<Todo> addTodo(String text, int hours, int minutes) async {
    final Todo optimistic = Todo(
      id: -1,
      userId: _api.devUserId,
      text: text,
      completed: false,
      durationHours: hours,
      durationMinutes: minutes,
      focusedTime: 0,
      wasOverdue: 0,
      overdueTime: 0,
      createdAt: DateTime.now(),
    );
    final inserted = await _db.insertTodo(
      AppDatabase.toTodosCompanion(
        optimistic,
        isInsert: true,
      ).copyWith(id: const Value.absent()),
    );
    logger.i('[TodoMutationService] Optimistic add local id=${inserted.id}');
    try {
      final data = await _api.addTodo(text, hours, minutes);
      final Todo serverTodo = Todo(
        id: data['id'],
        userId: data['user_id'],
        text: data['text'],
        completed: data['completed'] == 1,
        durationHours: data['duration_hours'],
        durationMinutes: data['duration_minutes'],
        focusedTime: data['focused_time'],
        wasOverdue: data['was_overdue'] ?? 0,
        overdueTime: data['overdue_time'] ?? 0,
        createdAt: DateTime.parse(data['created_at']),
      );
      await _db.deleteTodo(inserted.id);
      await _db.insertTodo(
        AppDatabase.toTodosCompanion(serverTodo, isInsert: false),
      );
      return serverTodo;
    } catch (e, st) {
      logger.e('[TodoMutationService] API add failed, reverting: $e\n$st');
      await _db.deleteTodo(inserted.id);
      rethrow;
    }
  }
  Future<void> deleteTodo(int id) async {
    final original = await _db.getTodoById(id);
    if (original == null) return;
    await _db.deleteTodo(id);
    try {
      await _api.deleteTodo(id);
    } catch (e, st) {
      logger.e('[TodoMutationService] Delete revert due API fail: $e\n$st');
      await _db.insertTodo(
        AppDatabase.toTodosCompanion(original, isInsert: false),
      );
      rethrow;
    }
  }
  Future<void> toggleTodo(int id, {int? liveFocusedTime}) async {
    final original = await _db.getTodoById(id);
    if (original == null) return;
    final int focused = liveFocusedTime ?? original.focusedTime;
    final int planned =
        (original.durationHours * 3600) + (original.durationMinutes * 60);
    final bool overdue =
        (planned > 0 && focused > planned) || original.wasOverdue == 1;
    final int overdueTime = overdue
        ? (focused - planned).clamp(0, double.infinity).toInt()
        : original.overdueTime;
    final updated = original.copyWith(
      completed: !original.completed,
      focusedTime: focused,
      wasOverdue: overdue ? 1 : 0,
      overdueTime: overdueTime,
    );
    await _db.updateTodo(
      id,
      AppDatabase.toTodosCompanion(updated, isInsert: false),
    );
    try {
      await _api.toggleTodoWithOverdue(
        id,
        wasOverdue: overdue,
        overdueTime: overdueTime,
      );
    } catch (e, st) {
      logger.e('[TodoMutationService] Toggle revert API fail: $e\n$st');
      await _db.updateTodo(
        id,
        AppDatabase.toTodosCompanion(original, isInsert: false),
      );
      rethrow;
    }
  }
  Future<void> updateTodo({
    required int id,
    String? text,
    int? hours,
    int? minutes,
  }) async {
    final original = await _db.getTodoById(id);
    if (original == null) return;
    final updated = original.copyWith(
      text: text ?? original.text,
      durationHours: hours ?? original.durationHours,
      durationMinutes: minutes ?? original.durationMinutes,
    );
    await _db.updateTodo(
      id,
      AppDatabase.toTodosCompanion(updated, isInsert: false),
    );
    try {
      await _api.updateTodo(id, text: text, hours: hours, minutes: minutes);
    } catch (e, st) {
      logger.e('[TodoMutationService] Update revert API fail: $e\n$st');
      await _db.updateTodo(
        id,
        AppDatabase.toTodosCompanion(original, isInsert: false),
      );
      rethrow;
    }
  }
  Future<void> markTaskPermanentlyOverdue(
    int id, {
    required int overdueTime,
  }) async {
    final original = await _db.getTodoById(id);
    if (original == null) return;
    final updated = original.copyWith(wasOverdue: 1, overdueTime: overdueTime);
    await _db.updateTodo(
      id,
      AppDatabase.toTodosCompanion(updated, isInsert: false),
    );
  }
  Future<void> clearCompleted() async {
    final all = await _db.select(_db.todos).get();
    final completed = all
        .where((e) => e.completed)
        .map(_db.mapTodoEntryToTodoModel)
        .toList();
    if (completed.isEmpty) return;
    await _db.clearCompletedTodos();
    try {
      await Future.wait(completed.map((t) => _api.deleteTodo(t.id)));
    } catch (e, st) {
      logger.e('[TodoMutationService] Clear completed remote fail: $e\n$st');
      rethrow;
    }
  }
  Future<void> updateFocusTime(int id, int focusedTime) async {
    final original = await _db.getTodoById(id);
    if (original == null) return;
    final updated = original.copyWith(focusedTime: focusedTime);
    await _db.updateTodo(
      id,
      AppDatabase.toTodosCompanion(updated, isInsert: false),
    );
    try {
      await _api.updateFocusTime(id, focusedTime);
    } catch (e, st) {
      logger.e('[TodoMutationService] Focus time sync fail: $e\n$st');
      rethrow;
    }
  }
}

================
File: flutter_app/lib/core/data/todo_repository.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/mock_api_service.dart';
import '../../features/todo/models/todo.dart';
import 'app_database.dart';
import 'todo_mutation_service.dart';
import 'todo_sync_service.dart';
class TodoRepository {
  final AppDatabase _localDb;
  final ApiService _apiService;
  late final TodoMutationService _mutations;
  late final TodoSyncService _sync;
  TodoRepository(this._localDb, this._apiService) {
    _mutations = TodoMutationService(_localDb, _apiService);
    _sync = TodoSyncService(_localDb, _apiService);
  }
  Stream<List<Todo>> watchTodos() {
    return _localDb.watchAllTodos();
  }
  Future<void> syncTodos() async => _sync.syncTodos();
  Future<void> addTodo(String text, int hours, int minutes) async =>
      _mutations.addTodo(text, hours, minutes);
  Future<void> deleteTodo(int id) async => _mutations.deleteTodo(id);
  Future<void> toggleTodo(int id, {int? liveFocusedTime}) async =>
      _mutations.toggleTodo(id, liveFocusedTime: liveFocusedTime);
  Future<void> toggleTodoWithOverdue(int id, {required bool wasOverdue, required int overdueTime}) async {
    await _mutations.toggleTodo(id, liveFocusedTime: null);
  }
  Future<void> updateTodo({required int id, String? text, int? hours, int? minutes}) async =>
      _mutations.updateTodo(id: id, text: text, hours: hours, minutes: minutes);
  Future<void> markTaskPermanentlyOverdue(int id, {required int overdueTime}) async =>
      _mutations.markTaskPermanentlyOverdue(id, overdueTime: overdueTime);
  Future<void> clearCompleted() async => _mutations.clearCompleted();
  Future<void> updateFocusTime(int id, int focusedTime) async =>
      _mutations.updateFocusTime(id, focusedTime);
}
extension IterableExtension<E> on Iterable<E> {
  E? firstWhereOrNull(bool Function(E element) test) {
    for (final element in this) {
      if (test(element)) {
        return element;
      }
    }
    return null;
  }
}
final databaseProvider = Provider<AppDatabase>((ref) {
  final db = AppDatabase();
  ref.onDispose(() => db.close());
  return db;
});
final todoRepositoryProvider = Provider<TodoRepository>((ref) {
  final localDb = ref.watch(databaseProvider);
  final apiService = ref.watch(
    apiServiceProvider,
  );
  return TodoRepository(localDb, apiService);
});

================
File: flutter_app/lib/core/data/todo_sync_service.dart
================
import 'package:drift/drift.dart' as drift;
import 'package:logger/logger.dart';
import '../../features/todo/models/todo.dart';
import 'app_database.dart';
import '../services/api_service.dart';
class TodoSyncService {
  final AppDatabase _db;
  final ApiService _api;
  final Logger logger = Logger();
  TodoSyncService(this._db, this._api);
  Future<void> syncTodos() async {
    logger.i('[TodoSyncService] Sync start');
    final remoteData = await _api.fetchTodos();
    final List<Todo> remoteTodos = remoteData.map((e) {
      final Map<String, dynamic> raw = Map<String, dynamic>.from(e);
      return Todo(
        id: raw['id'] is int ? raw['id'] : int.parse('${raw['id']}'),
        userId: raw['user_id'] ?? raw['userId'] ?? '',
        text: raw['text'] ?? '',
        completed: (raw['completed'] == 1 || raw['completed'] == true),
        durationHours: _asInt(raw['duration_hours']),
        durationMinutes: _asInt(raw['duration_minutes']),
        focusedTime: _asInt(raw['focused_time']),
        wasOverdue: _asInt(raw['was_overdue']),
        overdueTime: _asInt(raw['overdue_time']),
        createdAt: DateTime.parse(raw['created_at']),
      );
    }).toList();
    final localRows = await _db.select(_db.todos).get();
    final localTodos = localRows.map(_db.mapTodoEntryToTodoModel).toList();
    final remoteIds = remoteTodos.map((t) => t.id).toSet();
    for (final local in localTodos) {
      if (!remoteIds.contains(local.id)) {
        await _db.deleteTodo(local.id);
      }
    }
    for (final remote in remoteTodos) {
      final existing = localTodos.where((t) => t.id == remote.id).toList();
      if (existing.isEmpty) {
        final companion = AppDatabase.toTodosCompanion(
          remote,
          isInsert: true,
        ).copyWith(id: const drift.Value.absent());
        await _db.insertTodo(companion);
      } else {
        final current = existing.first;
        if (!_equivalent(current, remote)) {
          await _db.updateTodo(
            remote.id,
            AppDatabase.toTodosCompanion(remote, isInsert: false),
          );
        }
      }
    }
    logger.i('[TodoSyncService] Sync complete');
  }
  static int _asInt(dynamic v) {
    if (v == null) return 0;
    if (v is int) return v;
    return int.parse('$v');
  }
  bool _equivalent(Todo a, Todo b) {
    return a.text == b.text &&
        a.completed == b.completed &&
        a.durationHours == b.durationHours &&
        a.durationMinutes == b.durationMinutes &&
        a.focusedTime == b.focusedTime &&
        a.wasOverdue == b.wasOverdue &&
        a.overdueTime == b.overdueTime &&
        a.createdAt == b.createdAt;
  }
}

================
File: flutter_app/lib/core/services/notifications/notification_permission_manager.dart
================
import 'dart:io' show Platform;
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:logger/logger.dart';
class NotificationPermissionManager {
  final FlutterLocalNotificationsPlugin _plugin;
  final Logger logger = Logger();
  NotificationPermissionManager(this._plugin);
  Future<void> ensurePermissions() async {
    try {
      if (Platform.isAndroid) {
        final AndroidFlutterLocalNotificationsPlugin? androidImpl = _plugin
            .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin
            >();
        if (androidImpl != null) {
          final bool? enabled = await androidImpl.areNotificationsEnabled();
          if (enabled == false) {
            final bool? granted = await androidImpl
                .requestNotificationsPermission();
            logger.i(
              '[NotificationPermissions] Requested Android permission granted=$granted',
            );
          } else {
            logger.i(
              '[NotificationPermissions] Android notifications already enabled',
            );
          }
        }
      } else if (Platform.isIOS) {
        final IOSFlutterLocalNotificationsPlugin? iosImpl = _plugin
            .resolvePlatformSpecificImplementation<
              IOSFlutterLocalNotificationsPlugin
            >();
        if (iosImpl != null) {
          final bool? granted = await iosImpl.requestPermissions(
            alert: true,
            badge: true,
            sound: true,
          );
          logger.i('[NotificationPermissions] iOS permission granted=$granted');
        }
      } else if (Platform.isMacOS) {
        final MacOSFlutterLocalNotificationsPlugin? macImpl = _plugin
            .resolvePlatformSpecificImplementation<
              MacOSFlutterLocalNotificationsPlugin
            >();
        if (macImpl != null) {
          final bool? granted = await macImpl.requestPermissions(
            alert: true,
            badge: true,
            sound: true,
          );
          logger.i(
            '[NotificationPermissions] macOS permission granted=$granted',
          );
        }
      }
    } catch (e) {
      logger.e('[NotificationPermissions] Error requesting permissions err=$e');
    }
  }
}

================
File: flutter_app/lib/core/services/notifications/notification_sound_player.dart
================
import 'package:audioplayers/audioplayers.dart';
import 'package:logger/logger.dart';
import 'notification_sound_utils.dart';
class NotificationSoundPlayer {
  final AudioPlayer _audioPlayer = AudioPlayer();
  final Logger logger = Logger();
  Future<void> playSound(String soundFileName) async {
    try {
      logger.d('[NotificationSoundPlayer] playSound sound=$soundFileName');
      await _audioPlayer.stop();
      final String assetPath = normalizeSoundAsset(soundFileName);
      await Future.delayed(const Duration(milliseconds: 50));
      await _audioPlayer.play(AssetSource('sounds/$assetPath'));
      logger.i('[NotificationSoundPlayer] Sound played sound=$soundFileName');
      if (soundFileName.contains('break_timer_start')) {
        logger.i('[NotificationSoundPlayer] Break timer sound played');
      } else if (soundFileName.contains('progress_bar_full')) {
        logger.i('[NotificationSoundPlayer] Progress bar full sound played');
      }
    } catch (e, st) {
      logger.e('[NotificationSoundPlayer] Error playing $soundFileName err=$e');
      logger.e('[NotificationSoundPlayer] Stack trace: $st');
      if (soundFileName.contains('break_timer_start') ||
          soundFileName.contains('progress_bar_full')) {
        try {
          await _audioPlayer.setSource(AssetSource('sounds/$soundFileName'));
          await _audioPlayer.resume();
          logger.i(
            '[NotificationSoundPlayer] Alternative playback success sound=$soundFileName',
          );
        } catch (alt) {
          logger.e(
            '[NotificationSoundPlayer] Alternative playback failed err=$alt',
          );
        }
      }
    }
  }
}

================
File: flutter_app/lib/core/services/notifications/persistent_notification_manager.dart
================
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import '../../utils/debug_logger.dart';
import 'notification_constants.dart';
class PersistentNotificationManager {
  final FlutterLocalNotificationsPlugin _plugin;
  PersistentNotificationManager(this._plugin);
  Future<void> showOrUpdate({
    required String title,
    required String body,
    required List<String> actionIds,
  }) async {
    final List<AndroidNotificationAction> actions = actionIds
        .map(
          (id) => AndroidNotificationAction(
            id,
            mapActionLabel(id),
            showsUserInterface: false,
            cancelNotification: false,
            contextual: false,
          ),
        )
        .toList();
    final BigTextStyleInformation bigText = BigTextStyleInformation(body);
    final AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
          'pomodoro_persistent_channel',
          'Persistent Pomodoro Timer',
          channelDescription:
              'Ongoing notifications for your active Pomodoro timer.',
          importance: Importance.max,
          priority: Priority.max,
          ongoing: true,
          autoCancel: false,
          showWhen: false,
          onlyAlertOnce: true,
          largeIcon: const DrawableResourceAndroidBitmap('@mipmap/ic_launcher'),
          styleInformation: bigText,
          actions: actions,
          category: AndroidNotificationCategory.service,
          visibility: NotificationVisibility.public,
          enableLights: false,
          enableVibration: false,
          playSound: false,
          ticker: title,
        );
    final NotificationDetails platformDetails = NotificationDetails(
      android: androidDetails,
    );
    await _plugin.show(
      kPersistentTimerNotificationId,
      title,
      body,
      platformDetails,
      payload: kPayloadOpenApp,
    );
    logger.i(
      '[PersistentNotificationManager] Updated persistent title="$title" actions=$actionIds',
    );
    if (kDebugMode) {
      await debugDumpActiveNotifications();
    }
  }
  Future<void> cancel() async {
    await _plugin.cancel(kPersistentTimerNotificationId);
    logger.i(
      '[PersistentNotificationManager] Cancelled persistent notification',
    );
  }
  Future<void> debugDumpActiveNotifications() async {
    if (!Platform.isAndroid) return;
    final androidImpl = _plugin
        .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin
        >();
    if (androidImpl == null) return;
    try {
      final active = await androidImpl.getActiveNotifications();
      for (final n in active) {
        logger.d(
          '[PersistentNotificationManager] ACTIVE id=${n.id} tag=${n.tag} title=${n.title} text=${n.body}',
        );
      }
    } catch (e) {
      logger.e(
        '[PersistentNotificationManager] Error dumping active notifications: $e',
      );
    }
  }
}

================
File: flutter_app/lib/core/services/mock_api_service.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'api_service.dart';
class MockApiService extends ApiService {
  String _devUserId = 'dev';
  final Logger logger = Logger();
  @override
  String get devUserId => _devUserId;
  MockApiService(String baseUrl) : super(baseUrl) {
    logger.i(
      '[MockApiService] Initialized MockApiService with baseUrl: $baseUrl',
    );
    if (baseUrl.contains('127.0.0.1') || baseUrl.contains('localhost')) {
      _devUserId = 'dev';
    }
  }
  @override
  Future<List<dynamic>> fetchTodos() async {
    logger.d('[MockApiService] Mock fetchTodos called. Returning empty list.');
    return Future.value([]);
  }
  @override
  Future<Map<String, dynamic>> addTodo(
    String text,
    int hours,
    int minutes,
  ) async {
    logger.d(
      '[MockApiService] Mock addTodo called for: $text. Returning dummy data.',
    );
    return Future.value({
      'id': DateTime.now().millisecondsSinceEpoch,
      'user_id': _devUserId,
      'text': text,
      'completed': 0,
      'duration_hours': hours,
      'duration_minutes': minutes,
      'focused_time': 0,
      'was_overdue': 0,
      'overdue_time': 0,
      'created_at': DateTime.now().toIso8601String(),
    });
  }
  @override
  Future<dynamic> deleteTodo(int id) async {
    logger.d('[MockApiService] Mock deleteTodo called for ID: $id');
    return Future.value({'result': 'success'});
  }
  @override
  Future<dynamic> updateTodo(
    int id, {
    String? text,
    int? hours,
    int? minutes,
  }) async {
    logger.d('[MockApiService] Mock updateTodo called for ID: $id');
    return Future.value({'result': 'success'});
  }
  @override
  Future<dynamic> toggleTodoWithOverdue(
    int id, {
    bool wasOverdue = false,
    int overdueTime = 0,
  }) async {
    logger.d('[MockApiService] Mock toggleTodoWithOverdue called for ID: $id');
    return Future.value({'result': 'success'});
  }
  @override
  Future<dynamic> toggleTodo(int id) async {
    logger.d('[MockApiService] Mock toggleTodo called for ID: $id');
    return Future.value({'result': 'success'});
  }
  @override
  Future<dynamic> updateFocusTime(int id, int focusedTime) async {
    logger.d(
      '[MockApiService] Mock updateFocusTime called for ID: $id, focusedTime: $focusedTime',
    );
    return Future.value({'result': 'success'});
  }
  @override
  Future<Map<String, dynamic>> authWithIdToken(String idToken) async {
    logger.d('[MockApiService] Mock authWithIdToken called.');
    return Future.value({
      'token': 'mock_server_token',
      'user': {
        'id': 'mock_user',
        'email': 'mock@example.com',
        'name': 'Mock User',
      },
    });
  }
  @override
  void setAuthToken(String? token) {
    logger.d(
      '[MockApiService] Mock setAuthToken called with token: ${token?.substring(0, 5)}...',
    );
  }
}
final apiServiceProvider = Provider<ApiService>((ref) {
  throw UnimplementedError(
    'apiServiceProvider must be overridden in main.dart '
    'with either ApiService or MockApiService depending on the environment.',
  );
});

================
File: flutter_app/lib/features/auth/providers/auth_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/services/auth_service.dart';
import '../../../core/services/mock_api_service.dart';
class AuthState {
  final bool isAuthenticated;
  final String email;
  final String userName;
  final Map<String, dynamic>? currentUser;
  const AuthState({
    this.isAuthenticated = false,
    this.email = '',
    this.userName = '',
    this.currentUser,
  });
  AuthState copyWith({
    bool? isAuthenticated,
    String? email,
    String? userName,
    Map<String, dynamic>? currentUser,
  }) {
    return AuthState(
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      email: email ?? this.email,
      userName: userName ?? this.userName,
      currentUser: currentUser ?? this.currentUser,
    );
  }
}
class AuthNotifier extends AsyncNotifier<AuthState> {
  late AuthService _authService;
  @override
  Future<AuthState> build() async {
    final apiService = ref.watch(apiServiceProvider);
    _authService = AuthService(apiService);
    // Load saved token and check current state
    await _authService.loadSavedToken();
    await _authService.checkAuthStatus();
    return AuthState(
      isAuthenticated: _authService.isAuthenticated,
      email: _authService.userEmail ?? '',
      userName: _authService.userName ?? '',
      currentUser: _authService.currentUser,
    );
  }
  Future<void> signInWithGoogle() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final success = await _authService.signInWithGoogle();
      if (success) {
        return AuthState(
          isAuthenticated: _authService.isAuthenticated,
          email: _authService.userEmail ?? '',
          userName: _authService.userName ?? '',
          currentUser: _authService.currentUser,
        );
      } else {
        throw Exception('Google Sign-In failed');
      }
    });
  }
  Future<void> signOut() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _authService.signOut();
      return const AuthState();
    });
  }
  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _authService.checkAuthStatus();
      return AuthState(
        isAuthenticated: _authService.isAuthenticated,
        email: _authService.userEmail ?? '',
        userName: _authService.userName ?? '',
        currentUser: _authService.currentUser,
      );
    });
  }
}
final authProvider = AsyncNotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

================
File: flutter_app/lib/features/pomodoro/models/timer_state.dart
================
import 'package:flutter/foundation.dart';
@immutable
class TimerState {
  final int? activeTaskId;
  final String? activeTaskName;
  final int timeRemaining;
  final bool isRunning;
  final bool
  isTimerActive;
  final String currentMode;
  final int? plannedDurationSeconds;
  final int? focusDurationSeconds;
  final int? breakDurationSeconds;
  final int currentCycle;
  final int totalCycles;
  final int completedSessions;
  final bool isProgressBarFull;
  final bool allSessionsComplete;
  final bool overdueSessionsComplete;
  final int? overdueCrossedTaskId;
  final String? overdueCrossedTaskName;
  final Set<int> overduePromptShown;
  final Set<int> overdueContinued;
  final Map<int, int>
  focusedTimeCache;
  final bool suppressNextActivation;
  final bool
  cycleOverflowBlocked;
  final bool isPermanentlyOverdue;
  final int? backgroundStartTime;
  final int pausedTimeTotal;
  final bool wasInBackground;
  const TimerState({
    this.activeTaskId,
    this.activeTaskName,
    this.timeRemaining = 0,
    this.isRunning = false,
    this.isTimerActive = false,
    this.currentMode = 'focus',
    this.plannedDurationSeconds,
    this.focusDurationSeconds,
    this.breakDurationSeconds,
    this.currentCycle = 1,
    this.totalCycles = 1,
    this.completedSessions = 0,
    this.isProgressBarFull = false,
    this.allSessionsComplete = false,
    this.overdueSessionsComplete = false,
    this.overdueCrossedTaskId,
    this.overdueCrossedTaskName,
    this.overduePromptShown = const {},
    this.overdueContinued = const {},
    this.focusedTimeCache = const {},
    this.suppressNextActivation = false,
    this.cycleOverflowBlocked = false,
    this.isPermanentlyOverdue = false,
    this.backgroundStartTime,
    this.pausedTimeTotal = 0,
    this.wasInBackground = false,
  });
  TimerState copyWith({
    int? activeTaskId,
    String? activeTaskName,
    int? timeRemaining,
    bool? isRunning,
    bool? isTimerActive,
    String? currentMode,
    int? plannedDurationSeconds,
    int? focusDurationSeconds,
    int? breakDurationSeconds,
    int? currentCycle,
    int? totalCycles,
    int? completedSessions,
    bool? isProgressBarFull,
    bool? allSessionsComplete,
    bool? overdueSessionsComplete,
    int? overdueCrossedTaskId,
    String? overdueCrossedTaskName,
    Set<int>? overduePromptShown,
    Set<int>? overdueContinued,
    Map<int, int>? focusedTimeCache,
    bool? suppressNextActivation,
    bool? cycleOverflowBlocked,
    bool? isPermanentlyOverdue,
    int? backgroundStartTime,
    int? pausedTimeTotal,
    bool? wasInBackground,
  }) {
    return TimerState(
      activeTaskId: activeTaskId ?? this.activeTaskId,
      activeTaskName: activeTaskName ?? this.activeTaskName,
      timeRemaining: timeRemaining ?? this.timeRemaining,
      isRunning: isRunning ?? this.isRunning,
      isTimerActive: isTimerActive ?? this.isTimerActive,
      currentMode: currentMode ?? this.currentMode,
      plannedDurationSeconds:
          plannedDurationSeconds ?? this.plannedDurationSeconds,
      focusDurationSeconds: focusDurationSeconds ?? this.focusDurationSeconds,
      breakDurationSeconds: breakDurationSeconds ?? this.breakDurationSeconds,
      currentCycle: currentCycle ?? this.currentCycle,
      totalCycles: totalCycles ?? this.totalCycles,
      completedSessions: completedSessions ?? this.completedSessions,
      isProgressBarFull: isProgressBarFull ?? this.isProgressBarFull,
      allSessionsComplete: allSessionsComplete ?? this.allSessionsComplete,
      overdueSessionsComplete:
          overdueSessionsComplete ?? this.overdueSessionsComplete,
      overdueCrossedTaskId: overdueCrossedTaskId ?? this.overdueCrossedTaskId,
      overdueCrossedTaskName:
          overdueCrossedTaskName ?? this.overdueCrossedTaskName,
      overduePromptShown: overduePromptShown ?? this.overduePromptShown,
      overdueContinued: overdueContinued ?? this.overdueContinued,
      focusedTimeCache: focusedTimeCache ?? this.focusedTimeCache,
      suppressNextActivation:
          suppressNextActivation ?? this.suppressNextActivation,
      cycleOverflowBlocked: cycleOverflowBlocked ?? this.cycleOverflowBlocked,
      isPermanentlyOverdue: isPermanentlyOverdue ?? this.isPermanentlyOverdue,
      backgroundStartTime: backgroundStartTime ?? this.backgroundStartTime,
      pausedTimeTotal: pausedTimeTotal ?? this.pausedTimeTotal,
      wasInBackground: wasInBackground ?? this.wasInBackground,
    );
  }
  @override
  String toString() {
    return '''TimerState(
  activeTaskId: $activeTaskId,
  activeTaskName: ${activeTaskName != null ? '"$activeTaskName"' : null},
  isTimerActive: $isTimerActive,
  isRunning: $isRunning,
  currentMode: "$currentMode",
  timeRemaining: $timeRemaining,
  currentCycle: $currentCycle,
  totalCycles: $totalCycles,
  completedSessions: $completedSessions,
  isProgressBarFull: $isProgressBarFull,
  allSessionsComplete: $allSessionsComplete,
  isPermanentlyOverdue: $isPermanentlyOverdue,
  overdueCrossedTaskId: $overdueCrossedTaskId,
  pausedTimeTotal: $pausedTimeTotal,
  focusedTimeCache: $focusedTimeCache,
  wasInBackground: $wasInBackground,
  backgroundStartTime: $backgroundStartTime,
  )''';
  }
}

================
File: flutter_app/lib/features/pomodoro/notifications/persistent_timer_notification_model.dart
================
import '../../todo/models/todo.dart';
import '../models/timer_state.dart';
class PersistentTimerNotificationModel {
  final String title;
  final String body;
  final List<String> actionIds;
  final bool ongoing;
  const PersistentTimerNotificationModel({
    required this.title,
    required this.body,
    required this.actionIds,
    required this.ongoing,
  });
  static const String actionPause = 'pause_timer';
  static const String actionResume = 'resume_timer';
  static const String actionStop = 'stop_timer';
  static const String actionMarkComplete = 'mark_complete';
  static const String actionContinueWorking = 'continue_working';
  static PersistentTimerNotificationModel fromState({
    required TimerState state,
    required Todo? activeTodo,
  }) {
    final String taskName = activeTodo?.text ?? 'Unknown Task';
    if (state.overdueSessionsComplete) {
      return PersistentTimerNotificationModel(
        title: ' SESSIONS COMPLETE',
        body: "You have finished all planned sessions for '$taskName'.",
        actionIds: const [actionMarkComplete, actionContinueWorking],
        ongoing: true,
      );
    }
    if (state.isProgressBarFull && !state.overdueSessionsComplete) {
      return PersistentTimerNotificationModel(
        title: 'TIMER IS COMPLETE',
        body: "Planned time for '$taskName' is up.",
        actionIds: const [actionMarkComplete, actionContinueWorking],
        ongoing: true,
      );
    }
    final bool isFocus = state.currentMode == 'focus';
    if (state.isPermanentlyOverdue && isFocus && state.isRunning) {
      final int focusDuration = state.focusDurationSeconds ?? 0;
    final int rawElapsed = focusDuration - state.timeRemaining;
    final int elapsed = rawElapsed < 0
      ? 0
      : (rawElapsed > 86400 ? 86400 : rawElapsed);
      final String elapsedStr = _format(elapsed);
      return PersistentTimerNotificationModel(
        title: ' FOCUS TIME',
        body: '$taskName  $elapsedStr',
        actionIds: [state.isRunning ? actionPause : actionResume, actionStop],
        ongoing: true,
      );
    }
    final String remaining = _format(state.timeRemaining);
    final String title = isFocus ? ' FOCUS TIME' : ' BREAK TIME';
    return PersistentTimerNotificationModel(
      title: title,
      body: '$taskName  $remaining',
      actionIds: state.isRunning
          ? [actionPause, actionStop]
          : [actionResume, actionStop],
      ongoing: true,
    );
  }
  static String _format(int seconds) {
    final int m = seconds ~/ 60;
    final int s = seconds % 60;
    return '${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
  }
}

================
File: flutter_app/lib/features/pomodoro/services/timer_autosave_service.dart
================
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import '../../../core/constants/timer_defaults.dart';
import '../../../core/data/todo_repository.dart';
import '../providers/timer_provider.dart';
class TimerAutoSaveService {
  final TimerNotifier _notifier;
  final Ref _ref;
  Timer? _autoSaveTimer;
  bool _isAutoSaving = false;
  int _lastAutoSavedSeconds = 0;
  final Logger logger = Logger();
  TimerAutoSaveService(this._notifier, this._ref);
  void start() {
    stop();
    _autoSaveTimer = Timer.periodic(
      const Duration(seconds: TimerDefaults.autoSaveIntervalSeconds),
      (_) => triggerDeferredAutoSave(),
    );
  }
  void stop() {
    _autoSaveTimer?.cancel();
    _autoSaveTimer = null;
  }
  void resetLastSavedForTask(int taskId) {
    _lastAutoSavedSeconds = _notifier.state.focusedTimeCache[taskId] ?? 0;
  }
  void triggerDeferredAutoSave() {
    final int? taskId = _notifier.state.activeTaskId;
    if (taskId == null) return;
    final int currentFocused = _notifier.state.focusedTimeCache[taskId] ?? 0;
    if (currentFocused - _lastAutoSavedSeconds <
        TimerDefaults.autoSaveIntervalSeconds)
      return;
    _autoSaveFocusedTime(todoId: taskId);
  }
  Future<void> forceSaveIfNeeded() async {
    final int? taskId = _notifier.state.activeTaskId;
    if (taskId == null) return;
    await _autoSaveFocusedTime(todoId: taskId, force: true);
  }
  Future<void> _autoSaveFocusedTime({
    required int todoId,
    bool force = false,
  }) async {
    final int? taskId = _notifier.state.activeTaskId;
    if (taskId == null) return;
    final int currentFocused = _notifier.state.focusedTimeCache[taskId] ?? 0;
    if (!force && currentFocused <= _lastAutoSavedSeconds) return;
    if (_isAutoSaving) return;
    _isAutoSaving = true;
    try {
      final todoRepository = _ref.read(todoRepositoryProvider);
      await todoRepository.updateFocusTime(todoId, currentFocused);
      _lastAutoSavedSeconds = currentFocused;
      await _notifier.persistState();
    } catch (e) {
      logger.e('[TimerAutoSaveService] Error auto-saving focused time: $e');
    } finally {
      _isAutoSaving = false;
    }
  }
}

================
File: flutter_app/lib/features/pomodoro/services/timer_background_scheduler.dart
================
import 'dart:convert';
import 'package:logger/logger.dart';
import 'package:workmanager/workmanager.dart';
import '../../../core/utils/app_constants.dart';
import '../models/timer_state.dart';
import '../services/timer_persistence_manager.dart';
class TimerBackgroundScheduler {
  final TimerPersistenceManager persistenceManager;
  final Logger logger = Logger();
  TimerBackgroundScheduler(this.persistenceManager);
  Future<void> scheduleSession({
    required TimerState state,
    required String apiBaseUrl,
    required bool isDebugMode,
    required int remainingSeconds,
  }) async {
    if (remainingSeconds <= 0 ||
        !state.isRunning ||
        state.activeTaskId == null) {
      await cancelSession();
      return;
    }
    await cancelSession();
    await persistenceManager.saveApiConfig(apiBaseUrl, isDebugMode);
    await persistenceManager.saveTimerState(state);
    final int delaySeconds = remainingSeconds + 5;
    logger.i('[TimerBackgroundScheduler] Scheduling in $delaySeconds s');
    await Workmanager().registerOneOffTask(
      AppConstants.pomodoroTimerTask,
      AppConstants.pomodoroTimerTask,
      initialDelay: Duration(seconds: delaySeconds),
      existingWorkPolicy: ExistingWorkPolicy.replace,
      constraints: Constraints(
        networkType: NetworkType.notRequired,
        requiresCharging: false,
        requiresBatteryNotLow: false,
      ),
      inputData: _buildInputData(
        state,
        apiBaseUrl,
        isDebugMode,
        remainingSeconds,
      ),
    );
    await persistenceManager.setSessionScheduled(true);
  }
  Future<void> cancelSession() async {
    await Workmanager().cancelByUniqueName(AppConstants.pomodoroTimerTask);
    await persistenceManager.setSessionScheduled(false);
  }
  Map<String, dynamic> _buildInputData(
    TimerState state,
    String apiBaseUrl,
    bool isDebugMode,
    int remainingSeconds,
  ) {
    return {
      'apiBaseUrl': apiBaseUrl,
      'isDebugMode': isDebugMode,
      'activeTaskId': state.activeTaskId,
      'activeTaskText': state.activeTaskName,
      'timeRemaining': remainingSeconds,
      'currentMode': state.currentMode,
      'focusedTimeCache': json.encode(
        state.focusedTimeCache.map((k, v) => MapEntry(k.toString(), v)),
      ),
      'plannedDurationSeconds': state.plannedDurationSeconds ?? 0,
      'focusDurationSeconds': state.focusDurationSeconds ?? 0,
      'breakDurationSeconds': state.breakDurationSeconds ?? 0,
      'currentCycle': state.currentCycle,
      'totalCycles': state.totalCycles,
      'completedSessions': state.completedSessions,
      'isPermanentlyOverdue': state.isPermanentlyOverdue,
    };
  }
}

================
File: flutter_app/lib/features/pomodoro/services/timer_overdue_service.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import '../../../core/constants/sound_assets.dart';
import '../../../core/data/todo_repository.dart';
import '../../todo/providers/todos_provider.dart';
import '../../../core/providers/notification_provider.dart';
import '../providers/timer_provider.dart';
class TimerOverdueService {
  final TimerNotifier notifier;
  final Ref ref;
  final Logger logger = Logger();
  TimerOverdueService({required this.notifier, required this.ref});
  void markOverdueAndFreeze(int taskId) {
    try {
      final notificationService = ref.read(notificationServiceProvider);
      final todos = ref.read(todosProvider).value ?? [];
      final task = todos.where((t) => t.id == taskId).toList();
      if (task.isNotEmpty) {
        notificationService.playSoundWithNotification(
          soundFileName: SoundAsset.sessionComplete.fileName,
          title: 'Planned Time Complete!',
          body:
              'Time for "${task.first.text}" is up. Decide whether to continue or complete.',
        );
      }
    } catch (e) {
      logger.e('[TimerOverdueService] Notification error: $e');
    }
    notifier.update(
      isRunning: false,
      timeRemaining: 0,
      isProgressBarFull: true,
      overdueCrossedTaskId: taskId,
      plannedDurationSeconds: null,
      focusDurationSeconds: null,
      breakDurationSeconds: null,
      currentCycle: 1,
      totalCycles: 1,
    );
  }
  Future<void> markTaskPermanentlyOverdue(
    int taskId,
    int overdueSeconds,
  ) async {
    final repo = ref.read(todoRepositoryProvider);
    await repo.markTaskPermanentlyOverdue(taskId, overdueTime: overdueSeconds);
  }
}

================
File: flutter_app/lib/features/pomodoro/services/timer_persistence_manager.dart
================
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:logger/logger.dart';
import '../../../core/utils/app_constants.dart';
import '../models/timer_state.dart';
class TimerPersistenceManager {
  final SharedPreferences _prefs;
  final Logger logger = Logger();
  TimerPersistenceManager(this._prefs);
  Future<void> saveTimerState(TimerState state) async {
    await _prefs.setInt(
      AppConstants.prefActiveTaskId,
      state.activeTaskId ?? -1,
    );
    await _prefs.setString(
      AppConstants.prefActiveTaskText,
      state.activeTaskName ?? '',
    );
    await _prefs.setInt(AppConstants.prefTimeRemaining, state.timeRemaining);
    await _prefs.setBool(AppConstants.prefIsRunning, state.isRunning);
    await _prefs.setBool(AppConstants.prefIsTimerActive, state.isTimerActive);
    await _prefs.setString(AppConstants.prefCurrentMode, state.currentMode);
    await _prefs.setInt(
      AppConstants.prefPlannedDurationSeconds,
      state.plannedDurationSeconds ?? 0,
    );
    await _prefs.setInt(
      AppConstants.prefFocusDurationSeconds,
      state.focusDurationSeconds ?? 0,
    );
    await _prefs.setInt(
      AppConstants.prefBreakDurationSeconds,
      state.breakDurationSeconds ?? 0,
    );
    await _prefs.setInt(AppConstants.prefCurrentCycle, state.currentCycle);
    await _prefs.setInt(AppConstants.prefTotalCycles, state.totalCycles);
    await _prefs.setInt(
      AppConstants.prefCompletedSessions,
      state.completedSessions,
    );
    await _prefs.setBool(
      AppConstants.prefIsProgressBarFull,
      state.isProgressBarFull,
    );
    await _prefs.setBool(
      AppConstants.prefAllSessionsComplete,
      state.allSessionsComplete,
    );
    await _prefs.setBool(
      AppConstants.prefOverdueSessionsComplete,
      state.overdueSessionsComplete,
    );
    await _prefs.setInt(
      AppConstants.prefOverdueCrossedTaskId,
      state.overdueCrossedTaskId ?? -1,
    );
    await _prefs.setString(
      AppConstants.prefOverdueCrossedTaskName,
      state.overdueCrossedTaskName ?? '',
    );
    await _prefs.setStringList(
      AppConstants.prefOverduePromptShown,
      state.overduePromptShown.map((e) => e.toString()).toList(),
    );
    await _prefs.setStringList(
      AppConstants.prefOverdueContinued,
      state.overdueContinued.map((e) => e.toString()).toList(),
    );
    final Map<String, int> focusedTimeCacheStringKeys = state.focusedTimeCache
        .map((k, v) => MapEntry(k.toString(), v));
    await _prefs.setString(
      AppConstants.prefFocusedTimeCache,
      json.encode(focusedTimeCacheStringKeys),
    );
    await _prefs.setBool(
      AppConstants.prefSuppressNextActivation,
      state.suppressNextActivation,
    );
    await _prefs.setBool(
      AppConstants.prefCycleOverflowBlocked,
      state.cycleOverflowBlocked,
    );
    await _prefs.setBool(
      AppConstants.prefIsPermanentlyOverdue,
      state.isPermanentlyOverdue,
    );
    await _prefs.setInt(
      AppConstants.prefBackgroundStartTime,
      state.backgroundStartTime ?? 0,
    );
    await _prefs.setInt(
      AppConstants.prefPausedTimeTotal,
      state.pausedTimeTotal,
    );
    await _prefs.setBool(
      AppConstants.prefWasInBackground,
      state.wasInBackground,
    );
    logger.i('[TimerPersistenceManager] TimerState saved: ${state.toString()}');
  }
  TimerState? loadTimerState() {
    final int? activeTaskIdRaw = _prefs.getInt(AppConstants.prefActiveTaskId);
    if (activeTaskIdRaw == null || activeTaskIdRaw == -1)
      return null; // Nothing persisted
    final String? cacheJson = _prefs.getString(
      AppConstants.prefFocusedTimeCache,
    );
    final Map<int, int> focusedTimeCache = cacheJson != null
        ? Map<String, int>.from(
            json.decode(cacheJson),
          ).map((k, v) => MapEntry(int.parse(k), v))
        : {};
    final loaded = TimerState(
      activeTaskId: activeTaskIdRaw,
      activeTaskName: _prefs.getString(AppConstants.prefActiveTaskText),
      timeRemaining: _prefs.getInt(AppConstants.prefTimeRemaining) ?? 0,
      isRunning: _prefs.getBool(AppConstants.prefIsRunning) ?? false,
      isTimerActive: _prefs.getBool(AppConstants.prefIsTimerActive) ?? false,
      currentMode: _prefs.getString(AppConstants.prefCurrentMode) ?? 'focus',
      plannedDurationSeconds:
          _prefs.getInt(AppConstants.prefPlannedDurationSeconds) ?? 0,
      focusDurationSeconds:
          _prefs.getInt(AppConstants.prefFocusDurationSeconds) ?? 0,
      breakDurationSeconds:
          _prefs.getInt(AppConstants.prefBreakDurationSeconds) ?? 0,
      currentCycle: _prefs.getInt(AppConstants.prefCurrentCycle) ?? 1,
      totalCycles: _prefs.getInt(AppConstants.prefTotalCycles) ?? 1,
      completedSessions: _prefs.getInt(AppConstants.prefCompletedSessions) ?? 0,
      isProgressBarFull:
          _prefs.getBool(AppConstants.prefIsProgressBarFull) ?? false,
      allSessionsComplete:
          _prefs.getBool(AppConstants.prefAllSessionsComplete) ?? false,
      overdueSessionsComplete:
          _prefs.getBool(AppConstants.prefOverdueSessionsComplete) ?? false,
      overdueCrossedTaskId:
          _prefs.getInt(AppConstants.prefOverdueCrossedTaskId) == -1
          ? null
          : _prefs.getInt(AppConstants.prefOverdueCrossedTaskId),
      overdueCrossedTaskName: _prefs.getString(
        AppConstants.prefOverdueCrossedTaskName,
      ),
      overduePromptShown: Set<int>.from(
        _prefs
                .getStringList(AppConstants.prefOverduePromptShown)
                ?.map(int.parse) ??
            [],
      ),
      overdueContinued: Set<int>.from(
        _prefs
                .getStringList(AppConstants.prefOverdueContinued)
                ?.map(int.parse) ??
            [],
      ),
      focusedTimeCache: focusedTimeCache,
      suppressNextActivation:
          _prefs.getBool(AppConstants.prefSuppressNextActivation) ?? false,
      cycleOverflowBlocked:
          _prefs.getBool(AppConstants.prefCycleOverflowBlocked) ?? false,
      isPermanentlyOverdue:
          _prefs.getBool(AppConstants.prefIsPermanentlyOverdue) ?? false,
      backgroundStartTime: _prefs.getInt(AppConstants.prefBackgroundStartTime),
      pausedTimeTotal: _prefs.getInt(AppConstants.prefPausedTimeTotal) ?? 0,
      wasInBackground:
          _prefs.getBool(AppConstants.prefWasInBackground) ?? false,
    );
    logger.i('[TimerPersistenceManager] TimerState loaded: $loaded');
    return loaded;
  }
  Future<void> clearTimerState() async {
    final List<String> keys = [
      AppConstants.prefActiveTaskId,
      AppConstants.prefActiveTaskText,
      AppConstants.prefTimeRemaining,
      AppConstants.prefIsRunning,
      AppConstants.prefIsTimerActive,
      AppConstants.prefCurrentMode,
      AppConstants.prefPlannedDurationSeconds,
      AppConstants.prefFocusDurationSeconds,
      AppConstants.prefBreakDurationSeconds,
      AppConstants.prefCurrentCycle,
      AppConstants.prefTotalCycles,
      AppConstants.prefCompletedSessions,
      AppConstants.prefIsProgressBarFull,
      AppConstants.prefAllSessionsComplete,
      AppConstants.prefOverdueSessionsComplete,
      AppConstants.prefOverdueCrossedTaskId,
      AppConstants.prefOverdueCrossedTaskName,
      AppConstants.prefOverduePromptShown,
      AppConstants.prefOverdueContinued,
      AppConstants.prefFocusedTimeCache,
      AppConstants.prefSuppressNextActivation,
      AppConstants.prefCycleOverflowBlocked,
      AppConstants.prefIsPermanentlyOverdue,
      AppConstants.prefBackgroundStartTime,
      AppConstants.prefPausedTimeTotal,
      AppConstants.prefWasInBackground,
      AppConstants.prefSessionScheduled,
      AppConstants.prefApiBaseUrl,
      AppConstants.prefIsDebugMode,
    ];
    for (final k in keys) {
      await _prefs.remove(k);
    }
    logger.i('[TimerPersistenceManager] TimerState cleared from preferences.');
  }
  Future<void> setSessionScheduled(bool scheduled) async {
    await _prefs.setBool(AppConstants.prefSessionScheduled, scheduled);
  }
  bool isSessionScheduled() =>
      _prefs.getBool(AppConstants.prefSessionScheduled) ?? false;
  Future<void> saveApiConfig(String baseUrl, bool isDebug) async {
    await _prefs.setString(AppConstants.prefApiBaseUrl, baseUrl);
    await _prefs.setBool(AppConstants.prefIsDebugMode, isDebug);
  }
  (String, bool)? loadApiConfig() {
    final String? baseUrl = _prefs.getString(AppConstants.prefApiBaseUrl);
    final bool? isDebug = _prefs.getBool(AppConstants.prefIsDebugMode);
    if (baseUrl != null && isDebug != null) return (baseUrl, isDebug);
    return null;
  }
}

================
File: flutter_app/lib/features/todo/widgets/todo_list_app_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/utils/app_dialogs.dart';
import '../../auth/providers/auth_provider.dart';
class TodoListAppBar extends ConsumerWidget {
  final VoidCallback? onSignOut;
  const TodoListAppBar({this.onSignOut, super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    return AppBar(
      backgroundColor: AppColors.scaffoldBg,
      elevation: 0,
      title: Text(
        'BETAFLOW List',
        style: TextStyle(
          color: AppColors.lightGray,
          fontWeight: FontWeight.w600,
        ),
      ),
      actions: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (authState.hasValue && authState.value!.isAuthenticated) ...[
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      authState.value!.userName,
                      style: TextStyle(
                        color: AppColors.lightGray,
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    Text(
                      authState.value!.email,
                      style: TextStyle(
                        color: AppColors.lightGray.withValues(alpha: 0.7),
                        fontSize: 10,
                      ),
                    ),
                  ],
                ),
                const SizedBox(width: 8),
                PopupMenuButton<String>(
                  icon: CircleAvatar(
                    radius: 16,
                    backgroundColor: AppColors.brightYellow.withValues(
                      alpha: 0.2,
                    ),
                    child: Icon(
                      Icons.person,
                      size: 18,
                      color: AppColors.brightYellow,
                    ),
                  ),
                  color: AppColors.cardBg,
                  itemBuilder: (context) => [
                    PopupMenuItem(
                      value: 'logout',
                      child: Row(
                        children: [
                          Icon(
                            Icons.logout,
                            color: AppColors.lightGray,
                            size: 18,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Sign Out',
                            style: TextStyle(color: AppColors.lightGray),
                          ),
                        ],
                      ),
                    ),
                  ],
                  onSelected: (value) =>
                      _handleMenuSelection(context, ref, value),
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }
  Future<void> _handleMenuSelection(
    BuildContext context,
    WidgetRef ref,
    String value,
  ) async {
    if (value == 'logout') {
      final shouldLogout = await AppDialogs.showSignOutDialog(context: context);
      if (shouldLogout == true && context.mounted) {
        try {
          await ref.read(authProvider.notifier).signOut();
          onSignOut?.call();
        } catch (e) {
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Failed to sign out. Please try again.'),
                backgroundColor: Colors.redAccent,
              ),
            );
          }
        }
      }
    }
  }
}

================
File: flutter_app/test/notification_action_integration_test.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:focus_timer_app/features/pomodoro/models/timer_state.dart';
import 'package:focus_timer_app/features/pomodoro/providers/timer_provider.dart';
import 'package:focus_timer_app/core/providers/notification_action_provider.dart';
import 'package:focus_timer_app/core/providers/notification_provider.dart';
import 'package:focus_timer_app/core/services/notification_service.dart';
class _FakeNotificationService implements NotificationService {
  @override
  Function(String? payload)? onNotificationTap;
  @override
  Future<void> init() async {}
  @override
  Future<void> cancelPersistentTimerNotification() async {}
  @override
  Future<void> playSound(String soundFileName) async {}
  @override
  Future<void> playSoundWithNotification({required String soundFileName, required String title, required String body}) async {}
  @override
  Future<void> showNotification({required String title, required String body, String? payload, String? soundFileName}) async {}
  @override
  Future<void> showOrUpdatePersistent({required String title, required String body, required List<String> actionIds}) async {}
  @override
  Future<void> debugDumpActiveNotifications() async {}
  @override
  Future<void> ensurePermissions() async {}
}
class _FakeTimerNotifier extends TimerNotifier {
  String? lastAction;
  @override
  TimerState build() {
    return const TimerState(
      isRunning: true,
      isTimerActive: true,
      currentMode: 'focus',
      timeRemaining: 100,
      focusDurationSeconds: 100,
      breakDurationSeconds: 20,
      plannedDurationSeconds: 100,
    );
  }
  @override
  Future<void> handleNotificationAction(String actionId) async {
    lastAction = actionId;
    if (actionId == 'pause_timer') {
      state = state.copyWith(isRunning: false);
    } else if (actionId == 'resume_timer') {
      state = state.copyWith(isRunning: true);
    } else if (actionId == 'stop_timer') {
      state = state.copyWith(isTimerActive: false, activeTaskId: null, activeTaskName: null, isRunning: false);
    }
  }
}
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  Widget _buildHarness() {
    return Consumer(
      builder: (context, ref, _) {
        ref.listen<String?>(notificationActionProvider, (prev, next) {
          if (next != null) {
            ref.read(timerProvider.notifier).handleNotificationAction(next);
            ref.read(notificationActionProvider.notifier).state = null;
          }
        });
        final timerState = ref.watch(timerProvider);
        return Text(timerState.isRunning ? 'running' : 'paused', textDirection: TextDirection.ltr);
      },
    );
  }
  group('notificationActionProvider -> TimerNotifier wiring', () {
    testWidgets('pause then resume updates timer state', (tester) async {
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            notificationServiceProvider.overrideWithValue(_FakeNotificationService()),
            timerProvider.overrideWith(_FakeTimerNotifier.new),
          ],
          child: _buildHarness(),
        ),
      );
      expect(find.text('running'), findsOneWidget);
      final container = ProviderScope.containerOf(tester.element(find.text('running')));
      container.read(notificationActionProvider.notifier).state = 'pause_timer';
      await tester.pump();
      expect(find.text('paused'), findsOneWidget, reason: 'Should reflect paused after pause action');
      container.read(notificationActionProvider.notifier).state = 'resume_timer';
      await tester.pump();
      expect(find.text('running'), findsOneWidget, reason: 'Should reflect running after resume action');
    });
    testWidgets('stop_timer clears active timer flag', (tester) async {
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            notificationServiceProvider.overrideWithValue(_FakeNotificationService()),
            timerProvider.overrideWith(_FakeTimerNotifier.new),
          ],
          child: _buildHarness(),
        ),
      );
      final container = ProviderScope.containerOf(tester.element(find.text('running')));
      container.read(notificationActionProvider.notifier).state = 'stop_timer';
      await tester.pump();
      final state = container.read(timerProvider);
      expect(state.isTimerActive, isFalse);
      expect(state.activeTaskId, isNull);
    });
  });
}

================
File: flutter_app/test/persistent_timer_notification_model_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:focus_timer_app/features/pomodoro/notifications/persistent_timer_notification_model.dart';
import 'package:focus_timer_app/features/pomodoro/models/timer_state.dart';
import 'package:focus_timer_app/features/pomodoro/providers/timer_provider.dart';
import 'package:focus_timer_app/features/todo/models/todo.dart';
TimerState baseState() => const TimerState(
  timeRemaining: 1500,
  isRunning: true,
  currentMode: 'focus',
  focusDurationSeconds: 1500,
  breakDurationSeconds: 300,
  currentCycle: 1,
  totalCycles: 2,
);
Todo sampleTodo({bool overdue = false}) => Todo(
  id: 1,
  userId: 'u',
  text: 'Design New Logo',
  completed: false,
  durationHours: 0,
  durationMinutes: 25,
  focusedTime: overdue ? 1600 : 0,
  wasOverdue: overdue ? 1 : 0,
  overdueTime: overdue ? 100 : 0,
  createdAt: DateTime.now(),
);
void main() {
  group('PersistentTimerNotificationModel.fromState', () {
    test('standard running focus session', () {
      final model = PersistentTimerNotificationModel.fromState(
        state: baseState(),
        activeTodo: sampleTodo(),
      );
      expect(model.title, ' FOCUS TIME');
  expect(model.actionIds.first, anyOf(['pause_timer','resume_timer']));
      expect(model.actionIds, contains('stop_timer'));
    });
    test('planned time first reached (progress bar full)', () {
      final state = baseState().copyWith(isProgressBarFull: true, isRunning: false);
      final model = PersistentTimerNotificationModel.fromState(
        state: state,
        activeTodo: sampleTodo(),
      );
      expect(model.title, 'TIMER IS COMPLETE');
      expect(model.actionIds, ['mark_complete', 'continue_working']);
    });
    test('permanently overdue active focus count-up', () {
      final state = baseState().copyWith(isPermanentlyOverdue: true, timeRemaining: 1490);
      final model = PersistentTimerNotificationModel.fromState(
        state: state,
        activeTodo: sampleTodo(overdue: true),
      );
      expect(model.title, ' FOCUS TIME');
  expect(model.actionIds.first, anyOf(['pause_timer','resume_timer']));
    });
    test('overdue all planned sessions complete', () {
      final state = baseState().copyWith(
        isPermanentlyOverdue: true,
        overdueSessionsComplete: true,
        isRunning: false,
      );
      final model = PersistentTimerNotificationModel.fromState(
        state: state,
        activeTodo: sampleTodo(overdue: true),
      );
      expect(model.title, ' SESSIONS COMPLETE');
      expect(model.actionIds, ['mark_complete', 'continue_working']);
    });
    test('paused session shows resume action', () {
      final state = baseState().copyWith(isRunning: false);
      final model = PersistentTimerNotificationModel.fromState(
        state: state,
        activeTodo: sampleTodo(),
      );
      expect(model.actionIds.first, 'resume_timer');
    });
    test('running session shows pause action then stop', () {
      final state = baseState();
      final model = PersistentTimerNotificationModel.fromState(
        state: state,
        activeTodo: sampleTodo(),
      );
      expect(model.actionIds, isNotEmpty);
      expect(model.actionIds.first, 'pause_timer');
      expect(model.actionIds[1], 'stop_timer');
    });
  });
}

================
File: flutter_app/android/app/build.gradle.kts
================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
    // Google Services plugin for Firebase/Google Auth
    id("com.google.gms.google-services")
}

android {
    namespace = "com.todoapp.focus_timer"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    // Enable core library desugaring for libraries that require newer Java APIs on older
    // Android runtimes (required by flutter_local_notifications and others).
    isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // Updated to use a proper unique Application ID for production
        applicationId = "com.todoapp.focus_timer"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    // Provides backported Java core library APIs for desugaring on older Android runtimes.
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
}

================
File: flutter_app/lib/core/utils/app_dialogs.dart
================
import 'package:flutter/material.dart';
import '../theme/app_colors.dart';
class AppDialogs {
  static Future<bool?> showSwitchTaskDialog({
    required BuildContext context,
    required String currentTaskName,
    required String newTaskName,
  }) async {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Switch Task'),
        content: Text(
          'Switch to \'$newTaskName\'? This will stop the current session for \'$currentTaskName\' and save its progress.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Switch'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showOverdueDialog({
    required BuildContext context,
    required String taskName,
  }) async {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Task Complete'),
        content: Text(
          'Planned time is complete for \'$taskName\'. Mark task as done or continue working?',
        ),
        actions: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(false),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.actionSecondary,
              foregroundColor: Colors.white,
            ),
            child: const Text('Continue'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Mark Complete'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showStopSessionDialog({
    required BuildContext context,
    required String taskName,
    required int minutesWorked,
  }) async {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Stop Session'),
        content: Text(
          'Stop session for \'$taskName\'? Your progress of $minutesWorked minutes from this interval will be saved.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.priorityHigh,
              foregroundColor: Colors.white,
            ),
            child: const Text('Stop & Save'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showDeleteTaskDialog({
    required BuildContext context,
    required String taskName,
  }) async {
    return showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Task'),
        content: Text('This will remove the task "$taskName" permanently.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.priorityHigh,
              foregroundColor: Colors.white,
            ),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showSignOutDialog({
    required BuildContext context,
  }) async {
    return showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sign Out'),
        content: const Text('Are you sure you want to sign out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.priorityHigh,
              foregroundColor: Colors.white,
            ),
            child: const Text('Sign Out'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showClearCompletedDialog({
    required BuildContext context,
  }) async {
    return showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Completed Tasks'),
        content: const Text(
          'This will permanently delete all completed tasks.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.priorityHigh,
              foregroundColor: Colors.white,
            ),
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }
  static Future<void> showAddTaskDialog({
    required BuildContext context,
    required Function(String taskName, int hours, int minutes) onAddTask,
  }) async {
    final taskController = TextEditingController();
    final hoursController = TextEditingController(text: '0');
    final minutesController = TextEditingController(text: '25');
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add New Task'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: taskController,
              decoration: const InputDecoration(
                labelText: 'Task Name',
                hintText: 'Enter task name',
              ),
              autofocus: true,
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: hoursController,
                    decoration: const InputDecoration(labelText: 'Hours'),
                    keyboardType: TextInputType.number,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: TextField(
                    controller: minutesController,
                    decoration: const InputDecoration(labelText: 'Minutes'),
                    keyboardType: TextInputType.number,
                  ),
                ),
              ],
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              final taskName = taskController.text.trim();
              final hours = int.tryParse(hoursController.text) ?? 0;
              final minutes = int.tryParse(minutesController.text) ?? 25;
              if (taskName.isNotEmpty) {
                onAddTask(taskName, hours, minutes);
                Navigator.of(context).pop();
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
  static Future<void> showAllSessionsCompleteDialog({
    required BuildContext context,
    required int totalCycles,
  }) async {
    return showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Sessions Complete'),
        content: Text('You have completed all $totalCycles focus sessions!'),
        actions: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Dismiss'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showOverdueSessionCompleteDialog({
    required BuildContext context,
    required int totalCycles,
  }) async {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Session Complete'),
        content: Text(
          'Your planned number of sessions ($totalCycles/$totalCycles) is complete.',
        ),
        actions: [
          ElevatedButton(
            onPressed: () =>
                Navigator.of(context).pop(false),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.actionSecondary,
              foregroundColor: Colors.white,
            ),
            child: const Text('Continue Working'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Mark Complete'),
          ),
        ],
      ),
    );
  }
  static Future<bool?> showConfirmCompleteOverdueTaskDialog({
    required BuildContext context,
    required String taskName,
  }) async {
    return showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Completion'),
        content: Text(
          'The task "$taskName" is overdue. Are you sure you want to mark it as complete?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.brightYellow,
              foregroundColor: Colors.black,
            ),
            child: const Text('Mark Complete'),
          ),
        ],
      ),
    );
  }
}

================
File: flutter_app/lib/core/utils/debug_logger.dart
================
import 'package:logger/logger.dart';
final logger = Logger(
  printer: SimplePrinter(
    colors: true,
    printTime: false,
  ),
);

================
File: flutter_app/lib/core/widgets/progress_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import '../theme/app_colors.dart';
class ProgressBar extends StatelessWidget {
  final int focusedSeconds;
  final int plannedSeconds;
  final double barHeight;
  const ProgressBar({
    required this.focusedSeconds,
    required this.plannedSeconds,
    this.barHeight = 16.0,
    super.key,
  });
  @override
  Widget build(BuildContext context) {
    final double progress = (plannedSeconds <= 0)
        ? 0.0
        : (focusedSeconds / plannedSeconds).clamp(0.0, 1.0);
    final fillColor = AppColors.brightYellow;
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 1.0,
        horizontal: 8.0,
      ),
      child: LayoutBuilder(
        builder: (ctx, constraints) {
          final width = constraints.maxWidth;
          final progressWidth = width * progress;
          final textColor = progress > 0.5
              ? Colors.black
              : Colors.white.withAlpha((255 * 0.9).round());
          return Stack(
            children: [
              Container(
                width: width,
                height: barHeight,
                decoration: BoxDecoration(
                  color:
                      Colors.grey[900],
                  borderRadius: BorderRadius.circular(barHeight),
                ),
              ),
              AnimatedContainer(
                duration: const Duration(milliseconds: 400),
                width: progressWidth,
                height: barHeight,
                decoration: BoxDecoration(
                  color: fillColor,
                  borderRadius: BorderRadius.circular(barHeight),
                  boxShadow: [
                    BoxShadow(
                      color: fillColor.withAlpha((255 * 0.18).round()),
                      blurRadius: 8,
                      spreadRadius: 0.5,
                    ),
                  ],
                ),
              ),
              Positioned.fill(
                child: Align(
                  alignment: Alignment.center,
                  child: Text(
                    '${(progress * 100).toStringAsFixed(0)}%',
                    style: TextStyle(
                      color: textColor,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

================
File: flutter_app/lib/features/auth/screens/login_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_colors.dart';
import '../providers/auth_provider.dart';
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});
  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}
class _LoginScreenState extends ConsumerState<LoginScreen> {
  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    return Scaffold(
      backgroundColor: AppColors.scaffoldBg,
      appBar: AppBar(
        title: const Text(
          'Sign In',
          style: TextStyle(color: AppColors.lightGray),
        ),
        backgroundColor: AppColors.scaffoldBg,
        elevation: 0,
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Container(
                decoration: const BoxDecoration(),
                child: ClipOval(
                  child: Image.asset(
                    'assets/images/final_logo.png',
                    width: 220,
                    height: 220,
                    fit: BoxFit.cover,
                  ),
                ),
              ),
              const SizedBox(
                height: 20,
              ),
              Text(
                'Welcome to BETAFLOW',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: AppColors.lightGray,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Sign in with Google to sync your tasks across devices',
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: AppColors.lightGray.withValues(alpha: 0.7),
                ),
              ),
              const SizedBox(height: 48),
              authState.isLoading
                  ? Column(
                      children: [
                        CircularProgressIndicator(
                          color: AppColors.brightYellow,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Signing you in...',
                          style: TextStyle(
                            color: AppColors.lightGray.withValues(alpha: 0.7),
                          ),
                        ),
                      ],
                    )
                  : SizedBox(
                      width: double.infinity,
                      height: 56,
                      child: ElevatedButton.icon(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppColors.brightYellow,
                          foregroundColor: AppColors.scaffoldBg,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          elevation: 2,
                        ),
                        icon: const Icon(Icons.login, size: 24),
                        label: const Text(
                          'Sign in with Google',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        onPressed: () async {
                          if (kDebugMode) {
                            debugPrint('DEBUG: Login button pressed');
                          }
                          await ref
                              .read(authProvider.notifier)
                              .signInWithGoogle();
                          if (!mounted) return;
                          final currentAuthState = ref.read(authProvider);
                          currentAuthState.whenOrNull(
                            error: (error, stackTrace) {
                              if (kDebugMode) {
                                debugPrint('DEBUG: Login failed: $error');
                              }
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: const Text(
                                    'Google Sign-In failed. Please try again.',
                                  ),
                                  backgroundColor: Colors.red.shade600,
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            },
                          );
                        },
                      ),
                    ),
              const SizedBox(height: 24),
              if (kDebugMode)
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: AppColors.brightYellow.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: AppColors.brightYellow.withValues(alpha: 0.3),
                    ),
                  ),
                  child: Column(
                    children: [
                      Icon(
                        Icons.info_outline,
                        color: AppColors.brightYellow,
                        size: 20,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Development Mode',
                        style: TextStyle(
                          color: AppColors.brightYellow,
                          fontWeight: FontWeight.bold,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Using mock authentication for development. In production, this will use real Google Sign-In.',
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: AppColors.lightGray.withValues(alpha: 0.8),
                          fontSize: 11,
                        ),
                      ),
                    ],
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

================
File: flutter_app/lib/features/pomodoro/widgets/pomodoro_overdue_display.dart
================
import 'package:flutter/material.dart';
class PomodoroOverdueDisplay extends StatelessWidget {
  final int focusedSeconds;
  final int plannedSeconds;
  const PomodoroOverdueDisplay({
    required this.focusedSeconds,
    required this.plannedSeconds,
    super.key,
  });
  @override
  Widget build(BuildContext context) {
    final overdueSeconds = (focusedSeconds - plannedSeconds)
        .clamp(0, double.infinity)
        .toInt();
    final hours = overdueSeconds ~/ 3600;
    final minutes = (overdueSeconds % 3600) ~/ 60;
    final seconds = overdueSeconds % 60;
    String timeText;
    if (hours > 0) {
      timeText =
          '$hours:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
    } else {
      timeText = '$minutes:${seconds.toString().padLeft(2, '0')}';
    }
    return Container(
      height: 28.0, // Match ProgressBar height for visual consistency
      decoration: BoxDecoration(
        color: Colors.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(14.0),
        border: Border.all(color: Colors.red, width: 1.0),
      ),
      child: Center(
        child: Text(
          'OVERDUE TIME: $timeText',
          style: const TextStyle(
            color: Colors.red,
            fontSize: 16.0,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}

================
File: flutter_app/lib/features/pomodoro/widgets/pomodoro_setup_view.dart
================
import 'package:flutter/material.dart';
import '../../../core/theme/app_colors.dart';
class PomodoroSetupView extends StatelessWidget {
  final TextEditingController focusController;
  final TextEditingController breakController;
  final TextEditingController cyclesController;
  final Function(String) onFocusChanged;
  final Function(String) onBreakChanged;
  const PomodoroSetupView({
    required this.focusController,
    required this.breakController,
    required this.cyclesController,
    required this.onFocusChanged,
    required this.onBreakChanged,
    super.key,
  });
  static const double _moduleWidth = 88.0;
  static const double _connectorHeight =
      130.0;
  static const double _gap = 16.0;
  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      crossAxisAlignment: CrossAxisAlignment.end,
      children: [
        _ConfigModule(
          label: 'Work Duration',
          controller: focusController,
          onChanged: onFocusChanged,
          placeInputOnTop: true,
          width: _moduleWidth,
          connectorHeight: _connectorHeight,
          gap: _gap,
        ),
        _ConfigModule(
          label: 'Break Time',
          controller: breakController,
          onChanged: onBreakChanged,
          placeInputOnTop: false,
          width: _moduleWidth,
          connectorHeight: _connectorHeight,
          gap: _gap,
        ),
        _ConfigModule(
          label: 'Cycles',
          controller: cyclesController,
          onChanged: null,
          readOnly: true,
          placeInputOnTop: true,
          width: _moduleWidth,
          connectorHeight: _connectorHeight,
          gap: _gap,
        ),
      ],
    );
  }
}
class _ConfigModule extends StatelessWidget {
  final String label;
  final TextEditingController controller;
  final Function(String)? onChanged;
  final bool readOnly;
  final bool placeInputOnTop;
  final double width;
  final double connectorHeight;
  final double gap;
  const _ConfigModule({
    required this.label,
    required this.controller,
    required this.onChanged,
    required this.placeInputOnTop,
    required this.width,
    required this.connectorHeight,
    required this.gap,
    this.readOnly = false,
  });
  @override
  Widget build(BuildContext context) {
    final List<Widget> topSequence = [
      _NumberInput(
        controller: controller,
        readOnly: readOnly,
        onChanged: onChanged,
        width: width,
      ),
      SizedBox(height: gap),
      _ConnectorLine(height: connectorHeight),
      SizedBox(height: gap),
      _Label(text: label),
    ];
    final List<Widget> bottomSequence = [
      _Label(text: label),
      SizedBox(height: gap),
      _ConnectorLine(height: connectorHeight),
      SizedBox(height: gap),
      _NumberInput(
        controller: controller,
        readOnly: readOnly,
        onChanged: onChanged,
        width: width,
      ),
    ];
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: placeInputOnTop ? topSequence : bottomSequence,
    );
  }
}
class _NumberInput extends StatelessWidget {
  final TextEditingController controller;
  final bool readOnly;
  final Function(String)? onChanged;
  final double width;
  const _NumberInput({
    required this.controller,
    required this.readOnly,
    required this.onChanged,
    required this.width,
  });
  @override
  Widget build(BuildContext context) {
    return Container(
      width: width,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      decoration: BoxDecoration(
        color: Colors.transparent,
        border: Border.all(color: Colors.grey.shade700, width: 1.0),
        borderRadius: BorderRadius.circular(10.0),
      ),
      child: TextField(
        controller: controller,
        textAlign: TextAlign.center,
        keyboardType: TextInputType.number,
        style: const TextStyle(fontSize: 18.0, color: Colors.white),
        decoration: const InputDecoration(border: InputBorder.none),
        readOnly: readOnly,
        onChanged: onChanged,
      ),
    );
  }
}
class _ConnectorLine extends StatelessWidget {
  final double height;
  const _ConnectorLine({required this.height});
  @override
  Widget build(BuildContext context) {
    return Container(width: 2, height: height, color: AppColors.brightYellow);
  }
}
class _Label extends StatelessWidget {
  final String text;
  const _Label({required this.text});
  @override
  Widget build(BuildContext context) {
    return Text(
      text,
      style: const TextStyle(
        fontSize: 12.0,
        color: AppColors.brightYellow,
        fontWeight: FontWeight.w600,
      ),
    );
  }
}

================
File: flutter_app/lib/features/todo/models/todo.dart
================
class Todo {
  final int id;
  final String userId;
  final String text;
  final bool completed;
  final int durationHours;
  final int durationMinutes;
  final int focusedTime;
  final int wasOverdue;
  final int overdueTime;
  final DateTime createdAt;
  Todo({
    required this.id,
    required this.userId,
    required this.text,
    required this.completed,
    required this.durationHours,
    required this.durationMinutes,
    required this.focusedTime,
    required this.wasOverdue,
    required this.overdueTime,
    required this.createdAt,
  });
  Todo copyWith({
    int? id,
    String? userId,
    String? text,
    bool? completed,
    int? durationHours,
    int? durationMinutes,
    int? focusedTime,
    int? wasOverdue,
    int? overdueTime,
    DateTime? createdAt,
  }) {
    return Todo(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      text: text ?? this.text,
      completed: completed ?? this.completed,
      durationHours: durationHours ?? this.durationHours,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      focusedTime: focusedTime ?? this.focusedTime,
      wasOverdue: wasOverdue ?? this.wasOverdue,
      overdueTime: overdueTime ?? this.overdueTime,
      createdAt: createdAt ?? this.createdAt,
    );
  }
  @override
  String toString() {
    return '''Todo(
  id: $id,
  text: "${text.replaceAll('\n', '\\n')}",
  completed: $completed,
  focusedTime: $focusedTime,
  wasOverdue: $wasOverdue,
  overdueTime: $overdueTime,
  createdAt: $createdAt,
  )''';
  }
}

================
File: flutter_app/test/widget_test.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:focus_timer_app/app.dart';
void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    await tester.pumpWidget(const App());
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

================
File: flutter_app/android/app/src/main/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.USE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <application
        android:label="flutter_app"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher"
        android:usesCleartextTraffic="true">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <receiver android:exported="false" android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver" />
        <receiver android:exported="false" android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON" />
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>
        <receiver android:exported="false" android:name="com.dexterous.flutterlocalnotifications.ActionBroadcastReceiver" />
        <service
            android:name="com.dexterous.flutterlocalnotifications.ForegroundService"
            android:exported="false"
            android:stopWithTask="false"
            android:foregroundServiceType="mediaPlayback">
        </service>
        <service
            android:name="dev.flutter.plugins.workmanager.WorkmanagerService"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:exported="false"/>
        <receiver
            android:name="dev.flutter.plugins.workmanager.WorkmanagerBroadcastReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON" />
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>
        <receiver
            android:name="dev.flutter.plugins.workmanager.RescheduleReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED"/>
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED"/>
            </intent-filter>
        </receiver>
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

================
File: flutter_app/lib/features/pomodoro/widgets/pomodoro_action_buttons.dart
================
import 'package:flutter/material.dart';
import '../../../core/theme/app_colors.dart';
import '../models/timer_state.dart';
class PomodoroActionButtons extends StatelessWidget {
  final TimerState timerState;
  final VoidCallback onReset;
  final VoidCallback onPlayPause;
  final VoidCallback onSkip;
  const PomodoroActionButtons({
    required this.timerState,
    required this.onReset,
    required this.onPlayPause,
    required this.onSkip,
    super.key,
  });
  @override
  Widget build(BuildContext context) {
    final isRunning = timerState.isRunning;
    final isSetupMode = !timerState.isRunning && timerState.currentCycle == 0;
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            _buildActionButton(
              icon: Icons.replay_rounded,
              label: 'Reset',
              onPressed: onReset,
              isSecondary: true,
            ),
            _buildMainActionButton(
              icon: isRunning ? Icons.pause_rounded : Icons.play_arrow_rounded,
              label: isSetupMode ? 'Start' : (isRunning ? 'Pause' : 'Resume'),
              onPressed: onPlayPause,
            ),
            _buildActionButton(
              icon: Icons.fast_forward_rounded,
              label: 'Skip',
              onPressed: onSkip,
              isSecondary: true,
            ),
          ],
        ),
        const SizedBox(height: 24),
      ],
    );
  }
  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
    bool isSecondary = false,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            border: Border.all(color: AppColors.brightYellow, width: 2.0),
          ),
          child: OutlinedButton(
            style: OutlinedButton.styleFrom(
              shape: const CircleBorder(),
              side: const BorderSide(color: Colors.transparent),
              padding: const EdgeInsets.all(12),
            ),
            onPressed: onPressed,
            child: Icon(icon, color: AppColors.brightYellow, size: 22),
          ),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 12,
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }
  Widget _buildMainActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: 72,
          height: 72,
          child: FloatingActionButton(
            backgroundColor: AppColors.brightYellow,
            onPressed: onPressed,
            child: Icon(icon, color: Colors.black, size: 40),
          ),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 14,
            fontWeight: FontWeight.w700,
          ),
        ),
      ],
    );
  }
}

================
File: flutter_app/lib/features/pomodoro/widgets/pomodoro_timer_view.dart
================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../../core/constants/timer_defaults.dart';
import '../models/timer_state.dart';
class PomodoroTimerView extends StatelessWidget {
  final TimerState timerState;
  const PomodoroTimerView({required this.timerState, super.key});
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(
          '${(timerState.focusDurationSeconds ?? TimerDefaults.focusSeconds) ~/ 60} / ${(timerState.breakDurationSeconds ?? TimerDefaults.breakSeconds) ~/ 60} / ${timerState.totalCycles}',
          style: const TextStyle(
            fontSize: 16.0,
            fontWeight: FontWeight.w600,
            color: Colors.white,
          ),
        ),
        const SizedBox(height: 12),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              '${timerState.currentCycle} / ${timerState.totalCycles}',
              style: const TextStyle(
                fontSize: 28.0,
                fontWeight: FontWeight.w900,
                color: Colors.white,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        const Divider(color: Color(0xFF262626)),
        const SizedBox(height: 12),
        Flexible(
          flex: 5,
          fit: FlexFit.loose,
          child: Center(
            child: IntrinsicWidth(
              child: DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: timerState.currentMode == 'focus'
                        ? Colors.redAccent
                        : Colors.greenAccent,
                    width: 6.0,
                  ),
                  borderRadius: BorderRadius.circular(14.0),
                ),
                child: Container(
                  alignment: Alignment.center,
                  padding: const EdgeInsets.all(20.0),
                  child: Text(
                    _formatTime(timerState.timeRemaining),
                    textAlign: TextAlign.center,
                    style: GoogleFonts.oswald(
                      fontSize: 120.0,
                      fontWeight: FontWeight.w700,
                      letterSpacing: -2.0,
                      height: 1.05,
                      color: Colors.white,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
        const SizedBox(height: 12),
        const Divider(color: Color(0xFF262626)),
      ],
    );
  }
  String _formatTime(int seconds) {
    final m = (seconds ~/ 60).toString().padLeft(2, '0');
    final s = (seconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }
}

================
File: flutter_app/lib/features/todo/widgets/inline_task_input.dart
================
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import '../../../core/theme/app_colors.dart';
class InlineTaskInput extends StatefulWidget {
  final Function(String taskName, int hours, int minutes) onAddTask;
  const InlineTaskInput({required this.onAddTask, super.key});
  @override
  State<InlineTaskInput> createState() => _InlineTaskInputState();
}
class _InlineTaskInputState extends State<InlineTaskInput> {
  final _taskController = TextEditingController();
  final _hoursController = TextEditingController(text: '0');
  final _minutesController = TextEditingController(text: '25');
  final _taskFocusNode = FocusNode();
  final Logger logger = Logger();
  void _onAddButtonPressed() {
    logger.i('[InlineTaskInput]  ADD BUTTON TAPPED!');
    _handleSubmit();
  }
  void _handleSubmit() {
    logger.i(
      '[InlineTaskInput]  ADD BUTTON PRESSED - Starting _handleSubmit',
    );
    final String taskName = _taskController.text.trim();
    final int hours = int.tryParse(_hoursController.text) ?? 0;
    final int minutes = int.tryParse(_minutesController.text) ?? 25;
    logger.d(
      '[InlineTaskInput] Attempting to add task: "$taskName" (${hours}h ${minutes}m)',
    );
    if (taskName.isEmpty) {
      logger.w('[InlineTaskInput] Validation failed: Task name is empty.');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Task name cannot be empty.'),
          backgroundColor: Colors.orange,
        ),
      );
      _taskFocusNode.requestFocus();
      return;
    }
    if (hours == 0 && minutes == 0) {
      logger.w('[InlineTaskInput] Validation failed: Task duration is zero.');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Task duration must be greater than 0 minutes.'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }
    logger.i('[InlineTaskInput] Validation passed. Calling onAddTask...');
    widget.onAddTask(taskName, hours, minutes);
    _taskController.clear();
    logger.i('[InlineTaskInput] Task input fields cleared.');
  }
  @override
  void dispose() {
    _taskController.dispose();
    _hoursController.dispose();
    _minutesController.dispose();
    _taskFocusNode.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          controller: _taskController,
          focusNode: _taskFocusNode,
          style: TextStyle(color: AppColors.lightGray, fontSize: 16),
          decoration: InputDecoration(
            hintText: 'What do you need to do?',
            hintStyle: TextStyle(color: AppColors.mediumGray, fontSize: 16),
            filled: true,
            fillColor: AppColors.midGray,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 16,
              vertical: 14,
            ),
          ),
          onSubmitted: (_) => _onAddButtonPressed(),
          textInputAction: TextInputAction.done,
        ),
        const SizedBox(height: 12),
        Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            _DurationInputBox(controller: _hoursController, unit: 'h'),
            const SizedBox(width: 12),
            _DurationInputBox(controller: _minutesController, unit: 'm'),
            const Spacer(),
            SizedBox(
              height: 48,
              child: ElevatedButton(
                onPressed: _onAddButtonPressed,
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppColors.brightYellow,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(10),
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                ),
                child: const Text(
                  'Add',
                  style: TextStyle(
                    color: Colors.black,
                    fontWeight: FontWeight.w700,
                    fontSize: 16,
                  ),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }
}
class _DurationInputBox extends StatelessWidget {
  final TextEditingController controller;
  final String unit;
  const _DurationInputBox({required this.controller, required this.unit});
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 80,
      height: 48,
      decoration: BoxDecoration(
        color: AppColors.midGray,
        borderRadius: BorderRadius.circular(10),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: controller,
              style: TextStyle(
                color: AppColors.lightGray,
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
              decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                contentPadding: EdgeInsets.zero,
              ),
              keyboardType: TextInputType.number,
              textAlign: TextAlign.start,
            ),
          ),
          Text(
            unit,
            style: TextStyle(
              color: AppColors.mediumGray,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }
}

================
File: flutter_app/lib/app.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'dart:async';
import 'core/theme/app_colors.dart';
import 'core/widgets/auth_wrapper.dart';
import 'features/pomodoro/providers/timer_provider.dart';
import 'core/providers/notification_action_provider.dart';
import 'core/bridge/notification_action_dispatcher.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'core/utils/debug_logger.dart';
class App extends ConsumerStatefulWidget {
  const App({super.key});
  @override
  ConsumerState<App> createState() => _AppState();
}
class _AppState extends ConsumerState<App> with WidgetsBindingObserver {
  bool _initialActionFlushed = false;
  Timer? _actionPoller;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    registerNotificationActionDispatcher((String actionId) {
      logger.i("App Dispatcher: Delivering action='$actionId' to provider.");
      ref.read(notificationActionProvider.notifier).state = actionId;
      return true;
    });
    _actionPoller = Timer.periodic(const Duration(seconds: 1), (_) async {
      await _flushPendingAction();
    });
  }
  Future<void> _flushPendingAction() async {
    try {
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      final String? last = prefs.getString('last_notification_action');
      if (last != null) {
        debugPrint('APP_FLUSH: detected pending action=$last');
        ref.read(notificationActionProvider.notifier).state = last;
        await prefs.remove('last_notification_action');
      }
    } catch (_) {
    }
  }
  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    clearNotificationActionDispatcher();
    _actionPoller?.cancel();
    super.dispose();
  }
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    final notifier = ref.read(timerProvider.notifier);
    if (state == AppLifecycleState.paused ||
        state == AppLifecycleState.detached) {
      notifier.scheduleBackgroundPersistence();
    } else if (state == AppLifecycleState.resumed) {
      _flushPendingAction();
      notifier.cancelBackgroundPersistence();
    }
  }
  @override
  Widget build(BuildContext context) {
    if (!_initialActionFlushed) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        if (_initialActionFlushed) return;
        await _flushPendingAction();
        _initialActionFlushed = true;
      });
    }
    ref.listen<String?>(notificationActionProvider, (prev, next) {
      if (next != null) {
        logger.d(
          "App Listener: Provider received action='$next'. Forwarding to TimerNotifier.",
        );
        ref.read(timerProvider.notifier).handleNotificationAction(next);
        ref.read(notificationActionProvider.notifier).state = null;
      }
    });
    return MaterialApp(
      title: 'Todo Flutter',
      theme: ThemeData.dark().copyWith(
        primaryColor: AppColors.brightYellow,
        scaffoldBackgroundColor: AppColors.scaffoldBg,
        textTheme: GoogleFonts.interTextTheme(
          ThemeData.dark().textTheme,
        ).apply(bodyColor: AppColors.lightGray),
      ),
      home: const AuthWrapper(),
    );
  }
}

================
File: flutter_app/test/timer_provider_overdue_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:focus_timer_app/features/pomodoro/providers/timer_provider.dart';
void main() {
  test('focused time accumulates while running in focus mode', () async {
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final notifier = container.read(timerProvider.notifier);
    notifier.update(
      activeTaskId: 1,
      activeTaskName: 'Test Task',
      isTimerActive: true,
      isRunning: true,
      currentMode: 'focus',
      timeRemaining: 3,
      focusDurationSeconds: 3,
      breakDurationSeconds: 2,
      plannedDurationSeconds: 3,
    );
    notifier.startTicker();
    await Future.delayed(const Duration(seconds: 4));
    final focused = notifier.getFocusedTime(1);
    expect(
      focused >= 3,
      isTrue,
      reason: 'Should record at least planned focus seconds',
    );
  });
  test(
    'overdue crossing sets overdueCrossedTaskName and freezes timer',
    () async {
      final container = ProviderContainer();
      addTearDown(container.dispose);
      final notifier = container.read(timerProvider.notifier);
      notifier.update(
        activeTaskId: 2,
        activeTaskName: 'taskB',
        isTimerActive: true,
        isRunning: true,
        currentMode: 'focus',
        timeRemaining: 1,
        focusDurationSeconds: 1,
        breakDurationSeconds: 1,
        plannedDurationSeconds: 1,
      );
      notifier.startTicker();
      await Future.delayed(const Duration(seconds: 2));
      final state = container.read(timerProvider);
      expect(state.overdueCrossedTaskName, 'taskB');
      expect(state.isRunning, isFalse, reason: 'Timer should freeze');
      expect(state.timeRemaining, 0);
    },
  );
}

================
File: flutter_app/test/timer_service_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:focus_timer_app/features/pomodoro/providers/timer_provider.dart';
void main() {
  test('timerProvider initial state', () {
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final state = container.read(timerProvider);
    expect(state.activeTaskId, isNull);
    expect(state.timeRemaining, 0);
    expect(state.isRunning, isFalse);
    expect(state.currentMode, 'focus');
  });
  test('update and focused time cache via notifier', () {
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final notifier = container.read(timerProvider.notifier);
    notifier.update(
      activeTaskId: 1,
      timeRemaining: 120,
      isRunning: true,
      isTimerActive: true,
      currentMode: 'focus',
    );
    notifier.updateFocusedTime(1, 30);
    final state = container.read(timerProvider);
    expect(state.activeTaskId, 1);
    expect(state.timeRemaining, 120);
    expect(state.isRunning, isTrue);
    expect(notifier.getFocusedTime(1), 30);
  });
}

================
File: flutter_app/lib/core/services/api_service.dart
================
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../utils/debug_logger.dart';
class ApiService {
  final Dio _dio;
  final int _maxRetries = 3;
  final Duration _retryDelay = const Duration(milliseconds: 500);
  final String _devUserId = 'dev';
  ApiService(String baseUrl)
    : _dio = Dio(
        BaseOptions(
          baseUrl: baseUrl,
          connectTimeout: const Duration(seconds: 5),
        ),
      ) {
    final String lowerBaseUrl = baseUrl.toLowerCase();
    if (lowerBaseUrl.contains('127.0.0.1') ||
        lowerBaseUrl.contains('localhost') ||
        lowerBaseUrl.contains('10.0.2.2')) {
      _dio.options.headers['x-user-id'] = _devUserId;
      logger.d('[ApiService] Set x-user-id header for local dev: $_devUserId');
    }
  }
  String get devUserId => _devUserId;
  void setAuthToken(String? token) {
    if (token != null) {
      _dio.options.headers['Authorization'] = 'Bearer $token';
    } else {
      _dio.options.headers.remove('Authorization');
    }
  }
  Future<Map<String, dynamic>> authWithIdToken(String idToken) async {
    final Response<dynamic> resp = await _dio.post(
      '/api/auth',
      data: {'id_token': idToken},
    );
    return resp.data as Map<String, dynamic>;
  }
  Future<List<dynamic>> fetchTodos() async {
    final Response<dynamic> resp = await _withRetry(
      () => _dio.get('/api/todos'),
    );
    return resp.data as List<dynamic>;
  }
  Future<dynamic> addTodo(String text, int hours, int minutes) async {
    final Response<dynamic> resp = await _withRetry(
      () => _dio.post(
        '/add',
        data: <String, dynamic>{
          'text': text,
          'duration_hours': hours,
          'duration_minutes': minutes,
        },
      ),
    );
    try {
      if (kDebugMode) debugPrint('ApiService.addTodo response: ${resp.data}');
    } catch (_) {}
    return resp.data;
  }
  Future<dynamic> deleteTodo(int id) async {
    final Response<dynamic> resp = await _withRetry(
      () => _dio.post('/delete', data: {'id': id}),
    );
    return resp.data;
  }
  Future<dynamic> updateTodo(
    int id, {
    String? text,
    int? hours,
    int? minutes,
  }) async {
    final Map<String, dynamic> data = <String, dynamic>{'id': id};
    if (text != null) data['text'] = text;
    if (hours != null) data['duration_hours'] = hours;
    if (minutes != null) data['duration_minutes'] = minutes;
    final Response<dynamic> resp = await _dio.post('/update', data: data);
    return resp.data;
  }
  Future<dynamic> toggleTodo(int id) async {
    final Response<dynamic> resp = await _withRetry(
      () => _dio.post('/toggle', data: {'id': id}),
    );
    return resp.data;
  }
  Future<dynamic> toggleTodoWithOverdue(
    int id, {
    bool wasOverdue = false,
    int overdueTime = 0,
  }) async {
    final Map<String, dynamic> payload = <String, dynamic>{
      'id': id,
      'was_overdue': wasOverdue ? 1 : 0,
      'overdue_time': overdueTime,
    };
    final Response<dynamic> resp = await _withRetry(
      () => _dio.post('/toggle', data: payload),
    );
    return resp.data;
  }
  Future<dynamic> updateFocusTime(int id, int focusedTime) async {
    final Response<dynamic> resp = await _withRetry(
      () => _dio.post(
        '/update_focus_time',
        data: <String, dynamic>{'id': id, 'focused_time': focusedTime},
      ),
    );
    return resp.data;
  }
  Future<Response<dynamic>> _withRetry(
    Future<Response<dynamic>> Function() fn,
  ) async {
    int attempt = 0;
    while (true) {
      try {
        return await fn();
      } on DioException catch (e) {
        final bool isConnError =
            e.type == DioExceptionType.connectionError ||
            e.error is Error ||
            (e.message?.toLowerCase().contains('connection refused') ?? false);
        if (e.type == DioExceptionType.badResponse) {
          logger.e(
            '[ApiService] API Error: Status ${e.response?.statusCode}, Data: ${e.response?.data}, Message: ${e.message}',
          );
        } else {
          logger.e(
            '[ApiService] Network Error: Type ${e.type}, Message: ${e.message}, Error: ${e.error}, Stack: ${e.stackTrace}',
          );
        }
        if (!isConnError || attempt >= _maxRetries - 1) {
          rethrow;
        }
        attempt++;
        logger.w(
          '[ApiService] Transient connection error, retrying ($attempt/$_maxRetries) in ${_retryDelay.inMilliseconds}ms ...',
        );
        await Future.delayed(_retryDelay);
      }
    }
  }
}

================
File: flutter_app/lib/core/services/auth_service.dart
================
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:logger/logger.dart';
import 'dart:convert';
import 'api_service.dart';
class AuthService extends ChangeNotifier {
  final FlutterSecureStorage _secure = const FlutterSecureStorage();
  final ApiService api;
  final Logger logger = Logger();
  Map<String, dynamic>? _currentUser;
  bool _isAuthenticated = false;
  AuthService(this.api);
  Map<String, dynamic>? get currentUser => _currentUser;
  bool get isAuthenticated => _isAuthenticated;
  String? get userEmail => _currentUser?['email'];
  String? get userName => _currentUser?['name'] ?? _currentUser?['email'];
  Future<bool> signInWithGoogle() async {
    try {
      logger.i('[AuthService] Initiating mock Google Sign-In...');
      final String mockIdToken =
          'mock_id_token_${DateTime.now().millisecondsSinceEpoch}';
      logger.d(
        '[AuthService] Generated mock token: ${mockIdToken.substring(0, 20)}...',
      );
      final bool result = await signInWithIdToken(mockIdToken);
      logger.i('[AuthService] signInWithIdToken returned: $result');
      return result;
    } catch (error, stackTrace) {
      logger.e('[AuthService] Mock sign-in error: $error');
      logger.e('[AuthService] Stack trace: $stackTrace');
      return false;
    }
  }
  Future<bool> signInWithIdToken(String idToken) async {
    try {
      if (kDebugMode) logger.d('[AuthService] Sending ID token to backend...');
      logger.d('[AuthService] API instance type: ${api.runtimeType}');
      final Map<String, dynamic> resp = await api.authWithIdToken(idToken);
      logger.i('[AuthService] Backend response received: $resp');
      final dynamic token = resp['token'];
      final dynamic user = resp['user'];
      if (token != null && user != null) {
        logger.i(
          '[AuthService] Valid token and user received, storing credentials...',
        );
        await _secure.write(key: 'server_token', value: token as String);
        await _secure.write(key: 'user_data', value: json.encode(user));
        api.setAuthToken(token as String?);
        _currentUser = user as Map<String, dynamic>;
        _isAuthenticated = true;
        if (kDebugMode) {
          logger.i(
            '[AuthService] Authentication successful for user: ${user['email']}',
          );
        }
        logger.d('[AuthService] Calling notifyListeners...');
        notifyListeners();
        return true;
      }
      if (kDebugMode) logger.w('[AuthService] No token received from backend');
      return false;
    } catch (error, stackTrace) {
      if (kDebugMode)
        logger.e('[AuthService] Backend authentication error: $error');
      if (kDebugMode) logger.e('[AuthService] Stack trace: $stackTrace');
      return false;
    }
  }
  Future<void> signOut() async {
    try {
      if (kDebugMode) logger.i('[AuthService] Signing out...');
      await _secure.delete(key: 'server_token');
      await _secure.delete(key: 'user_data');
      api.setAuthToken(null);
      _currentUser = null;
      _isAuthenticated = false;
      if (kDebugMode) logger.i('[AuthService] Sign out complete');
      notifyListeners();
    } catch (error) {
      if (kDebugMode) logger.e('[AuthService] Sign out error: $error');
    }
  }
  Future<void> loadSavedToken() async {
    try {
      final String? token = await _secure.read(key: 'server_token');
      final String? userDataString = await _secure.read(key: 'user_data');
      if (token != null) {
        api.setAuthToken(token);
        _isAuthenticated = true;
        if (userDataString != null) {
          _currentUser = json.decode(userDataString) as Map<String, dynamic>;
        }
        if (kDebugMode) logger.i('[AuthService] Loaded saved authentication');
        notifyListeners();
      }
    } catch (error) {
      if (kDebugMode)
        logger.e('[AuthService] Error loading saved token: $error');
    }
  }
  Future<bool> checkAuthStatus() async {
    final String? token = await _secure.read(key: 'server_token');
    _isAuthenticated = token != null;
    notifyListeners();
    return _isAuthenticated;
  }
}

================
File: flutter_app/lib/features/todo/providers/todos_provider.dart
================
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/todo.dart';
import '../../../core/data/todo_repository.dart';
import '../../../core/utils/debug_logger.dart';
class TodosNotifier extends AsyncNotifier<List<Todo>> {
  StreamSubscription<List<Todo>>? _todosSubscription;
  @override
  Future<List<Todo>> build() async {
    logger.i('[TodosNotifier] Building TodosNotifier...');
    final repository = ref.watch(todoRepositoryProvider);
    try {
      await repository.syncTodos();
      logger.i('[TodosNotifier] Initial sync with API completed.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Initial API sync failed',
        error: e,
        stackTrace: st,
      );
    }
    _todosSubscription = repository.watchTodos().listen(
      (todos) {
        logger.d(
          '[TodosNotifier] Received ${todos.length} todos from local DB stream.',
        );
        state = AsyncValue.data(todos);
      },
      onError: (e, st) {
        logger.e(
          '[TodosNotifier] Error in local DB stream',
          error: e,
          stackTrace: st,
        );
        state = AsyncValue.error(e, st);
      },
    );
    ref.onDispose(() {
      _todosSubscription?.cancel();
      logger.d(
        '[TodosNotifier] TodosNotifier disposed, subscription cancelled.',
      );
    });
    final initialTodos = await repository.watchTodos().first;
    logger.d(
      '[TodosNotifier] Initial data from local DB: ${initialTodos.length} todos.',
    );
    return initialTodos;
  }
  Future<void> addTodo(String text, int hours, int minutes) async {
    logger.i('[TodosNotifier] Attempting to add todo: "$text"');
    state = const AsyncValue.loading();
    try {
      await ref.read(todoRepositoryProvider).addTodo(text, hours, minutes);
      logger.i('[TodosNotifier] Todo "$text" added successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to add todo "$text"',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(
        e,
        st,
      );
      rethrow;
    } finally {
    }
  }
  Future<void> deleteTodo(int id) async {
    logger.i('[TodosNotifier] Attempting to delete todo ID: $id');
    try {
      await ref.read(todoRepositoryProvider).deleteTodo(id);
      logger.i('[TodosNotifier] Todo ID: $id deleted successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to delete todo ID: $id',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> updateTodo(
    int id, {
    String? text,
    int? hours,
    int? minutes,
  }) async {
    logger.i('[TodosNotifier] Attempting to update todo ID: $id');
    try {
      await ref
          .read(todoRepositoryProvider)
          .updateTodo(id: id, text: text, hours: hours, minutes: minutes);
      logger.i('[TodosNotifier] Todo ID: $id updated successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to update todo ID: $id',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> toggleTodo(int id, {int? liveFocusedTime}) async {
    logger.i('[TodosNotifier] Attempting to toggle todo ID: $id completion.');
    try {
      await ref
          .read(todoRepositoryProvider)
          .toggleTodo(id, liveFocusedTime: liveFocusedTime);
      logger.i('[TodosNotifier] Todo ID: $id toggled successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to toggle todo ID: $id',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> toggleTodoWithOverdue(
    int id, {
    required bool wasOverdue,
    required int overdueTime,
  }) async {
    logger.i(
      '[TodosNotifier] Attempting to toggle todo ID: $id with overdue status.',
    );
    try {
      await ref
          .read(todoRepositoryProvider)
          .toggleTodoWithOverdue(
            id,
            wasOverdue: wasOverdue,
            overdueTime: overdueTime,
          );
      logger.i(
        '[TodosNotifier] Todo ID: $id toggled with overdue status successfully.',
      );
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to toggle todo ID: $id with overdue status',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> markTaskPermanentlyOverdue(
    int id, {
    required int overdueTime,
  }) async {
    logger.i('[TodosNotifier] Marking todo ID: $id as permanently overdue.');
    try {
      await ref
          .read(todoRepositoryProvider)
          .markTaskPermanentlyOverdue(id, overdueTime: overdueTime);
      logger.i(
        '[TodosNotifier] Todo ID: $id marked as permanently overdue successfully.',
      );
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to mark todo ID: $id as permanently overdue',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> updateFocusTime(int id, int focusedTime) async {
    logger.d(
      '[TodosNotifier] Updating focus time for todo ID: $id to $focusedTime seconds.',
    );
    try {
      await ref.read(todoRepositoryProvider).updateFocusTime(id, focusedTime);
      logger.d(
        '[TodosNotifier] Focus time for todo ID: $id updated successfully.',
      );
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to update focus time for todo ID: $id',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
  Future<void> clearCompleted() async {
    logger.i('[TodosNotifier] Attempting to clear completed todos.');
    try {
      await ref.read(todoRepositoryProvider).clearCompleted();
      logger.i('[TodosNotifier] Completed todos cleared successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Failed to clear completed todos',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    } finally {
    }
  }
  Future<void> refresh() async {
    logger.i(
      '[TodosNotifier] Manually refreshing todos (triggering API sync)...',
    );
    state = const AsyncValue.loading();
    try {
      await ref.read(todoRepositoryProvider).syncTodos();
      logger.i('[TodosNotifier] Manual refresh completed successfully.');
    } catch (e, st) {
      logger.e(
        '[TodosNotifier] Manual refresh failed',
        error: e,
        stackTrace: st,
      );
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}
final todosProvider = AsyncNotifierProvider<TodosNotifier, List<Todo>>(
  TodosNotifier.new,
);

================
File: flutter_app/pubspec.yaml
================
name: focus_timer_app
description: "A focused productivity app with todo management and Pomodoro timer."
publish_to: 'none'
version: 1.0.1+2
environment:
  sdk: ^3.9.0
metadata:
  company: "TodoApp Inc."
  copyright: " 2025 TodoApp Inc."
dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.8
  dio: ^5.9.0
  google_sign_in: 7.0.0
  flutter_secure_storage: ^9.2.4
  shared_preferences: ^2.5.3
  flutter_local_notifications: ^19.4.0
  audioplayers: ^6.5.0
  google_fonts: ^6.3.0
  flutter_riverpod: ^2.6.1
  riverpod_annotation: ^2.6.1
  drift: ^2.28.1
  sqlite3_flutter_libs: ^0.5.39
  path_provider: ^2.1.5
  path: ^1.9.0
  workmanager: ^0.9.0+3
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  riverpod_generator: ^2.6.5
  build_runner: ^2.5.4
  drift_dev: ^2.28.0
  flutter_launcher_icons: "^0.13.1"
  flutter_native_splash: "^2.4.0"
  logger: ^2.3.0
flutter:
  uses-material-design: true
  assets:
    - assets/sounds/
    - assets/images/
flutter_icons:
  android: true
  ios: true
  image_path: "assets/images/final_logo.png"
  min_sdk_android: 21
  remove_alpha_ios: true
flutter_native_splash:
  color: "#1A1A1A"
  image: "assets/images/final_logo.png"
  android: true
  ios: true
  web: false
  ios_content_mode: "center"
  android_gravity: "center"
  fullscreen: true

================
File: flutter_app/lib/core/services/notification_service.dart
================
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:logger/logger.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:io' show Platform;
import 'notifications/notification_constants.dart';
import 'notifications/notification_permission_manager.dart';
import 'notifications/persistent_notification_manager.dart';
import 'notifications/notification_sound_player.dart';
abstract class INotificationService {
  Function(String? payload)? onNotificationTap;
  Future<void> init();
  Future<void> ensurePermissions();
  Future<void> showNotification({
    required String title,
    required String body,
    String? payload,
    String? soundFileName,
  });
  Future<void> showOrUpdatePersistent({
    required String title,
    required String body,
    required List<String> actionIds,
  });
  Future<void> cancelPersistentTimerNotification();
  Future<void> playSound(String soundFileName);
  Future<void> playSoundWithNotification({
    required String soundFileName,
    required String title,
    required String body,
  });
}
class NotificationService implements INotificationService {
  final FlutterLocalNotificationsPlugin _plugin =
      FlutterLocalNotificationsPlugin();
  late final NotificationPermissionManager _permissionManager =
      NotificationPermissionManager(_plugin);
  late final PersistentNotificationManager _persistentManager =
      PersistentNotificationManager(_plugin);
  late final NotificationSoundPlayer _soundPlayer = NotificationSoundPlayer();
  final Logger logger = Logger();
  @override
  Function(String? payload)? onNotificationTap;
  @override
  Future<void> init() async {
    const AndroidInitializationSettings initAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');
    const InitializationSettings settings = InitializationSettings(
      android: initAndroid,
    );
    await _plugin.initialize(
      settings,
      onDidReceiveNotificationResponse: (NotificationResponse resp) async {
        logger.i(
          " (Foreground) Notification tap received: action='${resp.actionId}', payload='${resp.payload}'",
        );
        final String? action = resp.actionId;
        if (action != null) {
          onNotificationTap?.call(action);
          return;
        }
        if (resp.payload == kPayloadOpenApp) {
          onNotificationTap?.call(resp.payload);
        }
      },
      onDidReceiveBackgroundNotificationResponse: _notificationTapBackground,
    );
    if (Platform.isAndroid) {
      final AndroidFlutterLocalNotificationsPlugin? android = _plugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();
      if (android != null) {
        await android.createNotificationChannel(
          const AndroidNotificationChannel(
            'pomodoro_persistent_channel',
            'Persistent Pomodoro Timer',
            description:
                'Ongoing notifications for your active Pomodoro timer.',
            importance: Importance.max,
            showBadge: false,
          ),
        );
        await android.createNotificationChannel(
          const AndroidNotificationChannel(
            'pomodoro_channel',
            'Pomodoro Notifications',
            description: 'Notifications for Pomodoro timer events',
            importance: Importance.max,
          ),
        );
      }
    }
    logger.i('[NotificationService] Initialized & channels created');
  }
  @override
  Future<void> ensurePermissions() => _permissionManager.ensurePermissions();
  @pragma('vm:entry-point')
  @pragma('vm:entry-point')
  static void _notificationTapBackground(
    NotificationResponse notificationResponse,
  ) {
    print(
      " (Background) Notification tap received: action='${notificationResponse.actionId}', payload='${notificationResponse.payload}'",
    );
    final String? action =
        notificationResponse.actionId ?? notificationResponse.payload;
    if (action == null) return;
    SharedPreferences.getInstance().then((prefs) async {
      await prefs.setString('last_notification_action', action);
      print(" (Background) Action persisted to SharedPreferences: '$action'");
    });
  }
  @override
  Future<void> showNotification({
    required String title,
    required String body,
    String? payload,
    String? soundFileName,
  }) async {
    AndroidNotificationDetails androidPlatformChannelSpecifics;
    if (soundFileName != null) {
      final soundName = soundFileName.replaceAll(
        '.wav',
        '',
      ); // Remove extension
      androidPlatformChannelSpecifics = AndroidNotificationDetails(
        'pomodoro_channel',
        'Pomodoro Notifications',
        channelDescription: 'Notifications for Pomodoro timer events',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: false,
        sound: RawResourceAndroidNotificationSound(soundName),
        enableLights: true,
        enableVibration: true,
        playSound: true,
      );
    } else {
      androidPlatformChannelSpecifics = const AndroidNotificationDetails(
        'pomodoro_channel',
        'Pomodoro Notifications',
        channelDescription: 'Notifications for Pomodoro timer events',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: false,
      );
    }
    final NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
    );
    await _plugin.show(
      DateTime.now()
          .millisecondsSinceEpoch,
      title,
      body,
      platformChannelSpecifics,
      payload: payload,
    );
  }
  @override
  Future<void> showOrUpdatePersistent({
    required String title,
    required String body,
    required List<String> actionIds,
  }) => _persistentManager.showOrUpdate(
    title: title,
    body: body,
    actionIds: actionIds,
  );
  Future<void> debugDumpActiveNotifications() =>
      _persistentManager.debugDumpActiveNotifications();
  @override
  Future<void> cancelPersistentTimerNotification() =>
      _persistentManager.cancel();
  @override
  Future<void> playSound(String soundFileName) =>
      _soundPlayer.playSound(soundFileName);
  @override
  Future<void> playSoundWithNotification({
    required String soundFileName,
    required String title,
    required String body,
  }) async {
    logger.i(
      '[NotificationService] playSoundWithNotification title="$title" body="$body" sound=$soundFileName',
    );
    await playSound(soundFileName);
    await showNotification(
      title: title,
      body: body,
      soundFileName: soundFileName,
      payload: 'sound_notification',
    );
    logger.i('[NotificationService] Sound notification shown title="$title"');
  }
}

================
File: flutter_app/lib/features/pomodoro/widgets/mini_timer_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/constants/timer_defaults.dart';
import '../providers/timer_provider.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/services/notification_service.dart';
import '../../todo/models/todo.dart';
import '../pomodoro_router.dart';
import '../../../core/utils/app_dialogs.dart';
import '../../../core/services/api_service.dart';
class MiniTimerBar extends ConsumerWidget {
  final ApiService api;
  final NotificationService notificationService;
  final Todo? activeTodo;
  final Future<void> Function(int) onComplete;
  const MiniTimerBar({
    required this.api,
    required this.notificationService,
    this.activeTodo,
    required this.onComplete,
    super.key,
  });
  String _format(int seconds) {
    final String m = (seconds ~/ 60).toString().padLeft(2, '0');
    final String s = (seconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final timer = ref.watch(timerProvider);
    final notifier = ref.read(timerProvider.notifier);
    if (!timer.isTimerActive || timer.activeTaskId == null) {
      return const SizedBox.shrink();
    }
    final bool keyboardVisible = MediaQuery.of(context).viewInsets.bottom > 0;
    if (keyboardVisible) {
      return const SizedBox.shrink();
    }
    final Color borderColor = timer.currentMode == 'focus'
        ? Colors.redAccent
        : Colors.greenAccent;
    return GestureDetector(
      onTap: () async {
        await PomodoroRouter.showPomodoroSheet(
          context,
          api,
          activeTodo ??
              Todo(
                id: timer.activeTaskId ?? 0,
                userId: '',
                text: 'Unknown Task',
                completed: false,
                durationHours: 0,
                durationMinutes: 0,
                focusedTime: 0,
                wasOverdue: 0,
                overdueTime: 0,
                createdAt: DateTime.now(),
              ),
          notificationService,
          ({bool wasOverdue = false, int overdueTime = 0}) async {
            if (activeTodo != null) {
              await onComplete(activeTodo!.id);
            }
          },
        );
      },
      child: Container(
        decoration: BoxDecoration(
          color: AppColors.cardBg,
          borderRadius: BorderRadius.circular(12.0),
          border: Border.all(color: borderColor, width: 3),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    _format(timer.timeRemaining),
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    activeTodo?.text ?? 'Unknown Task',
                    style: const TextStyle(
                      color: Color(0xFFFFD54F),
                      fontWeight: FontWeight.w700,
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                ],
              ),
            ),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  onPressed: notifier.toggleRunning,
                  icon: Icon(
                    timer.isRunning
                        ? Icons.pause_rounded
                        : Icons.play_arrow_rounded,
                    color: AppColors.brightYellow,
                  ),
                ),
                IconButton(
                  onPressed: () async {
                    if (activeTodo == null) {
                      notifier.clear();
                      return;
                    }
                    final bool wasRunning = timer.isRunning;
                    if (wasRunning) notifier.pauseTask();
                    final int totalFocusDuration =
                        timer.focusDurationSeconds ?? TimerDefaults.focusSeconds;
                    final int timeRemaining = timer.timeRemaining;
                    final int minutesWorked =
                        ((totalFocusDuration - timeRemaining) / 60).round();
                    final bool? shouldStop = await AppDialogs.showStopSessionDialog(
                      context: context,
                      taskName: activeTodo!.text,
                      minutesWorked: minutesWorked,
                    );
                    if (shouldStop != true) {
                      if (wasRunning) notifier.resumeTask();
                      return;
                    }
                    await notifier.stopAndSaveProgress(activeTodo!.id);
                  },
                  icon: const Icon(
                    Icons.close_rounded,
                    color: Colors.red,
                    size: 20,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================
File: flutter_app/lib/features/pomodoro/pomodoro_router.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/services/api_service.dart';
import '../../core/services/notification_service.dart';
import '../../core/theme/app_colors.dart';
import '../todo/models/todo.dart';
import 'pomodoro_screen.dart';
import 'providers/timer_provider.dart';
typedef TaskCompletedCallback =
    Future<void> Function({bool wasOverdue, int overdueTime});
class PomodoroRouter {
  static Future<void> showPomodoroSheet(
    BuildContext context,
    ApiService api,
    Todo todo,
    NotificationService notificationService,
    TaskCompletedCallback onTaskCompleted,
  ) async {
    void updateMinibarOnDismiss() {
      final container = ProviderScope.containerOf(context, listen: false);
      final timerState = container.read(timerProvider);
      final timerNotifier = container.read(timerProvider.notifier);
      final bool isSetupMode =
          !timerState.isRunning && timerState.currentCycle == 0;
      if (timerState.activeTaskId != null) {
        if (isSetupMode) {
          timerNotifier.clearPreserveProgress();
        } else {
          timerNotifier.update(isTimerActive: true);
        }
      }
    }
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black,
      builder: (context) => FractionallySizedBox(
        heightFactor: 0.85,
        alignment: Alignment.bottomCenter,
        child: Container(
          decoration: const BoxDecoration(
            color: AppColors.cardBg,
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: PomodoroScreen(
            api: api,
            todo: todo,
            notificationService: notificationService,
            asSheet: true,
            onTaskCompleted: onTaskCompleted,
          ),
        ),
      ),
    );
    updateMinibarOnDismiss();
  }
}

================
File: flutter_app/lib/features/pomodoro/pomodoro_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/services/api_service.dart';
import '../../core/services/notification_service.dart';
import '../../core/theme/app_colors.dart';
import '../../core/widgets/progress_bar.dart';
import '../../core/utils/app_dialogs.dart';
import '../todo/models/todo.dart';
import '../../core/constants/timer_defaults.dart';
import 'providers/timer_provider.dart';
import 'models/timer_state.dart';
import 'widgets/pomodoro_action_buttons.dart';
import 'widgets/pomodoro_setup_view.dart';
import 'widgets/pomodoro_timer_view.dart';
typedef TaskCompletedCallback =
    Future<void> Function({bool wasOverdue, int overdueTime});
class PomodoroScreen extends ConsumerStatefulWidget {
  final ApiService api;
  final Todo todo;
  final NotificationService notificationService;
  final TaskCompletedCallback onTaskCompleted;
  final bool asSheet;
  const PomodoroScreen({
    required this.api,
    required this.todo,
    required this.notificationService,
    required this.onTaskCompleted,
    this.asSheet = false,
    super.key,
  });
  @override
  ConsumerState<PomodoroScreen> createState() => _PomodoroScreenState();
}
class _PomodoroScreenState extends ConsumerState<PomodoroScreen> {
  late TextEditingController _focusController;
  late TextEditingController _breakController;
  late TextEditingController _cyclesController;
  @override
  void initState() {
    super.initState();
    final timerState = ref.read(timerProvider);
    _focusController = TextEditingController(
  text: ((timerState.focusDurationSeconds ?? TimerDefaults.focusSeconds) ~/ 60).toString(),
    );
    _breakController = TextEditingController(
  text: ((timerState.breakDurationSeconds ?? TimerDefaults.breakSeconds) ~/ 60).toString(),
    );
    _cyclesController = TextEditingController(
      text: timerState.totalCycles.toString(),
    );
    _focusController.addListener(_onDurationsChanged);
    _breakController.addListener(_onDurationsChanged);
    _cyclesController.addListener(_onDurationsChanged);
  }
  void _onDurationsChanged() {
    final focusMinutes = int.tryParse(_focusController.text) ?? 25;
    final breakMinutes = int.tryParse(_breakController.text) ?? 5;
    final plannedSeconds =
        (widget.todo.durationHours * 3600) + (widget.todo.durationMinutes * 60);
    int calculatedCycles = 4;
    if (plannedSeconds > 0 && focusMinutes > 0) {
      calculatedCycles = (plannedSeconds / (focusMinutes * 60)).ceil().clamp(
        1,
        1000,
      );
    }
    if (_cyclesController.text != calculatedCycles.toString()) {
      _cyclesController.text = calculatedCycles.toString();
    }
    ref
        .read(timerProvider.notifier)
        .updateDurations(
          focusDuration: focusMinutes * 60,
          breakDuration: breakMinutes * 60,
          totalCycles: calculatedCycles,
        );
  }
  @override
  void dispose() {
    _focusController.removeListener(_onDurationsChanged);
    _breakController.removeListener(_onDurationsChanged);
    _cyclesController.removeListener(_onDurationsChanged);
    _focusController.dispose();
    _breakController.dispose();
    _cyclesController.dispose();
    super.dispose();
  }
  void _handlePlayPause() {
    final notifier = ref.read(timerProvider.notifier);
    final timerState = ref.read(timerProvider);
    if (!timerState.isRunning && timerState.currentCycle == 0) {
      final focusDurationMinutes = int.tryParse(_focusController.text) ?? 25;
      final focusDurationSeconds = focusDurationMinutes * 60;
      final plannedDurationSeconds =
          (widget.todo.durationHours * 3600) +
          (widget.todo.durationMinutes * 60);
      final isPermanentOverdueMode = widget.todo.wasOverdue == 1;
      if (plannedDurationSeconds > 0 &&
          focusDurationSeconds > plannedDurationSeconds) {
        _showFocusDurationValidationError(
          focusDurationMinutes,
          widget.todo.durationHours,
          widget.todo.durationMinutes,
        );
        return;
      }
      notifier.startTask(
        taskId: widget.todo.id,
        taskName: widget.todo.text,
        focusDuration: focusDurationSeconds,
        breakDuration: (int.tryParse(_breakController.text) ?? 5) * 60,
        plannedDuration: plannedDurationSeconds,
        totalCycles: int.tryParse(_cyclesController.text) ?? 4,
        isPermanentlyOverdue: isPermanentOverdueMode,
      );
    } else {
      notifier.toggleRunning();
    }
  }
  void _handleReset() {
    ref.read(timerProvider.notifier).resetCurrentPhase();
  }
  void _handleSkip() {
    ref.read(timerProvider.notifier).skipPhase();
  }
  Future<void> _handleStop() async {
    final notifier = ref.read(timerProvider.notifier);
    final timerState = ref.read(timerProvider);
    if (timerState.activeTaskId == null) {
      notifier.clear();
      if (mounted) Navigator.of(context).pop();
      return;
    }
    final wasRunning = timerState.isRunning;
    if (wasRunning) notifier.pauseTask();
    final phaseDuration = timerState.currentMode == 'focus'
        ? (timerState.focusDurationSeconds ?? 0)
        : (timerState.breakDurationSeconds ?? 0);
    final elapsedInPhase = phaseDuration - timerState.timeRemaining;
    final minutesWorkedThisInterval = (elapsedInPhase / 60).round();
    final shouldStop = await AppDialogs.showStopSessionDialog(
      context: context,
      taskName: widget.todo.text,
      minutesWorked: minutesWorkedThisInterval,
    );
    if (!mounted) return;
    if (shouldStop == true) {
      await notifier.stopAndSaveProgress(widget.todo.id);
      Navigator.of(context).pop();
    } else {
      if (wasRunning) notifier.resumeTask();
    }
  }
  void _showFocusDurationValidationError(
    int focusMinutes,
    int taskHours,
    int taskMinutes,
  ) {
    final totalTaskMinutes = (taskHours * 60) + taskMinutes;
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text(
          'Invalid Focus Duration',
          style: TextStyle(color: Colors.red),
        ),
        content: Text(
          'Focus duration ($focusMinutes minutes) cannot be longer than the total task duration ($totalTaskMinutes minutes).\n\nPlease reduce the focus duration or increase the task duration.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
  void _showAllSessionsCompleteDialog(BuildContext context, int totalCycles) {
    AppDialogs.showAllSessionsCompleteDialog(
      context: context,
      totalCycles: totalCycles,
    ).then((_) {
      ref.read(timerProvider.notifier).clearAllSessionsCompleteFlag();
    });
  }
  Widget _buildStatusIndicator({
    required bool isPermanentOverdue,
    required bool isSetupMode,
    required int focusedSeconds,
    required int plannedSeconds,
  }) {
    final content = isPermanentOverdue
        ? _buildOverdueText(focusedSeconds, plannedSeconds)
        : ProgressBar(
            focusedSeconds: focusedSeconds,
            plannedSeconds: plannedSeconds,
            barHeight: 24.0,
          );
    return Padding(
      padding: EdgeInsets.only(top: isSetupMode ? 16.0 : 0),
      child: SizedBox(height: 28.0, child: content),
    );
  }
  Widget _buildOverdueText(int focusedSeconds, int plannedSeconds) {
    final overdueSeconds = (focusedSeconds - plannedSeconds)
        .clamp(0, 99999)
        .toInt();
    final minutes = (overdueSeconds ~/ 60).toString();
    final seconds = (overdueSeconds % 60).toString().padLeft(2, '0');
    return Center(
      child: Text(
        'OVERDUE TIME: $minutes:$seconds',
        style: const TextStyle(
          color: AppColors.priorityHigh,
          fontSize: 18.0,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
  ref.listen<TimerState>(timerProvider, (previous, next) {
      if (next.allSessionsComplete &&
          !(previous?.allSessionsComplete ?? false)) {
    if (!mounted) return;
    _showAllSessionsCompleteDialog(context, next.totalCycles);
      }
      if (next.overdueSessionsComplete &&
          !(previous?.overdueSessionsComplete ?? false)) {
        debugPrint(
          "POMODORO_SCREEN: Detected overdueSessionsComplete. Popping.",
        );
        if (!mounted) return;
        final navigator = Navigator.of(context);
        if (navigator.canPop()) {
          navigator.pop();
        }
      }
      if (next.cycleOverflowBlocked &&
          !(previous?.cycleOverflowBlocked ?? false)) {
        if (!mounted) return;
        final navigator = Navigator.of(context);
        showDialog(
          context: context,
          builder: (dialogCtx) => AlertDialog(
            title: const Text('Action Not Allowed'),
            content: Text(
              'Cannot set more than ${next.totalCycles} cycles for this task duration.',
            ),
            actions: [
              TextButton(
                onPressed: () {
                  navigator.pop();
                  ref.read(timerProvider.notifier).clearCycleOverflowBlockedFlag();
                },
                child: const Text('Dismiss'),
              ),
            ],
          ),
        );
      }
    });
    final timerState = ref.watch(timerProvider);
    final isSetupMode = !timerState.isRunning && timerState.currentCycle == 0;
    final focusedSeconds =
        timerState.focusedTimeCache[widget.todo.id] ?? widget.todo.focusedTime;
    final plannedSeconds =
        (widget.todo.durationHours * 3600) + (widget.todo.durationMinutes * 60);
    final isPermanentOverdueMode = widget.todo.wasOverdue == 1;
    return Stack(
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              if (widget.asSheet)
                Container(
                  width: 40,
                  height: 5,
                  decoration: BoxDecoration(
                    color: Colors.grey[600],
                    borderRadius: BorderRadius.circular(10),
                  ),
                ),
              const SizedBox(height: 50),
              Text(
                widget.todo.text,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  color: AppColors.brightYellow,
                  fontSize: 26.0,
                  fontWeight: FontWeight.w900,
                  letterSpacing: 0.6,
                ),
              ),
              const SizedBox(height: 20),
              _buildStatusIndicator(
                isPermanentOverdue: isPermanentOverdueMode,
                isSetupMode: isSetupMode,
                focusedSeconds: focusedSeconds,
                plannedSeconds: plannedSeconds,
              ),
              const SizedBox(height: 30),
              Expanded(
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 300),
                  child: isSetupMode
                      ? PomodoroSetupView(
                          key: const ValueKey('setup'),
                          focusController: _focusController,
                          breakController: _breakController,
                          cyclesController: _cyclesController,
                          onFocusChanged: (val) {},
                          onBreakChanged: (val) {},
                        )
                      : PomodoroTimerView(
                          key: const ValueKey('timer'),
                          timerState: timerState,
                        ),
                ),
              ),
              const SizedBox(height: 20),
              PomodoroActionButtons(
                timerState: timerState,
                onPlayPause: _handlePlayPause,
                onReset: _handleReset,
                onSkip: _handleSkip,
              ),
            ],
          ),
        ),
        if (!isSetupMode)
          Positioned(
            top: 10,
            right: 10,
            child: IconButton(
              icon: const Icon(Icons.close, color: Colors.white, size: 28),
              onPressed: _handleStop,
            ),
          ),
      ],
    );
  }
}

================
File: flutter_app/lib/features/todo/widgets/task_card.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_colors.dart';
import '../models/todo.dart';
import '../../pomodoro/providers/timer_provider.dart';
typedef PlayCallback = Future<void> Function(Todo todo);
class TaskCard extends ConsumerWidget {
  final Todo todo;
  final PlayCallback onPlay;
  final Future<void> Function() onDelete;
  final Future<void> Function() onToggle;
  final bool isActive;
  const TaskCard({
    required this.todo,
    required this.onPlay,
    required this.onDelete,
    required this.onToggle,
    this.isActive = false,
    super.key,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return todo.completed
        ? _buildCompletedTask(context)
        : _buildIncompleteTask(context, ref);
  }
  Widget _buildIncompleteTask(BuildContext context, WidgetRef ref) {
    final isPermanentlyOverdue = todo.wasOverdue == 1;
    final timerState = ref.watch(timerProvider);
    final focusedSeconds =
        timerState.focusedTimeCache[todo.id] ?? todo.focusedTime;
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: AppColors.midGray,
        borderRadius: BorderRadius.circular(12),
        border: isActive
            ? Border.all(color: AppColors.brightYellow, width: 2.0)
            : Border.all(color: Colors.transparent, width: 2.0),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  todo.text,
                  style: const TextStyle(
                    color: AppColors.lightGray,
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 6),
                Text(
                  '${todo.durationHours}h ${todo.durationMinutes}m',
                  style: TextStyle(
                    color: AppColors.mediumGray,
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                if (isPermanentlyOverdue)
                  Padding(
                    padding: const EdgeInsets.only(top: 4.0),
                    child: Text(
                      'Overdue: ${_formatOverdueDuration((focusedSeconds - ((todo.durationHours * 3600) + (todo.durationMinutes * 60))).clamp(0, 999999).toInt())}',
                      style: const TextStyle(
                        color: AppColors.priorityHigh,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
          ),
          _buildActionButtons(context, ref),
        ],
      ),
    );
  }
  Widget _buildCompletedTask(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
  color: AppColors.cardBg.withValues(alpha: 0.5),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      todo.text,
                      style: TextStyle(
                        color: AppColors.mediumGray,
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                        fontStyle: FontStyle.italic,
                        decoration: TextDecoration.none,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      '${todo.durationHours}h ${todo.durationMinutes}m',
                      style: TextStyle(
                        color: AppColors.mediumGray.withValues(alpha: 0.7),
                        fontSize: 13,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              Row(
                children: [
                  Opacity(
                    opacity: 0.0,
                    child: IconButton(
                      icon: const Icon(Icons.play_arrow, size: 24),
                      onPressed: () {},
                      padding: const EdgeInsets.all(4),
                      constraints: const BoxConstraints(
                        minWidth: 32,
                        minHeight: 32,
                      ),
                    ),
                  ),
                  IconButton(
                    onPressed: onToggle,
                    icon: const Icon(
                      Icons.replay,
                      color: AppColors.mediumGray,
                      size: 24,
                    ),
                    padding: const EdgeInsets.all(4),
                    constraints: const BoxConstraints(
                      minWidth: 32,
                      minHeight: 32,
                    ),
                  ),
                  IconButton(
                    onPressed: onDelete,
                    icon: const Icon(
                      Icons.delete_outline,
                      color: AppColors.mediumGray,
                      size: 24,
                    ),
                    padding: const EdgeInsets.all(4),
                    constraints: const BoxConstraints(
                      minWidth: 32,
                      minHeight: 32,
                    ),
                  ),
                ],
              ),
            ],
          ),
          const SizedBox(height: 8),
          _buildCompletionStatus(),
        ],
      ),
    );
  }
  Widget _buildCompletionStatus() {
    final plannedSeconds =
        (todo.durationHours * 3600) + (todo.durationMinutes * 60);
    final completedTag = const Text(
      'Completed',
      style: TextStyle(
        color: AppColors.priorityLow,
        fontSize: 13,
        fontWeight: FontWeight.bold,
      ),
    );
    if (todo.wasOverdue == 1) {
      final formattedDuration = _formatOverdueDuration(todo.overdueTime);
      final overdueTag = Text(
        'Overdue: $formattedDuration',
        style: const TextStyle(
          color: AppColors.priorityHigh,
          fontSize: 13,
          fontWeight: FontWeight.bold,
        ),
      );
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [overdueTag, const SizedBox(height: 4.0), completedTag],
      );
    }
    if (plannedSeconds > 0 && todo.focusedTime < plannedSeconds) {
      final percent = ((todo.focusedTime / plannedSeconds) * 100)
          .toStringAsFixed(0);
      final underdueTag = Text(
        'Underdue ($percent%)',
        style: const TextStyle(
          color: Colors.orangeAccent,
          fontSize: 13,
          fontWeight: FontWeight.bold,
        ),
      );
      return Wrap(spacing: 8.0, children: [underdueTag]);
    }
    return Wrap(spacing: 8.0, children: [completedTag]);
  }
  String _formatOverdueDuration(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0;
    final duration = Duration(seconds: totalSeconds);
    final minutes = duration.inMinutes;
    final seconds = totalSeconds % 60;
    if (minutes > 0) {
      return '${minutes}m ${seconds}s';
    } else {
      return '${seconds}s';
    }
  }
  Widget _buildActionButtons(BuildContext context, WidgetRef ref) {
    final timerState = ref.watch(timerProvider);
    final isThisTaskActive = timerState.activeTaskId == todo.id;
    final isThisTaskRunning = isThisTaskActive && timerState.isRunning;
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          onPressed: () {
            if (isThisTaskActive) {
              ref.read(timerProvider.notifier).toggleRunning();
            } else {
              onPlay(todo);
            }
          },
          icon: Icon(
            isThisTaskRunning ? Icons.pause : Icons.play_arrow,
            color: todo.completed ? AppColors.mediumGray : AppColors.lightGray,
            size: 24,
          ),
          padding: const EdgeInsets.all(4),
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
        ),
        IconButton(
          onPressed: onToggle,
          icon: const Icon(Icons.check, color: AppColors.lightGray, size: 24),
          padding: const EdgeInsets.all(4),
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
        ),
        IconButton(
          onPressed: onDelete,
          icon: const Icon(
            Icons.delete_outline,
            color: AppColors.lightGray,
            size: 24,
          ),
          padding: const EdgeInsets.all(4),
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
        ),
      ],
    );
  }
}

================
File: flutter_app/lib/features/todo/widgets/task_list.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/services/notification_service.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/utils/app_dialogs.dart';
import '../models/todo.dart';
import './task_card.dart';
import '../providers/todos_provider.dart';
import '../../pomodoro/providers/timer_provider.dart';
import '../../pomodoro/models/timer_state.dart';
import '../../pomodoro/pomodoro_router.dart';
import '../../../core/widgets/progress_bar.dart';
import '../../../core/services/api_service.dart';
import '../../../core/constants/timer_defaults.dart';
enum CompletedFilter { none, onTime, overdue, underdue }
class TaskList extends ConsumerStatefulWidget {
  final List<Todo> todos;
  final ApiService api;
  final NotificationService notificationService;
  final Function(String id) onPlay;
  final Function(String id) onDelete;
  final Function(String id) onToggle;
  final ValueChanged<bool>? onExpansionChanged;
  const TaskList({
    required this.todos,
    required this.api,
    required this.notificationService,
    required this.onPlay,
    required this.onDelete,
    required this.onToggle,
    this.onExpansionChanged,
    super.key,
  });
  @override
  ConsumerState<TaskList> createState() => _TaskListState();
}
class _TaskListState extends ConsumerState<TaskList> {
  bool _completedExpanded = false;
  CompletedFilter _activeFilter = CompletedFilter.none;
  bool _shouldShowOverdueCompletionDialog = false;
  Todo? _overdueTodoForDialog;
  String _getFilterName(CompletedFilter filter) {
    switch (filter) {
      case CompletedFilter.onTime:
        return 'Completed';
      case CompletedFilter.overdue:
        return 'Overdue';
      case CompletedFilter.underdue:
        return 'Underdue';
      case CompletedFilter.none:
        return '';
    }
  }
  @override
  Widget build(BuildContext context) {
    // Principle 3: Listen to provider state changes to trigger UI events
    ref.listen<TimerState>(timerProvider, (previous, next) {
      final bool wasComplete = previous?.overdueSessionsComplete ?? false;
      final bool isComplete = next.overdueSessionsComplete;
      // When the specific flag becomes true, prepare to show the dialog
      if (isComplete && !wasComplete && next.activeTaskId != null) {
        debugPrint(
          "TASK_LIST LISTENER: Detected overdueSessionsComplete for task ID ${next.activeTaskId}",
        );
        Todo? foundTodo;
        try {
          foundTodo = widget.todos.firstWhere((t) => t.id == next.activeTaskId);
        } catch (e) {
          debugPrint(
            "TASK_LIST LISTENER: Todo with ID ${next.activeTaskId} not found in current list",
          );
          return;
        }
        if (mounted) {
          setState(() {
            _overdueTodoForDialog = foundTodo;
            _shouldShowOverdueCompletionDialog = true;
          });
        }
      }
    });
    // If the flag is set, schedule the dialog to show after the build is complete.
    if (_shouldShowOverdueCompletionDialog && _overdueTodoForDialog != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        // Double-check flag and mounted status before showing
        if (mounted && _shouldShowOverdueCompletionDialog) {
          _showOverdueSessionCompletionPrompt(_overdueTodoForDialog!);
          // Reset the flag immediately after scheduling
          setState(() {
            _shouldShowOverdueCompletionDialog = false;
            _overdueTodoForDialog = null;
          });
        }
      });
    }
    final List<Todo> incompleteTodos = widget.todos.where((t) => !t.completed).toList();
    final List<Todo> completedTodos = widget.todos.where((t) => t.completed).toList();
    // Apply the active filter to the list of completed todos.
    final List<Todo> filteredCompletedTodos = completedTodos.where((todo) {
      if (_activeFilter == CompletedFilter.none) {
        return true;
      }
      final int plannedSeconds =
          (todo.durationHours * 3600) + (todo.durationMinutes * 60);
      final bool isOverdue = todo.wasOverdue == 1;
      final bool isUnderdue =
          plannedSeconds > 0 && todo.focusedTime < plannedSeconds;
      switch (_activeFilter) {
        case CompletedFilter.overdue:
          return isOverdue;
        case CompletedFilter.underdue:
          return isUnderdue;
        case CompletedFilter.onTime: // Logic for "Completed" only
          return !isOverdue && !isUnderdue;
        case CompletedFilter.none:
          return true;
      }
    }).toList();
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (incompleteTodos.isNotEmpty)
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: incompleteTodos.length,
              separatorBuilder: (context, index) => const SizedBox(height: 8),
              itemBuilder: (context, index) {
                final Todo todo = incompleteTodos[index];
                return Column(
                  children: [
                    _buildTaskCard(todo),
                    const SizedBox(height: 8),
                    _TaskStatusIndicator(todo: todo),
                  ],
                );
              },
            )
          else
            const Center(
              child: Padding(
                padding: EdgeInsets.symmetric(vertical: 40.0),
                child: Text(
                  'No active tasks.\nAdd one above to get started!',
                  style: TextStyle(color: AppColors.lightGray, fontSize: 16),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
          if (completedTodos.isNotEmpty) ...[
            const SizedBox(height: 16),
            const Divider(
              color: AppColors.brightYellow,
              thickness: 1.5,
              height: 48,
              indent: 20,
              endIndent: 20,
            ),
            Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: Colors.transparent),
              child: ExpansionTile(
                initiallyExpanded: _completedExpanded,
                onExpansionChanged: (bool expanded) {
                  setState(() {
                    _completedExpanded = expanded;
                  });
                  widget.onExpansionChanged?.call(expanded);
                },
                controlAffinity: ListTileControlAffinity.leading,
                tilePadding: const EdgeInsets.symmetric(horizontal: 16),
                title: Row(
                  children: [
                    const Text(
                      'Completed',
                      style: TextStyle(
                        color: AppColors.lightGray,
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (_activeFilter != CompletedFilter.none)
                      Padding(
                        padding: const EdgeInsets.only(left: 8.0),
                        child: Text(
                          '(${_getFilterName(_activeFilter)})',
                          style: const TextStyle(
                            color: AppColors.brightYellow,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                  ],
                ),
                trailing: const SizedBox.shrink(),
                leading: Icon(
                  _completedExpanded
                      ? Icons.keyboard_arrow_down
                      : Icons.keyboard_arrow_right,
                  color: AppColors.lightGray,
                ),
                children: [
                  Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16.0,
                      vertical: 4.0,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment
                          .start,
                      children: [
                        const Text(
                          'Filter:',
                          style: TextStyle(
                            color: AppColors.mediumGray,
                            fontSize: 12,
                          ),
                        ),
                        PopupMenuButton<CompletedFilter>(
                          onSelected: (CompletedFilter result) {
                            setState(() {
                              _activeFilter = result;
                            });
                          },
                          icon: Icon(
                            Icons.filter_list,
                            color: _activeFilter == CompletedFilter.none
                                ? AppColors.mediumGray
                                : AppColors.brightYellow,
                          ),
                          tooltip: 'Filter completed tasks',
                          color: AppColors.cardBg,
                          itemBuilder: (BuildContext context) =>
                              <PopupMenuEntry<CompletedFilter>>[
                                const PopupMenuItem<CompletedFilter>(
                                  value: CompletedFilter.onTime,
                                  child: Text(
                                    'Completed',
                                    style: TextStyle(
                                      color: AppColors.lightGray,
                                    ),
                                  ),
                                ),
                                const PopupMenuItem<CompletedFilter>(
                                  value: CompletedFilter.overdue,
                                  child: Text(
                                    'Overdue',
                                    style: TextStyle(
                                      color: AppColors.lightGray,
                                    ),
                                  ),
                                ),
                                const PopupMenuItem<CompletedFilter>(
                                  value: CompletedFilter.underdue,
                                  child: Text(
                                    'Underdue',
                                    style: TextStyle(
                                      color: AppColors.lightGray,
                                    ),
                                  ),
                                ),
                                const PopupMenuDivider(),
                                const PopupMenuItem<CompletedFilter>(
                                  value: CompletedFilter.none,
                                  child: Text(
                                    'Clear Filter',
                                    style: TextStyle(
                                      color: AppColors.lightGray,
                                    ),
                                  ),
                                ),
                              ],
                        ),
                        const SizedBox(width: 8),
                        TextButton(
                          onPressed: _handleClearCompleted,
                          style: TextButton.styleFrom(
                            backgroundColor: AppColors.midGray,
                            foregroundColor: AppColors.lightGray,
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 8,
                            ),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          child: const Text(
                            'Clear All',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (filteredCompletedTodos.isEmpty &&
                      _activeFilter != CompletedFilter.none)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 20.0),
                      child: Text(
                        'No tasks match the "${_getFilterName(_activeFilter)}" filter.',
                        style: TextStyle(color: AppColors.mediumGray),
                      ),
                    ),
                  ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: filteredCompletedTodos.length,
                    separatorBuilder: (context, index) =>
                        const SizedBox(height: 12),
                    itemBuilder: (context, index) =>
                        _buildTaskCard(filteredCompletedTodos[index]),
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
  Widget _buildTaskCard(Todo todo) {
    final timer = ref.watch(timerProvider);
    final isActive = timer.activeTaskId == todo.id;
    return TaskCard(
      todo: todo,
      isActive: isActive,
      onPlay: (t) => _handlePlayTask(t),
      onDelete: () => widget.onDelete(todo.id.toString()),
      onToggle: () => widget.onToggle(todo.id.toString()),
    );
  }
  Future<void> _showOverdueSessionCompletionPrompt(Todo todo) async {
    debugPrint(
      "SESSION_FLOW: Showing overdue session completion prompt for '${todo.text}'",
    );
    final timerNotifier = ref.read(timerProvider.notifier);
    final timerState = ref.read(timerProvider);
    final totalCycles = timerState.totalCycles;
    final result = await AppDialogs.showOverdueSessionCompleteDialog(
      context: context,
      totalCycles: totalCycles,
    );
    if (!mounted) return;
    timerNotifier.clearOverdueSessionsCompleteFlag();
    final liveFocusedTime = timerNotifier.getFocusedTime(todo.id);
    final plannedSeconds =
        (todo.durationHours * 3600) + (todo.durationMinutes * 60);
    final finalOverdueTime = (liveFocusedTime - plannedSeconds)
        .clamp(0, double.infinity)
        .toInt();
    if (result == true) {
      debugPrint("SESSION_FLOW: User chose 'Mark Complete'.");
      await ref.read(todosProvider.notifier).toggleTodo(todo.id);
      timerNotifier.clear();
    } else {
      debugPrint(
        "SESSION_FLOW: User chose 'Continue Working' or dismissed dialog.",
      );
      await timerNotifier.stopAndSaveProgress(todo.id);
      await ref
          .read(todosProvider.notifier)
          .updateFocusTime(todo.id, finalOverdueTime);
    }
  }
  Future<void> _handleClearCompleted() async {
    final shouldClear = await AppDialogs.showClearCompletedDialog(
      context: context,
    );
    if (shouldClear == true && mounted) {
      try {
        await ref.read(todosProvider.notifier).clearCompleted();
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to clear completed tasks'),
              backgroundColor: Colors.redAccent,
            ),
          );
        }
      }
    }
  }
  Future<void> _handlePlayTask(Todo todo) async {
    final timerState = ref.read(timerProvider);
    final isThisTaskActive = timerState.activeTaskId == todo.id;
    final isAnyTimerActive = timerState.isTimerActive;
    debugPrint(
      'PLAY_BUTTON: Task=${todo.text}, isThisTaskActive=$isThisTaskActive, isAnyTimerActive=$isAnyTimerActive',
    );
    if (isThisTaskActive) {
      await PomodoroRouter.showPomodoroSheet(
        context,
        widget.api,
        todo,
        widget.notificationService,
        ({bool wasOverdue = false, int overdueTime = 0}) async {},
      );
      debugPrint(
        "SESSION_FLOW: PomodoroSheet for '${todo.text}' has been closed.",
      );
      return;
    }
    if (isAnyTimerActive && timerState.activeTaskId != null) {
      final notifier = ref.read(timerProvider.notifier);
      final wasRunning = timerState.isRunning;
      if (wasRunning) notifier.pauseTask();
      final todosAsync = ref.read(todosProvider);
      String? currentTaskName;
      if (todosAsync.hasValue) {
        try {
          currentTaskName = todosAsync.value!
              .firstWhere((t) => t.id == timerState.activeTaskId)
              .text;
        } catch (e) {
          currentTaskName = null;
        }
      }
      final shouldSwitch = await AppDialogs.showSwitchTaskDialog(
        context: context,
        currentTaskName: currentTaskName ?? 'Unknown Task',
        newTaskName: todo.text,
      );
      if (shouldSwitch != true) {
        if (wasRunning) notifier.resumeTask();
        return;
      }
      if (!mounted) return;
      await notifier.stopAndSaveProgress(timerState.activeTaskId!);
    }
    final plannedSeconds =
        (todo.durationHours * 3600) + (todo.durationMinutes * 60);
  final int defaultFocus = TimerDefaults.focusSeconds;
  final int defaultBreak = TimerDefaults.breakSeconds;
    final cycles = plannedSeconds > 0
        ? (plannedSeconds / defaultFocus).ceil().clamp(1, 1000)
        : 4;
    final notifier = ref.read(timerProvider.notifier);
    notifier.resetForSetupWithTask(
      taskId: todo.id,
      focusDuration: defaultFocus,
      breakDuration: defaultBreak,
      totalCycles: cycles,
      plannedDuration: plannedSeconds,
      isPermanentlyOverdue: todo.wasOverdue == 1,
      taskName: todo.text,
    );
    await PomodoroRouter.showPomodoroSheet(
      context,
      widget.api,
      todo,
      widget.notificationService,
      ({bool wasOverdue = false, int overdueTime = 0}) async {},
    );
    debugPrint(
      "SESSION_FLOW: PomodoroSheet for '${todo.text}' has been closed.",
    );
  }
}
class _TaskStatusIndicator extends ConsumerWidget {
  final Todo todo;
  const _TaskStatusIndicator({required this.todo});
  String _formatOverdueDuration(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0;
    final duration = Duration(seconds: totalSeconds);
    final minutes = duration.inMinutes;
    final seconds = totalSeconds % 60;
    if (minutes > 0) {
      return '${minutes}m ${seconds}s';
    } else {
      return '${seconds}s';
    }
  }
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final timerState = ref.watch(timerProvider);
    final focusedSeconds =
        timerState.focusedTimeCache[todo.id] ?? todo.focusedTime;
    final plannedSeconds =
        (todo.durationHours * 3600) + (todo.durationMinutes * 60);
    if (todo.completed || todo.wasOverdue == 1) {
      return const SizedBox.shrink();
    }
    final isActivelyOverdue =
        plannedSeconds > 0 && focusedSeconds > plannedSeconds;
    if (isActivelyOverdue) {
      final overdueSeconds = focusedSeconds - plannedSeconds;
      return Container(
        height: 16,
        alignment: Alignment.centerLeft,
        padding: const EdgeInsets.symmetric(horizontal: 4.0),
        child: Text(
          'Overdue: ${_formatOverdueDuration(overdueSeconds)}',
          style: const TextStyle(
            color: AppColors.priorityHigh,
            fontSize: 12,
            fontWeight: FontWeight.bold,
          ),
        ),
      );
    } else {
      return SizedBox(
        height: 16,
        child: ProgressBar(
          focusedSeconds: focusedSeconds,
          plannedSeconds: plannedSeconds,
          barHeight: 16,
        ),
      );
    }
  }
}

================
File: flutter_app/lib/features/pomodoro/providers/timer_provider.dart
================
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:workmanager/workmanager.dart';
import '../../../core/services/timer_session_controller.dart';
import '../../../core/providers/notification_provider.dart';
import '../../../core/utils/app_constants.dart';
import '../../todo/providers/todos_provider.dart';
import '../../todo/models/todo.dart';
import '../notifications/persistent_timer_notification_model.dart';
import '../../../core/data/todo_repository.dart';
import '../models/timer_state.dart';
import '../services/timer_persistence_manager.dart';
import '../../../core/constants/sound_assets.dart';
import '../../../core/services/workmanager_timer_service.dart';
import '../services/timer_autosave_service.dart';
import '../services/timer_background_scheduler.dart';
import '../services/timer_overdue_service.dart';
import '../services/phase_transition_service.dart';
import '../services/foreground_ticker.dart';
import '../services/notification_action_handler.dart';
import '../../../core/constants/timer_defaults.dart';
class TimerNotifier extends Notifier<TimerState> {
  Timer? _ticker;
  Timer? _autoSaveTimer;
  int _lastAutoSavedSeconds = 0;
  bool _processingOverdue = false;
  TimerSessionController? _sessionController;
  DateTime? _lastStartAttempt;
  late final TimerPersistenceManager _persistenceManager;
  late SharedPreferences _prefs;
  late String _apiBaseUrl;
  late bool _isDebugMode;
  final WorkmanagerTimerService _wmService =
      WorkmanagerTimerService();
  TimerAutoSaveService? _autoSaveService;
  final Logger logger = Logger();
  TimerBackgroundScheduler? _backgroundScheduler;
  TimerOverdueService? _overdueService;
  PhaseTransitionService? _phaseService;
  ForegroundTicker? _foregroundTicker;
  NotificationActionHandler? _actionHandler;
  @override
  TimerState build() {
    _sessionController ??= TimerSessionController();
    Future(() async {
      _prefs = await SharedPreferences.getInstance();
      _persistenceManager = TimerPersistenceManager(_prefs);
      _apiBaseUrl =
          _prefs.getString(AppConstants.prefApiBaseUrl) ??
          'http://127.0.0.1:5000';
      _isDebugMode = _prefs.getBool(AppConstants.prefIsDebugMode) ?? kDebugMode;
      await _restoreTimerState();
      _autoSaveService ??= TimerAutoSaveService(this, ref);
      _backgroundScheduler ??= TimerBackgroundScheduler(_persistenceManager);
      _overdueService ??= TimerOverdueService(notifier: this, ref: ref);
      _phaseService ??= PhaseTransitionService(notifier: this, ref: ref);
      _foregroundTicker ??= ForegroundTicker();
      _actionHandler ??= NotificationActionHandler(notifier: this, ref: ref);
    });
    ref.listen<AsyncValue<List<Todo>>>(todosProvider, (_, next) {
      next.whenData((todos) {
        final currentCache = state.focusedTimeCache;
        final newCacheFromDB = {
          for (var todo in todos) todo.id: todo.focusedTime,
        };
        final mergedCache = Map<int, int>.from(newCacheFromDB);
        currentCache.forEach((taskId, liveSeconds) {
          if (liveSeconds > (newCacheFromDB[taskId] ?? -1)) {
            mergedCache[taskId] = liveSeconds;
          }
        });
        if (!mapEquals(state.focusedTimeCache, mergedCache)) {
          Future.microtask(() {
            state = state.copyWith(focusedTimeCache: mergedCache);
            _persistenceManager.saveTimerState(state);
          });
        }
      });
    });
    ref.onDispose(() {
      _ticker?.cancel();
      _autoSaveTimer?.cancel();
      _autoSaveService?.stop();
      _persistenceManager.saveTimerState(
        state.copyWith(
          isRunning: false,
          wasInBackground: false,
          backgroundStartTime: null,
        ),
      );
      if (state.activeTaskId != null &&
          _persistenceManager.isSessionScheduled()) {
        _wmService.cancelPomodoroTask();
        _persistenceManager.setSessionScheduled(false);
        ref
            .read(notificationServiceProvider)
            .cancelPersistentTimerNotification();
        logger.i('[TimerNotifier] Workmanager task cancelled on dispose.');
      }
    });
    return const TimerState();
  }
  Future<void> persistState() async {
    await _persistenceManager.saveTimerState(state);
  }
  Future<void> _restoreTimerState() async {
    final TimerState? savedState = _persistenceManager.loadTimerState();
    if (savedState != null) {
      logger.i(
        '[TimerNotifier] Restoring timer state from preferences: $savedState',
      );
      if (savedState.wasInBackground &&
          savedState.isRunning &&
          savedState.backgroundStartTime != null) {
        final int now = DateTime.now().millisecondsSinceEpoch;
        final int elapsedSinceBackground =
            (now - savedState.backgroundStartTime!) ~/ 1000;
        int restoredTimeRemaining =
            savedState.timeRemaining - elapsedSinceBackground;
        logger.d(
          '[TimerNotifier] Elapsed since background: $elapsedSinceBackground seconds.',
        );
        if (restoredTimeRemaining <= 0) {
          await _handleBackgroundSessionCompletion(
            savedState,
          );
          state = state.copyWith(
            isRunning: false,
            timeRemaining: 0,
            isTimerActive: false,
            wasInBackground: false,
            backgroundStartTime: null,
            allSessionsComplete:
                _prefs.getBool(AppConstants.prefAllSessionsComplete) ?? false,
            overdueSessionsComplete:
                _prefs.getBool(AppConstants.prefOverdueSessionsComplete) ??
                false,
          );
        } else {
          state = savedState.copyWith(
            timeRemaining: restoredTimeRemaining,
            wasInBackground: false,
            backgroundStartTime: null,
          );
          if (state.isRunning && _persistenceManager.isSessionScheduled()) {
            startTicker();
            await _showPersistentNotification();
          }
        }
      } else {
        state = savedState.copyWith(
          wasInBackground: false,
          backgroundStartTime: null,
        );
        if (state.isRunning) {
          startTicker();
          await _showPersistentNotification();
        }
      }
    }
  }
  Future<void> _handleBackgroundSessionCompletion(
    TimerState backgroundState,
  ) async {
    logger.i('[TimerNotifier] Handling background session completion...');
    final int? activeTaskId = backgroundState.activeTaskId;
    if (activeTaskId == null) return;
    final String? focusedTimeCacheJson = _prefs.getString(
      AppConstants.prefFocusedTimeCache,
    );
    final Map<int, int> focusedTimeCache = focusedTimeCacheJson != null
        ? Map<String, int>.from(
            json.decode(focusedTimeCacheJson),
          ).map((k, v) => MapEntry(int.parse(k), v))
        : {};
    state = state.copyWith(focusedTimeCache: focusedTimeCache);
    final todoRepository = ref.read(todoRepositoryProvider);
    await todoRepository.updateFocusTime(
      activeTaskId,
      focusedTimeCache[activeTaskId] ?? 0,
    );
    await _cancelWorkmanagerTask();
    await _persistenceManager.clearTimerState();
    logger.i(
      '[TimerNotifier] Background session completion handled. State reset.',
    );
  }
  Future<void> _saveTimerStateToPrefs() async {
    await _persistenceManager.saveTimerState(state);
    logger.d('[TimerNotifier] State saved to prefs.');
  }
  Future<void> _scheduleWorkmanagerTask(
    int taskId,
    String taskName,
    int remainingSeconds,
  ) async {
    if (remainingSeconds <= 0 || !state.isRunning) {
      await _cancelWorkmanagerTask();
      return;
    }
    await _cancelWorkmanagerTask();
    await _persistenceManager.saveApiConfig(_apiBaseUrl, _isDebugMode);
    await _saveTimerStateToPrefs();
    logger.i(
      '[TimerNotifier] Scheduling Workmanager task for $remainingSeconds seconds for Task ID: $taskId',
    );
    final Duration delay = Duration(seconds: remainingSeconds + 5);
    await Workmanager().registerOneOffTask(
      AppConstants.pomodoroTimerTask,
      AppConstants.pomodoroTimerTask,
      initialDelay: delay,
      existingWorkPolicy:
          ExistingWorkPolicy.replace,
      constraints: Constraints(
        networkType: NetworkType.notRequired,
        requiresDeviceIdle: false,
        requiresCharging: false,
        requiresBatteryNotLow: false,
      ),
      inputData: {
        'apiBaseUrl': _apiBaseUrl,
        'isDebugMode': _isDebugMode,
        'activeTaskId': taskId,
        'activeTaskText': taskName,
        'timeRemaining': remainingSeconds,
        'currentMode': state.currentMode,
        'focusedTimeCache': json.encode(
          state.focusedTimeCache.map((k, v) => MapEntry(k.toString(), v)),
        ),
        'plannedDurationSeconds': state.plannedDurationSeconds ?? 0,
        'focusDurationSeconds': state.focusDurationSeconds ?? 0,
        'breakDurationSeconds': state.breakDurationSeconds ?? 0,
        'currentCycle': state.currentCycle,
        'totalCycles': state.totalCycles,
        'completedSessions': state.completedSessions,
        'isPermanentlyOverdue': state.isPermanentlyOverdue,
      },
    );
    await _persistenceManager.setSessionScheduled(true);
    logger.i(
      '[TimerNotifier] Workmanager task scheduled to fire in ${delay.inSeconds} seconds.',
    );
  }
  Future<void> _cancelWorkmanagerTask() async {
    await Workmanager().cancelByUniqueName(AppConstants.pomodoroTimerTask);
    await _persistenceManager.setSessionScheduled(false);
    logger.i('[TimerNotifier] Workmanager task cancelled.');
  }
  void update({
    int? activeTaskId,
    String? activeTaskName,
    int? timeRemaining,
    bool? isRunning,
    bool? isTimerActive,
    String? currentMode,
    int? plannedDurationSeconds,
    int? focusDurationSeconds,
    int? breakDurationSeconds,
    int? currentCycle,
    int? totalCycles,
    int? completedSessions,
    bool? isProgressBarFull,
    bool? allSessionsComplete,
    bool? overdueSessionsComplete,
    int? overdueCrossedTaskId,
    String? overdueCrossedTaskName,
    Set<int>? overduePromptShown,
    Set<int>? overdueContinued,
    Map<int, int>? focusedTimeCache,
    bool? suppressNextActivation,
    bool? cycleOverflowBlocked,
    bool? isPermanentlyOverdue,
    int? backgroundStartTime,
    int? pausedTimeTotal,
    bool? wasInBackground,
  }) {
    final newState = state.copyWith(
      activeTaskId: activeTaskId,
      activeTaskName: activeTaskName,
      timeRemaining: timeRemaining,
      isRunning: isRunning,
      isTimerActive: isTimerActive,
      currentMode: currentMode,
      plannedDurationSeconds: plannedDurationSeconds,
      focusDurationSeconds: focusDurationSeconds,
      breakDurationSeconds: breakDurationSeconds,
      currentCycle: currentCycle,
      totalCycles: totalCycles,
      completedSessions: completedSessions,
      isProgressBarFull: isProgressBarFull,
      allSessionsComplete: allSessionsComplete,
      overdueSessionsComplete: overdueSessionsComplete,
      overdueCrossedTaskId: overdueCrossedTaskId,
      overdueCrossedTaskName: overdueCrossedTaskName,
      overduePromptShown: overduePromptShown,
      overdueContinued: overdueContinued,
      focusedTimeCache: focusedTimeCache,
      suppressNextActivation: suppressNextActivation,
      cycleOverflowBlocked: cycleOverflowBlocked,
      isPermanentlyOverdue: isPermanentlyOverdue,
      backgroundStartTime: backgroundStartTime,
      pausedTimeTotal: pausedTimeTotal,
      wasInBackground: wasInBackground,
    );
    if (newState != state) {
      state = newState;
      _saveTimerStateToPrefs();
      if (state.isTimerActive && state.activeTaskId != null) {
        _showPersistentNotification();
      } else {
        ref
            .read(notificationServiceProvider)
            .cancelPersistentTimerNotification();
      }
    }
  }
  Future<void> _showPersistentNotification() async {
    final notificationService = ref.read(notificationServiceProvider);
    final todos = ref.read(todosProvider).value;
    final active = todos?.firstWhere(
      (t) => t.id == state.activeTaskId,
      orElse: () => null as dynamic,
    );
    final model = PersistentTimerNotificationModel.fromState(
      state: state,
      activeTodo: active is Todo ? active : null,
    );
    await notificationService.showOrUpdatePersistent(
      title: model.title,
      body: model.body,
      actionIds: model.actionIds,
    );
  }
  void markOverduePromptShown(int taskId) {
    final newPromptShown = Set<int>.from(state.overduePromptShown)..add(taskId);
    update(overduePromptShown: newPromptShown);
  }
  void markOverdueContinued(int taskId) {
    final newOverdueContinued = Set<int>.from(state.overdueContinued)
      ..add(taskId);
    update(overdueContinued: newOverdueContinued);
  }
  void updateFocusedTime(int taskId, int seconds) {
    final newFocusedTimeCache = Map<int, int>.from(state.focusedTimeCache);
    newFocusedTimeCache[taskId] = seconds;
    update(focusedTimeCache: newFocusedTimeCache);
  }
  int getFocusedTime(int taskId) {
    return state.focusedTimeCache[taskId] ?? 0;
  }
  void startTicker() {
    _ticker?.cancel();
    _startAutoSaveTimer();
    _autoSaveService?.start();
    _foregroundTicker?.start(
      onTick: () {
        if (state.currentMode == 'focus' && state.activeTaskId != null) {
          final int taskId = state.activeTaskId!;
          final int currentFocused = state.focusedTimeCache[taskId] ?? 0;
          final newCache = Map<int, int>.from(state.focusedTimeCache);
          newCache[taskId] = currentFocused + 1;
          update(focusedTimeCache: newCache);
        }
        if (state.timeRemaining > 0) {
          update(timeRemaining: state.timeRemaining - 1);
        }
      },
      onPhaseComplete: () {
        _handlePhaseCompletion();
      },
      onOverdueCheck: () {
        final int focused = state.focusedTimeCache[state.activeTaskId] ?? 0;
        final int? planned = state.plannedDurationSeconds;
        if (!state.isPermanentlyOverdue &&
            !_processingOverdue &&
            state.currentMode == 'focus' &&
            state.activeTaskId != null &&
            planned != null &&
            planned > 0) {
          if (focused >= planned &&
              state.overdueCrossedTaskId != state.activeTaskId) {
            _processingOverdue = true;
            _markOverdueAndFreeze(state.activeTaskId!);
            _processingOverdue = false;
          }
        }
      },
      stateProvider: () => state,
    );
  }
  void _handlePhaseCompletion() {
    _phaseService?.handlePhaseCompletion(state);
    if (state.isRunning &&
        state.activeTaskId != null &&
        state.activeTaskName != null) {
      _scheduleWorkmanagerTask(
        state.activeTaskId!,
        state.activeTaskName!,
        state.timeRemaining,
      );
    } else {
      _cancelWorkmanagerTask();
    }
  }
  void stopTicker() {
    _ticker?.cancel();
    _ticker = null;
    _autoSaveTimer?.cancel();
    _autoSaveTimer = null;
    _autoSaveService?.stop();
    _cancelWorkmanagerTask();
    _saveTimerStateToPrefs();
  }
  void _markOverdueAndFreeze(int taskId) {
    _sessionController?.handleEvent(TimerSessionEvent.overdueReached);
    try {
      final notificationService = ref.read(notificationServiceProvider);
      final todos = ref.read(todosProvider).value ?? [];
      try {
        final task = todos.firstWhere((t) => t.id == taskId);
        notificationService.playSoundWithNotification(
          soundFileName: SoundAsset.sessionComplete.fileName,
          title: 'Planned Time Complete!',
          body:
              'Time for "${task.text}" is up. Decide whether to continue or complete.',
        );
      } catch (e) {
      }
    } catch (e) {
      logger.e('[TimerNotifier] SOUND/NOTIFICATION ERROR: $e');
    }
    _ticker?.cancel();
    _ticker = null;
    _overdueService?.markOverdueAndFreeze(taskId);
    _cancelWorkmanagerTask();
  }
  void stop() {
    update(isRunning: false);
    stopTicker();
    _saveTimerStateToPrefs();
  }
  void clear() {
    stopTicker();
    _sessionController?.forceReset();
    _persistenceManager.clearTimerState();
    state = const TimerState();
    _cancelWorkmanagerTask();
  }
  void resetCurrentPhase() {
    if (state.activeTaskId == null) return;
    final currentPhaseDuration = state.currentMode == 'focus'
        ? (state.focusDurationSeconds ?? TimerDefaults.focusSeconds)
        : (state.breakDurationSeconds ?? TimerDefaults.breakSeconds);
    final elapsedTime = currentPhaseDuration - state.timeRemaining;
    if (state.currentMode == 'focus' && elapsedTime > 0) {
      final taskId = state.activeTaskId!;
      final currentFocusedTime = getFocusedTime(taskId);
      final newFocusedTime = (currentFocusedTime - elapsedTime)
          .clamp(0, double.infinity)
          .toInt();
      updateFocusedTime(taskId, newFocusedTime);
    }
    update(timeRemaining: currentPhaseDuration, isRunning: false);
    stopTicker();
    _cancelWorkmanagerTask();
  }
  void clearPreserveProgress() {
    stopTicker();
    _sessionController?.handleEvent(TimerSessionEvent.abort);
    state = TimerState(focusedTimeCache: state.focusedTimeCache);
    _persistenceManager.clearTimerState();
    _persistenceManager.saveTimerState(
      state.copyWith(focusedTimeCache: state.focusedTimeCache),
    );
    _cancelWorkmanagerTask();
  }
  Future<bool> stopAndSaveProgress(int todoId) async {
    if (state.activeTaskId == null) {
      clear();
      return true;
    }
    try {
      final currentFocusedTime = state.focusedTimeCache[todoId] ?? 0;
      final todoRepository = ref.read(todoRepositoryProvider);
      await todoRepository.updateFocusTime(todoId, currentFocusedTime);
      clearPreserveProgress();
      return true;
    } catch (e) {
      logger.e('[TimerNotifier] Error saving progress: $e');
      clearPreserveProgress();
      return false;
    }
  }
  void toggleRunning() {
    final nextRunning = !state.isRunning;
    update(isRunning: nextRunning);
    if (nextRunning) {
      startTicker();
      if (state.activeTaskId != null && state.activeTaskName != null) {
        _scheduleWorkmanagerTask(
          state.activeTaskId!,
          state.activeTaskName!,
          state.timeRemaining,
        );
      }
    } else {
      stopTicker();
      _cancelWorkmanagerTask();
      _saveTimerStateToPrefs();
    }
  }
  bool startTask({
    required int taskId,
    required String taskName,
    required int focusDuration,
    required int breakDuration,
    required int plannedDuration,
    required int totalCycles,
    bool isPermanentlyOverdue = false,
  }) {
    final now = DateTime.now();
    if (_lastStartAttempt != null &&
        now.difference(_lastStartAttempt!).inMilliseconds < 500) {
      return false;
    }
    _lastStartAttempt = now;
    if (_sessionController?.currentState != TimerSessionState.idle) {
      _sessionController?.forceReset();
    }
    final success =
        _sessionController?.startSession(
          taskName: taskName,
          focusDurationSeconds: focusDuration,
          breakDurationSeconds: breakDuration,
          totalCycles: totalCycles,
        ) ??
        false;
    if (!success) return false;
    try {
      final notificationService = ref.read(notificationServiceProvider);
      notificationService.playSound(SoundAsset.focusStart.fileName);
      notificationService.showNotification(
        title: 'Focus Session Started!',
        body: 'Focus time for "$taskName". You\'ve got this!',
      );
    } catch (e) {
      logger.e('[TimerNotifier] SOUND/NOTIFICATION ERROR: $e');
    }
    update(
      activeTaskId: taskId,
      activeTaskName: taskName,
      focusDurationSeconds: focusDuration,
      breakDurationSeconds: breakDuration,
      plannedDurationSeconds: plannedDuration,
      totalCycles: totalCycles,
      currentCycle: 1,
      timeRemaining: focusDuration,
      currentMode: 'focus',
      isTimerActive: true,
      isRunning: true,
      isPermanentlyOverdue: isPermanentlyOverdue,
      wasInBackground: false,
      backgroundStartTime: null,
      pausedTimeTotal: 0,
    );
    startTicker();
    _scheduleWorkmanagerTask(taskId, taskName, focusDuration);
    _showPersistentNotification();
    return true;
  }
  void pauseTask() {
    logger.i(' PAUSE requested. Current state: $state');
    update(
      isRunning: false,
      pausedTimeTotal:
          state.pausedTimeTotal +
          (state.currentMode == 'focus'
              ? (state.focusDurationSeconds ?? 0)
              : (state.breakDurationSeconds ?? 0)) -
          state.timeRemaining,
    );
    stopTicker();
    _triggerDeferredAutoSave();
    _cancelWorkmanagerTask();
    _showPersistentNotification();
    logger.i(' PAUSE complete. New state: $state');
  }
  void resumeTask() {
    if (!state.isRunning) {
      logger.i(' RESUME requested. Current state: $state');
      update(isRunning: true);
      startTicker();
      _startAutoSaveTimer();
      if (state.activeTaskId != null && state.activeTaskName != null) {
        _scheduleWorkmanagerTask(
          state.activeTaskId!,
          state.activeTaskName!,
          state.timeRemaining,
        );
      }
      _showPersistentNotification();
      logger.i(' RESUME complete. New state: $state');
    }
  }
  void updateDurations({
    int? focusDuration,
    int? breakDuration,
    int? totalCycles,
  }) {
    update(
      focusDurationSeconds: focusDuration ?? state.focusDurationSeconds,
      breakDurationSeconds: breakDuration ?? state.breakDurationSeconds,
      totalCycles: totalCycles ?? state.totalCycles,
      timeRemaining:
          (!state.isRunning &&
              state.currentMode == 'focus' &&
              focusDuration != null &&
              state.currentCycle == 0)
          ? focusDuration
          : state.timeRemaining,
    );
  }
  void resetForSetupWithTask({
    required int taskId,
    required String taskName,
    required int focusDuration,
    required int breakDuration,
    required int totalCycles,
    required int plannedDuration,
    required bool isPermanentlyOverdue,
  }) {
    stopTicker();
    final cache = state.focusedTimeCache;
    update(
      activeTaskId: taskId,
      activeTaskName: taskName,
      focusDurationSeconds: focusDuration,
      breakDurationSeconds: breakDuration,
      totalCycles: totalCycles,
      plannedDurationSeconds: plannedDuration,
      timeRemaining: focusDuration,
      currentMode: 'focus',
      isRunning: false,
      currentCycle: 0,
      completedSessions: 0,
      isProgressBarFull: false,
      allSessionsComplete: false,
      overdueSessionsComplete: false,
      focusedTimeCache: cache,
      overdueCrossedTaskId: null,
      isTimerActive: false,
      isPermanentlyOverdue: isPermanentlyOverdue,
      wasInBackground: false,
      backgroundStartTime: null,
      pausedTimeTotal: 0,
    );
    _lastAutoSavedSeconds = state.focusedTimeCache[taskId] ?? 0;
    _cancelWorkmanagerTask();
    ref
        .read(notificationServiceProvider)
        .cancelPersistentTimerNotification();
  }
  void _startAutoSaveTimer() {
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer.periodic(
      const Duration(seconds: TimerDefaults.autoSaveIntervalSeconds),
      (_) {
        _triggerDeferredAutoSave();
      },
    );
  }
  void _triggerDeferredAutoSave() {
    final taskId = state.activeTaskId;
    if (taskId == null) return;
    final currentFocused = state.focusedTimeCache[taskId] ?? 0;
    if (currentFocused - _lastAutoSavedSeconds <
        TimerDefaults.autoSaveIntervalSeconds)
      return;
    _autoSaveService?.triggerDeferredAutoSave();
  }
  void skipPhase() {
    _phaseService?.skipPhase(state);
    if (state.activeTaskId != null && state.activeTaskName != null) {
      _scheduleWorkmanagerTask(
        state.activeTaskId!,
        state.activeTaskName!,
        state.timeRemaining,
      );
    }
    _showPersistentNotification();
  }
  void clearAllSessionsCompleteFlag() {
    update(allSessionsComplete: false);
    _prefs.setBool(AppConstants.prefAllSessionsComplete, false);
  }
  void clearOverdueSessionsCompleteFlag() {
    if (state.overdueSessionsComplete) {
      update(overdueSessionsComplete: false);
      _prefs.setBool(AppConstants.prefOverdueSessionsComplete, false);
    }
  }
  void clearCycleOverflowBlockedFlag() {
    if (state.cycleOverflowBlocked) {
      update(cycleOverflowBlocked: false);
    }
  }
  Future<void> scheduleBackgroundPersistence() async {
    if (state.activeTaskId == null || !state.isRunning) return;
    update(
      wasInBackground: true,
      backgroundStartTime: DateTime.now().millisecondsSinceEpoch,
    );
    await _persistenceManager.saveApiConfig(_apiBaseUrl, _isDebugMode);
    await Workmanager().registerOneOffTask(
      AppConstants.pomodoroTimerTask,
      AppConstants.pomodoroTimerTask,
      initialDelay: Duration(seconds: state.timeRemaining + 5),
      existingWorkPolicy: ExistingWorkPolicy.replace,
      constraints: Constraints(networkType: NetworkType.notRequired),
      inputData: {
        'apiBaseUrl': _apiBaseUrl,
        'isDebugMode': _isDebugMode,
        'activeTaskId': state.activeTaskId!,
        'activeTaskText': state.activeTaskName!,
        'timeRemaining': state.timeRemaining,
        'currentMode': state.currentMode,
        'focusedTimeCache': json.encode(
          state.focusedTimeCache.map((k, v) => MapEntry(k.toString(), v)),
        ),
        'plannedDurationSeconds': state.plannedDurationSeconds ?? 0,
        'focusDurationSeconds': state.focusDurationSeconds ?? 0,
        'breakDurationSeconds': state.breakDurationSeconds ?? 0,
        'currentCycle': state.currentCycle,
        'totalCycles': state.totalCycles,
        'completedSessions': state.completedSessions,
        'isPermanentlyOverdue': state.isPermanentlyOverdue,
      },
    );
    await _persistenceManager.setSessionScheduled(true);
    logger.i(
      '[TimerNotifier] Background persistence scheduled via Workmanager.',
    );
  }
  Future<void> cancelBackgroundPersistence() async {
    if (_persistenceManager.isSessionScheduled()) {
      await Workmanager().cancelByUniqueName(AppConstants.pomodoroTimerTask);
      await _persistenceManager.setSessionScheduled(false);
      logger.i('[TimerNotifier] Background persistence cancelled.');
    }
    update(wasInBackground: false, backgroundStartTime: null);
    ref.read(notificationServiceProvider).cancelPersistentTimerNotification();
  }
  Future<void> handleNotificationAction(String actionId) async {
    logger.i(" TimerNotifier handling notification action: '$actionId'");
    await _actionHandler?.handle(actionId);
    logger.d(" TimerNotifier finished handling action: '$actionId'");
  }
}
final timerProvider = NotifierProvider<TimerNotifier, TimerState>(
  () => TimerNotifier(),
);

================
File: flutter_app/lib/features/todo/screens/todo_list_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:math';
import '../../../core/services/mock_api_service.dart';
import '../../../core/providers/notification_provider.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/utils/app_dialogs.dart';
import '../../../core/utils/debug_logger.dart';
import '../../../core/utils/error_handler.dart';
import '../../auth/providers/auth_provider.dart';
import '../../pomodoro/providers/timer_provider.dart';
import '../../pomodoro/models/timer_state.dart';
import '../../pomodoro/widgets/mini_timer_bar.dart';
import '../models/todo.dart';
import '../providers/todos_provider.dart';
import '../widgets/inline_task_input.dart';
import '../widgets/task_list.dart';
class TodoListScreen extends ConsumerStatefulWidget {
  const TodoListScreen({super.key});
  @override
  ConsumerState<TodoListScreen> createState() => _TodoListScreenState();
}
class _TodoListScreenState extends ConsumerState<TodoListScreen> {
  bool _isCompletedExpanded = false;
  Future<void> _addTodo(String taskName, int hours, int minutes) async {
    logger.d(
      '[TodoListScreen] Received add task request: "$taskName" (${hours}h ${minutes}m)',
    );
    if (!mounted) {
      logger.w('[TodoListScreen] _addTodo: Widget not mounted, aborting.');
      return;
    }
    try {
      logger.d('[TodoListScreen] Calling todosProvider.notifier.addTodo...');
      await ref.read(todosProvider.notifier).addTodo(taskName, hours, minutes);
      ErrorHandler.showSuccess(context, 'Task added successfully!');
      logger.d(
        '[TodoListScreen] Task added successfully and success message shown.',
      );
    } catch (e, st) {
      logger.e('[TodoListScreen] Error adding task', error: e, stackTrace: st);
      if (mounted) {
        ErrorHandler.showError(context, e);
        logger.d('[TodoListScreen] Error message shown for adding task.');
      }
    }
  }
  void _showOverduePrompt(BuildContext context, Todo todo) async {
    final timerNotifier = ref.read(timerProvider.notifier);
    timerNotifier.markOverduePromptShown(todo.id);
    final wasRunning = ref.read(timerProvider).isRunning;
    if (wasRunning) timerNotifier.pauseTask();
    final result = await AppDialogs.showOverdueDialog(
      context: context,
      taskName: todo.text,
    );
    if (!mounted) return;
    final liveFocusedTime = timerNotifier.getFocusedTime(todo.id);
    if (result == true) {
      await ref
          .read(todosProvider.notifier)
          .toggleTodo(todo.id, liveFocusedTime: liveFocusedTime);
      timerNotifier.clear();
    } else if (result == false) {
      await timerNotifier.stopAndSaveProgress(todo.id);
      final plannedTime =
          (todo.durationHours * 3600) + (todo.durationMinutes * 60);
      final overdueTime = (liveFocusedTime - plannedTime)
          .clamp(0, double.infinity)
          .toInt();
      await ref
          .read(todosProvider.notifier)
          .markTaskPermanentlyOverdue(
            todo.id,
            overdueTime: overdueTime,
          );
    } else {
      if (wasRunning) timerNotifier.resumeTask();
    }
  }
  Future<void> _handleTaskCompletion(int id, {bool wasOverdue = false}) async {
    if (!mounted) return;
    final timerState = ref.read(timerProvider);
    final currentTodo = ref
        .read(todosProvider)
        .value
        ?.firstWhere((t) => t.id == id);
    if (currentTodo != null &&
        timerState.activeTaskId == currentTodo.id &&
        timerState.isTimerActive) {
      await ref.read(timerProvider.notifier).stopAndSaveProgress(id);
    }
    try {
      await ref.read(todosProvider.notifier).toggleTodo(id);
    } catch (e) {
      if (mounted) {
        ErrorHandler.showError(context, e);
      }
    }
  }
  Future<void> _handleTaskDeletion(int id) async {
    if (!mounted) return;
    final timerState = ref.read(timerProvider);
    final currentTodo = ref
        .read(todosProvider)
        .value
        ?.firstWhere((t) => t.id == id);
    if (currentTodo == null) return;
    final shouldDelete = await AppDialogs.showDeleteTaskDialog(
      context: context,
      taskName: currentTodo.text,
    );
    if (shouldDelete != true) return;
    if (timerState.activeTaskId == currentTodo.id && timerState.isTimerActive) {
      ref.read(timerProvider.notifier).clear();
    }
    try {
      await ref.read(todosProvider.notifier).deleteTodo(id);
      ErrorHandler.showSuccess(context, 'Task deleted successfully!');
    } catch (e) {
      if (mounted) {
        ErrorHandler.showError(context, e);
      }
    }
  }
  Future<void> _handleTaskToggle(int id) async {
    if (!mounted) return;
    final todos = ref.read(todosProvider).value ?? [];
    Todo? currentTodo;
    try {
      currentTodo = todos.firstWhere((t) => t.id == id);
    } catch (e) {
      return;
    }
    if (currentTodo.wasOverdue == 1 && !currentTodo.completed) {
      final confirm = await AppDialogs.showConfirmCompleteOverdueTaskDialog(
        context: context,
        taskName: currentTodo.text,
      );
      if (confirm != true) {
        return;
      }
    }
    final timerState = ref.read(timerProvider);
    if (timerState.activeTaskId == currentTodo.id &&
        timerState.isTimerActive &&
        !currentTodo.completed) {
      await ref.read(timerProvider.notifier).stopAndSaveProgress(id);
    }
    final liveFocusedTime =
        timerState.focusedTimeCache[id] ?? currentTodo.focusedTime;
    try {
      await ref
          .read(todosProvider.notifier)
          .toggleTodo(id, liveFocusedTime: liveFocusedTime);
    } catch (e) {
      if (mounted) {
        ErrorHandler.showError(context, e);
      }
    }
  }
  Future<void> _handleSignOut() async {
    final shouldLogout = await AppDialogs.showSignOutDialog(context: context);
    if (shouldLogout == true && mounted) {
      try {
        await ref.read(authProvider.notifier).signOut();
      } catch (e) {
        if (mounted) {
          ErrorHandler.showError(context, e);
        }
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    if (!mounted) {
      return const SizedBox.shrink();
    }
    final screenWidth = MediaQuery.of(context).size.width;
    final maxCardWidth = min(screenWidth * 0.95, 520.0);
    final api = ref.watch(apiServiceProvider);
    final notificationService = ref.watch(notificationServiceProvider);
    final todosAsync = ref.watch(todosProvider);
    final authState = ref.watch(authProvider);
    final timerState = ref.watch(timerProvider);
    final userName = authState.hasValue && authState.value!.isAuthenticated
        ? authState.value!.userName
        : 'User';
    final activeTaskId = timerState.activeTaskId;
    Todo? activeTodo;
    if (activeTaskId != null &&
        todosAsync.hasValue &&
        todosAsync.value != null) {
      try {
        activeTodo = todosAsync.value!.firstWhere(
          (todo) => todo.id == activeTaskId,
        );
      } catch (_) {
        activeTodo = null;
      }
    }
    ref.listen<TimerState>(timerProvider, (previous, next) {
      final overdueTaskId = next.overdueCrossedTaskId;
      if (overdueTaskId == null ||
          next.overduePromptShown.contains(overdueTaskId))
        return;
      final todoList = todosAsync.value;
      if (todoList == null) return;
      Todo? overdue;
      try {
        overdue = todoList.firstWhere((t) => t.id == overdueTaskId);
      } catch (_) {
        return;
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        _showOverduePrompt(context, overdue!);
      });
    });
    final isTimerBarVisible =
        timerState.isTimerActive && timerState.activeTaskId != null;
    final isKeyboardVisible = MediaQuery.of(context).viewInsets.bottom > 0;
    final showSignOutButton =
        !isTimerBarVisible && !isKeyboardVisible && !_isCompletedExpanded;
    final showCreditTag =
        !isTimerBarVisible && !isKeyboardVisible && !_isCompletedExpanded;
    return Scaffold(
      backgroundColor: AppColors.scaffoldBg,
      body: SafeArea(
        child: Stack(
          children: [
            Center(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: maxCardWidth),
                child: Container(
                  decoration: BoxDecoration(
                    color: AppColors.cardBg,
                    borderRadius: BorderRadius.circular(22),
                  ),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 20,
                      vertical: 18,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        const SizedBox(height: 20),
                        Text(
                          'BETAFLOW',
                          style: TextStyle(
                            color: AppColors.brightYellow,
                            fontSize: 48,
                            fontWeight: FontWeight.w900,
                            letterSpacing: 1.4,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(
                          height: 32,
                        ),
                        Text(
                          'Welcome, $userName!',
                          style: const TextStyle(
                            color: AppColors.lightGray,
                            fontSize: 16,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 22),
                        InlineTaskInput(onAddTask: _addTodo),
                        const Divider(
                          color: AppColors.brightYellow,
                          thickness: 1.5,
                          height: 48,
                          indent: 20,
                          endIndent: 20,
                        ),
                        Expanded(
                          child: todosAsync.when(
                            loading: () => const Center(
                              child: CircularProgressIndicator(),
                            ),
                            error: (err, stack) => Center(
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Text('Error: $err'),
                                  ElevatedButton(
                                    onPressed: () =>
                                        ref.invalidate(todosProvider),
                                    child: const Text('Retry'),
                                  ),
                                ],
                              ),
                            ),
                            data: (todos) => TaskList(
                              todos: todos,
                              api: api,
                              notificationService: notificationService,
                              onPlay: (id) => _handleTaskCompletion(
                                int.parse(id),
                                wasOverdue: false,
                              ),
                              onDelete: (id) =>
                                  _handleTaskDeletion(int.parse(id)),
                              onToggle: (id) =>
                                  _handleTaskToggle(int.parse(id)),
                              onExpansionChanged: (isExpanded) {
                                setState(() {
                                  _isCompletedExpanded = isExpanded;
                                });
                              },
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            if (isTimerBarVisible)
              Positioned(
                left: 20,
                right: 20,
                bottom: 10,
                child: MiniTimerBar(
                  api: api,
                  notificationService: notificationService,
                  activeTodo: activeTodo,
                  onComplete: (id) => _handleTaskCompletion(id),
                ),
              ),
            if (showCreditTag)
              Positioned(
                bottom: 12,
                left: 16,
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  child: RichText(
                    text: TextSpan(
                      children: [
                        TextSpan(
                          text: 'Made with ',
                          style: TextStyle(
                            color: AppColors.mediumGray.withValues(alpha: 0.6),
                            fontSize: 12,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                        TextSpan(
                          text: '',
                          style: TextStyle(
                            color: Colors.red,
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        TextSpan(
                          text: ' by Prayas',
                          style: TextStyle(
                            color: AppColors.mediumGray.withValues(alpha: 0.6),
                            fontSize: 12,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            if (showSignOutButton)
              Positioned(
                bottom: 16,
                right: 24,
                child: IconButton(
                  icon: const Icon(
                    Icons.logout,
                    color: AppColors.mediumGray,
                    size: 28,
                  ),
                  tooltip: 'Sign Out',
                  onPressed: _handleSignOut,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

================
File: flutter_app/lib/main.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart';
import 'package:workmanager/workmanager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'core/utils/app_constants.dart';
import 'core/data/app_database.dart';
import 'core/data/todo_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';
import 'core/services/mock_api_service.dart';
import 'core/services/api_service.dart';
import 'core/services/notification_service.dart';
import 'core/debug/notification_sound_tester.dart';
import 'core/providers/notification_provider.dart';
import 'core/utils/debug_logger.dart';
import 'core/utils/helpers.dart';
import 'features/pomodoro/notifications/persistent_timer_notification_model.dart';
import 'features/pomodoro/models/timer_state.dart';
import 'features/todo/models/todo.dart';
import 'core/providers/notification_action_provider.dart';
import 'core/bridge/notification_action_dispatcher.dart';
late final ApiService actualApiService;
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]);
  final notificationService = NotificationService();
  await notificationService.init();
  await notificationService.ensurePermissions();
  notificationService.onNotificationTap = (String? payload) {
    if (payload == null) return;
    logger.i("[MAIN] Notification action received: '$payload'");
    final bool dispatched = dispatchNotificationActionIfPossible(payload);
    if (!dispatched) {
      logger.w(
        "[MAIN] Dispatcher not ready, persisting action '$payload' for later flush.",
      );
      SharedPreferences.getInstance().then((prefs) {
        prefs.setString('last_notification_action', payload);
      });
      _PendingNotificationActionHolder.latest = payload;
    } else {
      logger.d(
        "[MAIN] Action '$payload' forwarded synchronously via dispatcher.",
      );
    }
  };
  if (kDebugMode) {
    final tester = NotificationSoundTester(notificationService);
    await tester.testBreakSound();
  }
  const envBase = String.fromEnvironment('API_BASE_URL', defaultValue: '');
  String chooseBaseUrl() {
    if (envBase.isNotEmpty) return envBase;
    if (Platform.isAndroid) {
      return 'http:
    }
    return 'http://127.0.0.1:5000';
  }
  final baseUrl = chooseBaseUrl();
  logger.i('[MAIN] Using API baseUrl: $baseUrl');
  actualApiService = kDebugMode
      ? MockApiService(baseUrl)
      : ApiService(baseUrl);
  await Workmanager().initialize(callbackDispatcher, isInDebugMode: kDebugMode);
  Workmanager().registerPeriodicTask(
    AppConstants.pomodoroTimerTask,
    AppConstants.pomodoroTimerTask,
    frequency: const Duration(minutes: 15),
    initialDelay: const Duration(seconds: 10),
    constraints: Constraints(networkType: NetworkType.notRequired),
  );
  runApp(
    ProviderScope(
      overrides: [
        apiServiceProvider.overrideWithValue(actualApiService),
        notificationServiceProvider.overrideWithValue(notificationService),
      ],
      child: const App(),
    ),
  );
}
class _PendingNotificationActionHolder {
  static String? latest;
}
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    final NotificationService notificationService = NotificationService();
    await notificationService.init();
    logger.i('[BackgroundTimer] Executing workmanager task: $task');
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final String? savedApiBaseUrl = prefs.getString(
      AppConstants.prefApiBaseUrl,
    );
    final bool? savedIsDebugMode = prefs.getBool(AppConstants.prefIsDebugMode);
    if (savedApiBaseUrl == null || savedIsDebugMode == null) {
      logger.e(
        '[BackgroundTimer] Missing API config in preferences. Cannot initialize ApiService. Exiting.',
      );
      return Future.value(true);
    }
    final ApiService backgroundApiService = savedIsDebugMode
        ? MockApiService(savedApiBaseUrl)
        : ApiService(savedApiBaseUrl);
    final AppDatabase db = AppDatabase();
    final TodoRepository todoRepository = TodoRepository(
      db,
      backgroundApiService,
    );
    try {
      if (task == AppConstants.pomodoroTimerTask) {
        final int? activeTaskIdRaw = prefs.getInt(
          AppConstants.prefActiveTaskId,
        );
        final String? activeTaskText = prefs.getString(
          AppConstants.prefActiveTaskText,
        );
        int timeRemaining = prefs.getInt(AppConstants.prefTimeRemaining) ?? 0;
        bool isRunning = prefs.getBool(AppConstants.prefIsRunning) ?? false;
        final String currentMode =
            prefs.getString(AppConstants.prefCurrentMode) ?? 'focus';
        final int plannedDurationSeconds =
            prefs.getInt(AppConstants.prefPlannedDurationSeconds) ?? 0;
        final int focusDurationSeconds =
            prefs.getInt(AppConstants.prefFocusDurationSeconds) ?? 0;
        final int breakDurationSeconds =
            prefs.getInt(AppConstants.prefBreakDurationSeconds) ?? 0;
        int currentCycle = prefs.getInt(AppConstants.prefCurrentCycle) ?? 1;
        final int totalCycles = prefs.getInt(AppConstants.prefTotalCycles) ?? 1;
        int completedSessions =
            prefs.getInt(AppConstants.prefCompletedSessions) ?? 0;
        final int? backgroundStartTime = prefs.getInt(
          AppConstants.prefBackgroundStartTime,
        );
        final bool isPermanentlyOverdue =
            prefs.getBool(AppConstants.prefIsPermanentlyOverdue) ?? false;
        final String? focusedTimeCacheJson = prefs.getString(
          AppConstants.prefFocusedTimeCache,
        );
        final Map<int, int> focusedTimeCache = focusedTimeCacheJson != null
            ? Map<String, int>.from(
                json.decode(focusedTimeCacheJson),
              ).map((k, v) => MapEntry(int.parse(k), v))
            : {};
        if (activeTaskIdRaw == null || activeTaskIdRaw == -1 || !isRunning) {
          logger.w(
            '[BackgroundTimer] No active/running timer in background or invalid task ID. Cancelling Workmanager task and persistent notification.',
          );
          await Workmanager().cancelByUniqueName(
            AppConstants.pomodoroTimerTask,
          );
          await prefs.setBool(AppConstants.prefSessionScheduled, false);
          await notificationService
              .cancelPersistentTimerNotification();
          return Future.value(true);
        }
        final int activeTaskId = activeTaskIdRaw;
        if (backgroundStartTime != null) {
          final int now = DateTime.now().millisecondsSinceEpoch;
          final int elapsedSinceBackground =
              (now - backgroundStartTime) ~/ 1000;
          timeRemaining -= elapsedSinceBackground;
          focusedTimeCache[activeTaskId] =
              (focusedTimeCache[activeTaskId] ?? 0) + elapsedSinceBackground;
          await prefs.setString(
            AppConstants.prefFocusedTimeCache,
            json.encode(
              focusedTimeCache.map((k, v) => MapEntry(k.toString(), v)),
            ),
          );
        }
        logger.i(
          '[BackgroundTimer] Task: $activeTaskText, Mode: $currentMode, Remaining: $timeRemaining s, Focused: ${focusedTimeCache[activeTaskId]} s',
        );
        final bool isProgressBarFull =
            prefs.getBool(AppConstants.prefIsProgressBarFull) ?? false;
        final bool allSessionsComplete =
            prefs.getBool(AppConstants.prefAllSessionsComplete) ?? false;
        final bool overdueSessionsComplete =
            prefs.getBool(AppConstants.prefOverdueSessionsComplete) ?? false;
        final int? overdueCrossedTaskId = prefs.getInt(
          AppConstants.prefOverdueCrossedTaskId,
        );
        final Set<int> overduePromptShown = {
          for (final id
              in (prefs.getStringList(AppConstants.prefOverduePromptShown) ??
                  []))
            int.tryParse(id) ?? -1,
        }..remove(-1);
        final Set<int> overdueContinued = {
          for (final id
              in (prefs.getStringList(AppConstants.prefOverdueContinued) ?? []))
            int.tryParse(id) ?? -1,
        }..remove(-1);
        final bool suppressNextActivation =
            prefs.getBool(AppConstants.prefSuppressNextActivation) ?? false;
        final bool cycleOverflowBlocked =
            prefs.getBool(AppConstants.prefCycleOverflowBlocked) ?? false;
        final int pausedTimeTotal =
            prefs.getInt(AppConstants.prefPausedTimeTotal) ?? 0;
        final pseudoState = TimerState(
          activeTaskId: activeTaskId,
          activeTaskName: activeTaskText,
          timeRemaining: timeRemaining.clamp(0, double.infinity).toInt(),
          isRunning: isRunning,
          isTimerActive: true,
          currentMode: currentMode,
          focusDurationSeconds: focusDurationSeconds,
          breakDurationSeconds: breakDurationSeconds,
          currentCycle: currentCycle,
          totalCycles: totalCycles,
          completedSessions: completedSessions,
          isProgressBarFull: isProgressBarFull,
          allSessionsComplete: allSessionsComplete,
          overdueSessionsComplete: overdueSessionsComplete,
          overdueCrossedTaskId: overdueCrossedTaskId,
          overduePromptShown: overduePromptShown,
          overdueContinued: overdueContinued,
          focusedTimeCache: focusedTimeCache,
          suppressNextActivation: suppressNextActivation,
          cycleOverflowBlocked: cycleOverflowBlocked,
          isPermanentlyOverdue: isPermanentlyOverdue,
          backgroundStartTime: backgroundStartTime,
          pausedTimeTotal: pausedTimeTotal,
        );
        final model = PersistentTimerNotificationModel.fromState(
          state: pseudoState,
          activeTodo: activeTaskId != null
              ? Todo(
                  id: activeTaskId,
                  userId: '',
                  text: activeTaskText ?? 'Unknown Task',
                  completed: false,
                  durationHours: 0,
                  durationMinutes: 0,
                  focusedTime: focusedTimeCache[activeTaskId] ?? 0,
                  wasOverdue: isPermanentlyOverdue ? 1 : 0,
                  overdueTime: 0,
                  createdAt: DateTime.now(),
                )
              : null,
        );
        await notificationService.showOrUpdatePersistent(
          title: model.title,
          body: model.body,
          actionIds: model.actionIds,
        );
        if (timeRemaining <= 0) {
          if (currentMode == 'focus') {
            completedSessions++;
            await todoRepository.updateFocusTime(
              activeTaskId,
              focusedTimeCache[activeTaskId] ?? 0,
            );
            if (completedSessions >= totalCycles) {
              if (isPermanentlyOverdue) {
                logger.i(
                  '[BackgroundTimer] Overdue task session complete in background!',
                );
                await notificationService.playSound('progress_bar_full.wav');
                await notificationService.showNotification(
                  title: 'Overdue Session Complete!',
                  body:
                      'Your overdue session for "$activeTaskText" is complete.',
                );
                await prefs.setBool(
                  AppConstants.prefOverdueSessionsComplete,
                  true,
                );
              } else {
                logger.i(
                  '[BackgroundTimer] All focus sessions complete in background!',
                );
                await notificationService.playSound('progress_bar_full.wav');
                await notificationService.showNotification(
                  title: 'All Sessions Complete!',
                  body:
                      'You have completed all $totalCycles focus sessions for "$activeTaskText"!',
                );
                await prefs.setBool(AppConstants.prefAllSessionsComplete, true);
              }
              await Workmanager().cancelByUniqueName(
                AppConstants.pomodoroTimerTask,
              );
              await prefs.setBool(AppConstants.prefSessionScheduled, false);
              await prefs.remove(AppConstants.prefActiveTaskId);
              await prefs.remove(AppConstants.prefActiveTaskText);
              await prefs.setBool(AppConstants.prefIsRunning, false);
              await notificationService
                  .cancelPersistentTimerNotification();
            } else {
              await notificationService.playSound('break_timer_start.wav');
              await notificationService.showNotification(
                title: 'Focus Session Complete!',
                body: 'Time for a break for "$activeTaskText".',
              );
              currentCycle++;
              timeRemaining = breakDurationSeconds;
              await prefs.setString(AppConstants.prefCurrentMode, 'break');
              await prefs.setInt(AppConstants.prefTimeRemaining, timeRemaining);
              await prefs.setInt(AppConstants.prefCurrentCycle, currentCycle);
              await prefs.setInt(
                AppConstants.prefCompletedSessions,
                completedSessions,
              );
              await prefs.setInt(
                AppConstants.prefBackgroundStartTime,
                DateTime.now().millisecondsSinceEpoch,
              );
            }
          } else if (currentMode == 'break') {
            await notificationService.playSound('focus_timer_start.wav');
            await notificationService.showNotification(
              title: 'Break Complete!',
              body: 'Time to focus on "$activeTaskText" again!',
            );
            timeRemaining = focusDurationSeconds;
            await prefs.setString(AppConstants.prefCurrentMode, 'focus');
            await prefs.setInt(AppConstants.prefTimeRemaining, timeRemaining);
            await prefs.setInt(
              AppConstants.prefBackgroundStartTime,
              DateTime.now().millisecondsSinceEpoch,
            );
          }
          if (prefs.getBool(AppConstants.prefIsRunning) ?? false) {
            await Workmanager().registerOneOffTask(
              AppConstants.pomodoroTimerTask,
              AppConstants.pomodoroTimerTask,
              initialDelay: Duration(
                seconds: timeRemaining.clamp(1, double.infinity).toInt() + 5,
              ),
              existingWorkPolicy: ExistingWorkPolicy.replace,
              inputData: {
                'apiBaseUrl': savedApiBaseUrl,
                'isDebugMode': savedIsDebugMode,
              },
            );
            await prefs.setBool(AppConstants.prefSessionScheduled, true);
          } else {
            await Workmanager().cancelByUniqueName(
              AppConstants.pomodoroTimerTask,
            );
            await prefs.setBool(AppConstants.prefSessionScheduled, false);
            await notificationService.cancelPersistentTimerNotification();
          }
        } else {
          await prefs.setInt(AppConstants.prefTimeRemaining, timeRemaining);
          await prefs.setInt(
            AppConstants.prefBackgroundStartTime,
            DateTime.now().millisecondsSinceEpoch,
          );
          if (!isPermanentlyOverdue &&
              currentMode == 'focus' &&
              plannedDurationSeconds > 0 &&
              (focusedTimeCache[activeTaskId] ?? 0) >= plannedDurationSeconds &&
              (prefs.getInt(AppConstants.prefOverdueCrossedTaskId) !=
                  activeTaskId)) {
            logger.w(
              '[BackgroundTimer] Task "$activeTaskText" crossed planned duration in background!',
            );
            await notificationService.playSound('progress_bar_full.wav');
            await notificationService.showNotification(
              title: 'Planned Time Complete!',
              body:
                  'Time for "$activeTaskText" is up. Decide whether to continue or complete when you open the app.',
            );
            await prefs.setInt(
              AppConstants.prefOverdueCrossedTaskId,
              activeTaskId,
            );
            await prefs.setBool(
              AppConstants.prefIsRunning,
              false,
            );
          }
          await Workmanager().registerOneOffTask(
            AppConstants.pomodoroTimerTask,
            AppConstants.pomodoroTimerTask,
            initialDelay: const Duration(seconds: 1),
            existingWorkPolicy: ExistingWorkPolicy.replace,
            inputData: {
              'apiBaseUrl': savedApiBaseUrl,
              'isDebugMode': savedIsDebugMode,
            },
          );
          await prefs.setBool(AppConstants.prefSessionScheduled, true);
        }
      }
      return Future.value(true);
    } catch (e, st) {
      logger.e('[BackgroundTimer] Error in callbackDispatcher: $e\n$st');
      return Future.value(false);
    } finally {
      await db.close();
    }
  });
}





================================================================
End of Codebase
================================================================
