This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  copilot-instructions.md
backend/
  .dart_tool/
    extension_discovery/
      devtools.json
      README.md
      vs_code.json
    package_config.json
    package_graph.json
  bin/
    cli.dart
    server.dart
  pubspec.lock
  pubspec.yaml
  README.md
  schema.sql
  server.pid
flutter_app/
  android/
    app/
      src/
        debug/
          AndroidManifest.xml
        main/
          java/
            io/
              flutter/
                plugins/
                  GeneratedPluginRegistrant.java
          kotlin/
            com/
              example/
                flutter_app/
                  MainActivity.kt
          res/
            drawable/
              launch_background.xml
            drawable-v21/
              launch_background.xml
            values/
              styles.xml
            values-night/
              styles.xml
          AndroidManifest.xml
        profile/
          AndroidManifest.xml
      build.gradle.kts
    gradle/
      wrapper/
        gradle-wrapper.properties
    .gitignore
    build.gradle.kts
    flutter_app_android.iml
    gradle.properties
    settings.gradle.kts
  ios/
    Flutter/
      AppFrameworkInfo.plist
      Debug.xcconfig
      Release.xcconfig
    Runner/
      Assets.xcassets/
        AppIcon.appiconset/
          Contents.json
        LaunchImage.imageset/
          Contents.json
          README.md
      Base.lproj/
        LaunchScreen.storyboard
        Main.storyboard
      AppDelegate.swift
      Info.plist
      Runner-Bridging-Header.h
    Runner.xcodeproj/
      project.xcworkspace/
        xcshareddata/
          IDEWorkspaceChecks.plist
          WorkspaceSettings.xcsettings
        contents.xcworkspacedata
      xcshareddata/
        xcschemes/
          Runner.xcscheme
      project.pbxproj
    Runner.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
        WorkspaceSettings.xcsettings
      contents.xcworkspacedata
    RunnerTests/
      RunnerTests.swift
    .gitignore
  lib/
    models/
      task_timer_state.dart
      todo.dart
    screens/
      login_screen.dart
      pomodoro_screen.dart
      todo_list_screen.dart
    services/
      api_service.dart
      auth_service.dart
      local_timer_store.dart
      notification_service.dart
      pomodoro_controller.dart
      timer_service.dart
    theme/
      app_colors.dart
    utils/
      debug_logger.dart
    widgets/
      mini_timer_bar.dart
      pomodoro_bottom_sheet.dart
      progress_bar.dart
      task_card.dart
    main.dart
  linux/
    flutter/
      CMakeLists.txt
      generated_plugin_registrant.cc
      generated_plugin_registrant.h
      generated_plugins.cmake
    runner/
      CMakeLists.txt
      main.cc
      my_application.cc
      my_application.h
    .gitignore
    CMakeLists.txt
  macos/
    Flutter/
      Flutter-Debug.xcconfig
      Flutter-Release.xcconfig
      GeneratedPluginRegistrant.swift
    Runner/
      Assets.xcassets/
        AppIcon.appiconset/
          Contents.json
      Base.lproj/
        MainMenu.xib
      Configs/
        AppInfo.xcconfig
        Debug.xcconfig
        Release.xcconfig
        Warnings.xcconfig
      AppDelegate.swift
      DebugProfile.entitlements
      Info.plist
      MainFlutterWindow.swift
      Release.entitlements
    Runner.xcodeproj/
      project.xcworkspace/
        xcshareddata/
          IDEWorkspaceChecks.plist
      xcshareddata/
        xcschemes/
          Runner.xcscheme
      project.pbxproj
    Runner.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
      contents.xcworkspacedata
    RunnerTests/
      RunnerTests.swift
    .gitignore
  test/
    pomodoro_controller_test.dart
    timer_service_test.dart
    widget_test.dart
  web/
    index.html
    manifest.json
  windows/
    flutter/
      CMakeLists.txt
      generated_plugin_registrant.cc
      generated_plugin_registrant.h
      generated_plugins.cmake
    runner/
      CMakeLists.txt
      flutter_window.cpp
      flutter_window.h
      main.cpp
      resource.h
      runner.exe.manifest
      Runner.rc
      utils.cpp
      utils.h
      win32_window.cpp
      win32_window.h
    .gitignore
    CMakeLists.txt
  .gitignore
  .metadata
  analysis_options.yaml
  devtools_options.yaml
  pubspec.lock
  pubspec.yaml
  README.md
static/
  script.js
  style.css
templates/
  index.html
.gitignore
app.py
build_plan.txt
GEMINI.md
logs.txt
package.json
schema.sql
Script.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="flutter_app/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java">
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new xyz.luan.audioplayers.AudioplayersPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin audioplayers_android, xyz.luan.audioplayers.AudioplayersPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_local_notifications, com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.it_nomads.fluttersecurestorage.FlutterSecureStoragePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_secure_storage, com.it_nomads.fluttersecurestorage.FlutterSecureStoragePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
    }
  }
}
</file>

<file path="flutter_app/android/flutter_app_android.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="FacetManager">
    <facet type="android" name="Android">
      <configuration>
        <option name="ALLOW_USER_CONFIGURATION" value="false" />
        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/app/src/main/AndroidManifest.xml" />
        <option name="RES_FOLDER_RELATIVE_PATH" value="/app/src/main/res" />
        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/app/src/main/assets" />
        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/app/src/main/libs" />
        <option name="PROGUARD_LOGS_FOLDER_RELATIVE_PATH" value="/app/src/main/proguard_logs" />
      </configuration>
    </facet>
  </component>
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/app/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/app/src/main/kotlin" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
    </content>
    <orderEntry type="jdk" jdkName="Android API 29 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Flutter for Android" level="project" />
    <orderEntry type="library" name="KotlinJavaRuntime" level="project" />
  </component>
</module>
</file>

<file path="backend/.dart_tool/extension_discovery/devtools.json">
{"version":2,"entries":[{"package":"todoapp_backend","rootUri":"../","packageUri":"lib/"}]}
</file>

<file path="backend/.dart_tool/extension_discovery/README.md">
Extension Discovery Cache
=========================

This folder is used by `package:extension_discovery` to cache lists of
packages that contains extensions for other packages.

DO NOT USE THIS FOLDER
----------------------

 * Do not read (or rely) the contents of this folder.
 * Do write to this folder.

If you're interested in the lists of extensions stored in this folder use the
API offered by package `extension_discovery` to get this information.

If this package doesn't work for your use-case, then don't try to read the
contents of this folder. It may change, and will not remain stable.

Use package `extension_discovery`
---------------------------------

If you want to access information from this folder.

Feel free to delete this folder
-------------------------------

Files in this folder act as a cache, and the cache is discarded if the files
are older than the modification time of `.dart_tool/package_config.json`.

Hence, it should never be necessary to clear this cache manually, if you find a
need to do please file a bug.
</file>

<file path="backend/.dart_tool/extension_discovery/vs_code.json">
{"version":2,"entries":[{"package":"todoapp_backend","rootUri":"../","packageUri":"lib/"}]}
</file>

<file path="backend/.dart_tool/package_config.json">
{
  "configVersion": 2,
  "packages": [
    {
      "name": "args",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/args-2.7.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "async",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/async-2.13.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "collection",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/collection-1.19.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "crypto",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/crypto-3.0.6",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "dotenv",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/dotenv-4.2.0",
      "packageUri": "lib/",
      "languageVersion": "2.16"
    },
    {
      "name": "ffi",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/ffi-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "http_methods",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/http_methods-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "http_parser",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/http_parser-4.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "js",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/js-0.6.7",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "meta",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/meta-1.17.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "path",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/path-1.9.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "shelf",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/shelf-1.4.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "shelf_router",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/shelf_router-1.1.4",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "source_span",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/source_span-1.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "sqlite3",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/sqlite3-1.11.2",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "stack_trace",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/stack_trace-1.12.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "stream_channel",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/stream_channel-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "string_scanner",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/string_scanner-1.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "term_glyph",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/term_glyph-1.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "typed_data",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/typed_data-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "uuid",
      "rootUri": "file:///Users/pustak/.pub-cache/hosted/pub.dev/uuid-3.0.7",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "todoapp_backend",
      "rootUri": "../",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    }
  ],
  "generator": "pub",
  "generatorVersion": "3.9.0",
  "flutterRoot": "file:///opt/homebrew/share/flutter",
  "flutterVersion": "3.35.1",
  "pubCache": "file:///Users/pustak/.pub-cache"
}
</file>

<file path="backend/.dart_tool/package_graph.json">
{
  "roots": [
    "todoapp_backend"
  ],
  "packages": [
    {
      "name": "todoapp_backend",
      "version": "0.0.1",
      "dependencies": [
        "dotenv",
        "shelf",
        "shelf_router",
        "sqlite3",
        "uuid"
      ],
      "devDependencies": []
    },
    {
      "name": "uuid",
      "version": "3.0.7",
      "dependencies": [
        "crypto"
      ]
    },
    {
      "name": "dotenv",
      "version": "4.2.0",
      "dependencies": [
        "args",
        "meta"
      ]
    },
    {
      "name": "sqlite3",
      "version": "1.11.2",
      "dependencies": [
        "collection",
        "ffi",
        "js",
        "meta",
        "path"
      ]
    },
    {
      "name": "shelf_router",
      "version": "1.1.4",
      "dependencies": [
        "http_methods",
        "meta",
        "shelf"
      ]
    },
    {
      "name": "shelf",
      "version": "1.4.2",
      "dependencies": [
        "async",
        "collection",
        "http_parser",
        "path",
        "stack_trace",
        "stream_channel"
      ]
    },
    {
      "name": "crypto",
      "version": "3.0.6",
      "dependencies": [
        "typed_data"
      ]
    },
    {
      "name": "meta",
      "version": "1.17.0",
      "dependencies": []
    },
    {
      "name": "args",
      "version": "2.7.0",
      "dependencies": []
    },
    {
      "name": "path",
      "version": "1.9.1",
      "dependencies": []
    },
    {
      "name": "js",
      "version": "0.6.7",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "ffi",
      "version": "2.1.4",
      "dependencies": []
    },
    {
      "name": "collection",
      "version": "1.19.1",
      "dependencies": []
    },
    {
      "name": "http_methods",
      "version": "1.1.1",
      "dependencies": []
    },
    {
      "name": "stream_channel",
      "version": "2.1.4",
      "dependencies": [
        "async"
      ]
    },
    {
      "name": "stack_trace",
      "version": "1.12.1",
      "dependencies": [
        "path"
      ]
    },
    {
      "name": "http_parser",
      "version": "4.1.2",
      "dependencies": [
        "collection",
        "source_span",
        "string_scanner",
        "typed_data"
      ]
    },
    {
      "name": "async",
      "version": "2.13.0",
      "dependencies": [
        "collection",
        "meta"
      ]
    },
    {
      "name": "typed_data",
      "version": "1.4.0",
      "dependencies": [
        "collection"
      ]
    },
    {
      "name": "string_scanner",
      "version": "1.4.1",
      "dependencies": [
        "source_span"
      ]
    },
    {
      "name": "source_span",
      "version": "1.10.1",
      "dependencies": [
        "collection",
        "path",
        "term_glyph"
      ]
    },
    {
      "name": "term_glyph",
      "version": "1.2.2",
      "dependencies": []
    }
  ],
  "configVersion": 1
}
</file>

<file path="backend/bin/cli.dart">
import 'dart:io';
import 'package:sqlite3/sqlite3.dart';

final String databasePath = 'database.db';

Database getDb() => sqlite3.open(databasePath);

void initDb() {
  final dbFile = File('../schema.sql');
  if (!dbFile.existsSync()) {
    print('schema.sql not found at ../schema.sql');
    exit(1);
  }
  final sql = dbFile.readAsStringSync();
  final db = getDb();
  db.execute(sql);
  db.dispose();
  print('Initialized the database.');
}

void fixFocusedTimes() {
  final db = getDb();
  final rows = db.select('SELECT id, focused_time, overdue_time FROM todos');
  var fixed = 0;
  for (final r in rows) {
    final tid = r['id'] as int;
    var ft = (r['focused_time'] as int?) ?? 0;
    var ot = (r['overdue_time'] as int?) ?? 0;
    if (ft > 1000000) {
      final newFt = ft ~/ 1000;
      final newOt = (ot != 0 && ot > 1000000) ? (ot ~/ 1000) : ot;
      final meta = db.select(
        'SELECT duration_hours, duration_minutes FROM todos WHERE id = ?',
        [tid],
      );
      var dh = 0;
      var dm = 0;
      if (meta.isNotEmpty) {
        dh = (meta.first['duration_hours'] as int?) ?? 0;
        dm = (meta.first['duration_minutes'] as int?) ?? 0;
      }
      final total = (dh * 3600) + (dm * 60);
      final wasOverdue = (total > 0 && newFt > total) ? 1 : 0;
      final overdueTime = (total > 0)
          ? ((newFt > total) ? (newFt - total) : 0)
          : newOt;
      final stmt = db.prepare(
        'UPDATE todos SET focused_time = ?, overdue_time = ?, was_overdue = ? WHERE id = ?',
      );
      stmt.execute([newFt, overdueTime, wasOverdue, tid]);
      stmt.dispose();
      fixed += 1;
    }
  }
  db.dispose();
  print('Fixed $fixed todos.');
}

void printUsage() {
  print('Usage: dart run bin/cli.dart <command>');
  print('Commands:');
  print('  init-db           Initialize the database using ../schema.sql');
  print(
    '  fix-focused-times Fix obviously bad focused_time/overdue_time values',
  );
}

void main(List<String> args) {
  if (args.isEmpty) {
    printUsage();
    exit(0);
  }
  final cmd = args.first;
  if (cmd == 'init-db') {
    initDb();
  } else if (cmd == 'fix-focused-times') {
    fixFocusedTimes();
  } else {
    printUsage();
  }
}
</file>

<file path="backend/bin/server.dart">
import 'dart:convert';
import 'dart:io';

import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart' as io;
import 'package:shelf_router/shelf_router.dart';
import 'package:sqlite3/sqlite3.dart';

final String databasePath = 'database.db';

Database getDb() {
  final db = sqlite3.open(databasePath);
  return db;
}

Map<String, dynamic>? currentUser(Request request) {
  // Simple development fallback: if header 'x-user-id' present use it.
  final userId = request.headers['x-user-id'];
  if (userId != null && userId.isNotEmpty) {
    return {'sub': userId};
  }
  // If running in debug locally, allow a default dev user
  if (Platform.environment['DEBUG'] == '1') {
    return {'sub': 'dev'};
  }
  return null;
}

void ensureWasOverdueColumn(Database db) {
  // Check if columns exist in 'todos' and add if missing
  final result = db.select("PRAGMA table_info('todos');");
  final cols = result.map((r) => r['name'] as String).toList();
  if (!cols.contains('was_overdue')) {
    db.execute(
      "ALTER TABLE todos ADD COLUMN was_overdue INTEGER NOT NULL DEFAULT 0",
    );
  }
  if (!cols.contains('overdue_time')) {
    db.execute(
      "ALTER TABLE todos ADD COLUMN overdue_time INTEGER NOT NULL DEFAULT 0",
    );
  }
}

int maxSessionSeconds = 24 * 3600;

Response jsonResponse(Object? obj, {int status = 200}) {
  return Response(
    status,
    body: json.encode(obj),
    headers: {'content-type': 'application/json'},
  );
}

Future<Response> apiTodos(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse([], status: 200);

  final db = getDb();
  ensureWasOverdueColumn(db);
  final rows = db.select('SELECT * FROM todos WHERE user_id = ?', [
    user['sub'],
  ]);
  final result = rows.map((r) {
    return {
      'id': r['id'],
      'user_id': r['user_id'],
      'text': r['text'],
      'completed': r['completed'],
      'duration_hours': r['duration_hours'],
      'duration_minutes': r['duration_minutes'],
      'focused_time': r['focused_time'],
      'was_overdue': r['was_overdue'] ?? 0,
      'overdue_time': r['overdue_time'] ?? 0,
    };
  }).toList();
  db.dispose();
  return jsonResponse(result);
}

Future<Response> addTodo(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse({'error': 'Unauthorized'}, status: 401);
  final payload =
      json.decode(await request.readAsString()) as Map<String, dynamic>;
  final todoText = (payload['text'] as String?)?.trim() ?? '';
  final durationHours =
      int.tryParse((payload['duration_hours'] ?? '0').toString()) ?? 0;
  final durationMinutes =
      int.tryParse((payload['duration_minutes'] ?? '0').toString()) ?? 0;
  if (todoText.isEmpty)
    return jsonResponse({'error': 'Text is required'}, status: 400);

  final db = getDb();
  final stmt = db.prepare(
    'INSERT INTO todos (user_id, text, duration_hours, duration_minutes, focused_time, was_overdue, overdue_time) VALUES (?, ?, ?, ?, 0, 0, 0)',
  );
  stmt.execute([user['sub'], todoText, durationHours, durationMinutes]);
  final newId = db.lastInsertRowId;
  stmt.dispose();
  db.dispose();

  return jsonResponse({
    'id': newId,
    'text': todoText,
    'completed': 0,
    'duration_hours': durationHours,
    'duration_minutes': durationMinutes,
    'focused_time': 0,
    'was_overdue': 0,
    'overdue_time': 0,
  });
}

Future<Response> deleteTodo(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse({'error': 'Unauthorized'}, status: 401);
  final payload =
      json.decode(await request.readAsString()) as Map<String, dynamic>;
  final todoId = payload['id'];
  final db = getDb();
  final stmt = db.prepare('DELETE FROM todos WHERE id = ? AND user_id = ?');
  stmt.execute([todoId, user['sub']]);
  stmt.dispose();
  db.dispose();
  return jsonResponse({'result': 'success'});
}

Future<Response> toggleTodo(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse({'error': 'Unauthorized'}, status: 401);
  final payload =
      json.decode(await request.readAsString()) as Map<String, dynamic>;
  final todoId = payload['id'];
  final db = getDb();
  final row = db.select(
    'SELECT completed FROM todos WHERE id = ? AND user_id = ?',
    [todoId, user['sub']],
  );
  if (row.isNotEmpty) {
    final current = row.first['completed'] as int;
    final newVal = current == 0 ? 1 : 0;
    final stmt = db.prepare(
      'UPDATE todos SET completed = ? WHERE id = ? AND user_id = ?',
    );
    stmt.execute([newVal, todoId, user['sub']]);
    stmt.dispose();
  }
  db.dispose();
  return jsonResponse({'result': 'success'});
}

Future<Response> updateTodo(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse({'error': 'Unauthorized'}, status: 401);
  final payload =
      json.decode(await request.readAsString()) as Map<String, dynamic>;
  final todoId = payload['id'];
  if (todoId == null) return jsonResponse({'error': 'Missing id'}, status: 400);
  final db = getDb();
  if (payload.containsKey('text')) {
    final stmt = db.prepare(
      'UPDATE todos SET text = ? WHERE id = ? AND user_id = ?',
    );
    stmt.execute([payload['text'], todoId, user['sub']]);
    stmt.dispose();
  }
  if (payload.containsKey('duration_hours')) {
    final stmt = db.prepare(
      'UPDATE todos SET duration_hours = ? WHERE id = ? AND user_id = ?',
    );
    stmt.execute([payload['duration_hours'], todoId, user['sub']]);
    stmt.dispose();
  }
  if (payload.containsKey('duration_minutes')) {
    final stmt = db.prepare(
      'UPDATE todos SET duration_minutes = ? WHERE id = ? AND user_id = ?',
    );
    stmt.execute([payload['duration_minutes'], todoId, user['sub']]);
    stmt.dispose();
  }
  db.dispose();
  return jsonResponse({'result': 'success'});
}

Future<Response> updateFocusTime(Request request) async {
  final user = currentUser(request);
  if (user == null) return jsonResponse({'error': 'Unauthorized'}, status: 401);
  final payload =
      json.decode(await request.readAsString()) as Map<String, dynamic>;
  final todoId = payload['id'];
  int ft = 0;
  try {
    ft = int.tryParse((payload['focused_time'] ?? '0').toString()) ?? 0;
  } catch (_) {
    ft = 0;
  }
  if (ft > 1000000) ft = ft ~/ 1000;
  if (ft > maxSessionSeconds) ft = maxSessionSeconds;

  final db = getDb();
  final stmt = db.prepare(
    'UPDATE todos SET focused_time = ? WHERE id = ? AND user_id = ?',
  );
  stmt.execute([ft, todoId, user['sub']]);
  stmt.dispose();

  final rows = db.select(
    'SELECT duration_hours, duration_minutes FROM todos WHERE id = ? AND user_id = ?',
    [todoId, user['sub']],
  );
  int wasOverdue = 0;
  int overdueTime = 0;
  if (rows.isNotEmpty) {
    final row = rows.first;
    final durationHours = row['duration_hours'] as int? ?? 0;
    final durationMinutes = row['duration_minutes'] as int? ?? 0;
    final totalSeconds = (durationHours * 3600) + (durationMinutes * 60);
    if (totalSeconds > 0 && ft > totalSeconds) {
      wasOverdue = 1;
      overdueTime = ft - totalSeconds;
    }
  }
  final stmt2 = db.prepare(
    'UPDATE todos SET was_overdue = ?, overdue_time = ? WHERE id = ? AND user_id = ?',
  );
  stmt2.execute([wasOverdue, overdueTime, todoId, user['sub']]);
  stmt2.dispose();
  db.dispose();

  return jsonResponse({
    'result': 'success',
    'was_overdue': wasOverdue,
    'overdue_time': overdueTime,
    'focused_time': ft,
  });
}

void main(List<String> args) async {
  final ip = InternetAddress.anyIPv4;
  final port = int.tryParse(Platform.environment['PORT'] ?? '5000') ?? 5000;

  final router = Router();

  router.get('/api/todos', (Request request) => apiTodos(request));
  router.post('/add', (Request request) => addTodo(request));
  router.post('/delete', (Request request) => deleteTodo(request));
  router.post('/toggle', (Request request) => toggleTodo(request));
  router.post('/update', (Request request) => updateTodo(request));
  router.post(
    '/update_focus_time',
    (Request request) => updateFocusTime(request),
  );

  final handler =
      const Pipeline().addMiddleware(logRequests()).addHandler(router);

  final server = await io.serve(handler, ip, port);
  print('Server listening on http://${server.address.host}:${server.port}');
}
</file>

<file path="backend/pubspec.lock">
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  dotenv:
    dependency: "direct main"
    description:
      name: dotenv
      sha256: "379e64b6fc82d3df29461d349a1796ecd2c436c480d4653f3af6872eccbc90e1"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.0"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "289279317b4b16eb2bb7e271abccd4bf84ec9bdcbe999e278a94b804f5630418"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  http_methods:
    dependency: transitive
    description:
      name: http_methods
      sha256: "6bccce8f1ec7b5d701e7921dca35e202d425b57e317ba1a37f2638590e29e566"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  js:
    dependency: transitive
    description:
      name: js
      sha256: f2c445dce49627136094980615a031419f7f3eb393237e4ecd97ac15dea343f3
      url: "https://pub.dev"
    source: hosted
    version: "0.6.7"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "23f08335362185a5ea2ad3a4e597f1375e78bce8a040df5c600c8d3552ef2394"
      url: "https://pub.dev"
    source: hosted
    version: "1.17.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  shelf:
    dependency: "direct main"
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_router:
    dependency: "direct main"
    description:
      name: shelf_router
      sha256: f5e5d492440a7fb165fe1e2e1a623f31f734d3370900070b2b1e0d0428d59864
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  sqlite3:
    dependency: "direct main"
    description:
      name: sqlite3
      sha256: "281b672749af2edf259fc801f0fcba092257425bcd32a0ce1c8237130bc934c7"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.2"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: "648e103079f7c64a36dc7d39369cabb358d377078a051d6ae2ad3aa539519313"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
sdks:
  dart: ">=3.7.0 <4.0.0"
</file>

<file path="backend/pubspec.yaml">
name: todoapp_backend
description: Dart replacement for the Flask backend used by the Todoapp project.
version: 0.0.1
environment:
  sdk: '>=2.18.0 <4.0.0'
dependencies:
  shelf: ^1.4.0
  shelf_router: ^1.1.0
  sqlite3: ^1.2.0
  dotenv: ^4.2.0
  uuid: ^3.0.7
</file>

<file path="backend/README.md">
# Dart backend replacement for Flask app

This folder contains a minimal Dart backend implemented with `shelf` and `sqlite3` to replace the original Flask `app.py`.

How to run

1. Install Dart SDK (2.18+).
2. From this folder run:

```bash
dart pub get
dart run bin/server.dart
```

3. The server listens on port 5000 by default. For local development, the Flutter client can pass the `x-user-id` header to simulate a logged-in user (the original app used OAuth). Example: `x-user-id: dev`.

Notes
- OAuth was simplified: the Dart server uses an `x-user-id` header or DEBUG env var to allow local development without external OAuth provider.
- The server expects the same SQLite file `database.db` used by the app; it will alter the schema to add `was_overdue` and `overdue_time` columns if missing.
</file>

<file path="backend/schema.sql">
CREATE TABLE IF NOT EXISTS todos (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  text TEXT NOT NULL,
  completed INTEGER DEFAULT 0,
  duration_hours INTEGER DEFAULT 0,
  duration_minutes INTEGER DEFAULT 0,
  focused_time INTEGER DEFAULT 0,
  was_overdue INTEGER DEFAULT 0,
  overdue_time INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
</file>

<file path="backend/server.pid">
62122
</file>

<file path="flutter_app/android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="flutter_app/android/app/src/main/kotlin/com/example/flutter_app/MainActivity.kt">
package com.example.flutter_app

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
</file>

<file path="flutter_app/android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="flutter_app/android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="flutter_app/android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="flutter_app/android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="flutter_app/android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="flutter_app"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="flutter_app/android/app/src/profile/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="flutter_app/android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.flutter_app"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    // Enable core library desugaring for libraries that require newer Java APIs on older
    // Android runtimes (required by flutter_local_notifications and others).
    isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.flutter_app"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    // Provides backported Java core library APIs for desugaring on older Android runtimes.
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
}
</file>

<file path="flutter_app/android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip
</file>

<file path="flutter_app/android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="flutter_app/android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="flutter_app/android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
</file>

<file path="flutter_app/android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="flutter_app/ios/Flutter/AppFrameworkInfo.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Flutter/Debug.xcconfig">
#include "Generated.xcconfig"
</file>

<file path="flutter_app/ios/Flutter/Release.xcconfig">
#include "Generated.xcconfig"
</file>

<file path="flutter_app/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="flutter_app/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json">
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="flutter_app/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md">
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
</file>

<file path="flutter_app/ios/Runner/Base.lproj/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>
</file>

<file path="flutter_app/ios/Runner/Base.lproj/Main.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>
</file>

<file path="flutter_app/ios/Runner/AppDelegate.swift">
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
</file>

<file path="flutter_app/ios/Runner/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Flutter App</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>flutter_app</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Runner/Runner-Bridging-Header.h">
#import "GeneratedPluginRegistrant.h"
</file>

<file path="flutter_app/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="flutter_app/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="flutter_app/ios/Runner.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}
</file>

<file path="flutter_app/ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="flutter_app/ios/Runner.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="flutter_app/ios/RunnerTests/RunnerTests.swift">
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
</file>

<file path="flutter_app/ios/.gitignore">
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
</file>

<file path="flutter_app/lib/models/todo.dart">
class Todo {
  final int id;
  final String userId;
  final String text;
  final bool completed;
  final int durationHours;
  final int durationMinutes;
  final int focusedTime;
  final int wasOverdue;
  final int overdueTime;

  Todo({
    required this.id,
    required this.userId,
    required this.text,
    required this.completed,
    required this.durationHours,
    required this.durationMinutes,
    required this.focusedTime,
    required this.wasOverdue,
    required this.overdueTime,
  });

  factory Todo.fromJson(Map<String, dynamic> j) {
    return Todo(
      id: j['id'] is int ? j['id'] : int.parse('${j['id']}'),
      userId: j['user_id'] ?? j['userId'] ?? '',
      text: j['text'] ?? '',
      completed: (j['completed'] == 1 || j['completed'] == true),
      durationHours: j['duration_hours'] != null ? (j['duration_hours'] is int ? j['duration_hours'] : int.parse('${j['duration_hours']}')) : 0,
      durationMinutes: j['duration_minutes'] != null ? (j['duration_minutes'] is int ? j['duration_minutes'] : int.parse('${j['duration_minutes']}')) : 0,
      focusedTime: j['focused_time'] != null ? (j['focused_time'] is int ? j['focused_time'] : int.parse('${j['focused_time']}')) : 0,
      wasOverdue: j['was_overdue'] != null ? (j['was_overdue'] is int ? j['was_overdue'] : int.parse('${j['was_overdue']}')) : 0,
      overdueTime: j['overdue_time'] != null ? (j['overdue_time'] is int ? j['overdue_time'] : int.parse('${j['overdue_time']}')) : 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'text': text,
      'completed': completed ? 1 : 0,
      'duration_hours': durationHours,
      'duration_minutes': durationMinutes,
      'focused_time': focusedTime,
      'was_overdue': wasOverdue,
      'overdue_time': overdueTime,
    };
  }
}
</file>

<file path="flutter_app/lib/services/local_timer_store.dart">
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/task_timer_state.dart';

class LocalTimerStore {
  static const key = 'todo_task_timer_states_v1';

  Future<Map<String, TaskTimerState>> loadAll() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(key);
    if (raw == null) return {};
    try {
      final parsed = json.decode(raw) as Map<String, dynamic>;
      final out = <String, TaskTimerState>{};
      parsed.forEach((k, v) {
        out[k] = TaskTimerState.fromJson(Map<String, dynamic>.from(v));
      });
      return out;
    } catch (e) {
      return {};
    }
  }

  Future<void> saveAll(Map<String, TaskTimerState> map) async {
    final prefs = await SharedPreferences.getInstance();
    final serializable = map.map((k, v) => MapEntry(k, v.toJson()));
    await prefs.setString(key, json.encode(serializable));
  }

  Future<void> save(String taskId, TaskTimerState s) async {
    final all = await loadAll();
    all[taskId] = s;
    await saveAll(all);
  }

  Future<TaskTimerState?> load(String taskId) async {
    final all = await loadAll();
    return all[taskId];
  }
}
</file>

<file path="flutter_app/lib/services/notification_service.dart">
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:audioplayers/audioplayers.dart';

class NotificationService {
  final FlutterLocalNotificationsPlugin _notificationsPlugin =
      FlutterLocalNotificationsPlugin();
  final AudioPlayer _audioPlayer = AudioPlayer();
  // _audioCache removed: using AudioPlayer with AssetSource for playback.

  Future<void> init() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    final InitializationSettings initializationSettings =
        InitializationSettings(android: initializationSettingsAndroid);

    await _notificationsPlugin.initialize(initializationSettings);
  }

  Future<void> showNotification({
    required String title,
    required String body,
  }) async {
    const AndroidNotificationDetails androidPlatformChannelSpecifics =
        AndroidNotificationDetails(
          'pomodoro_channel',
          'Pomodoro Notifications',
          channelDescription: 'Notifications for Pomodoro timer events',
          importance: Importance.max,
          priority: Priority.high,
          showWhen: false,
        );

    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
    );

    await _notificationsPlugin.show(0, title, body, platformChannelSpecifics);
  }

  Future<void> playSound(String sound) async {
    await _audioPlayer.play(AssetSource(sound));
  }
}
</file>

<file path="flutter_app/lib/theme/app_colors.dart">
import 'package:flutter/material.dart';

class AppColors {
  static const scaffoldBg = Color(0xFF1A1A1A);
  static const cardBg = Color(0xFF2C2C2C);
  static const midGray = Color(0xFF404040);
  static const lightGray = Color(0xFFE0E0E0);
  static const mediumGray = Color(0xFFA0A0A0);
  // Primary action color
  static const brightYellow = Color(0xFFFFD700);
  // Slightly muted secondary action for less prominent buttons
  static const actionSecondary = Color(0xFFB59A00);
  // Priority colors
  static const priorityHigh = Color(0xFFE84545);
  static const priorityMedium = Color(0xFFF2A33A);
  static const priorityLow = Color(0xFF6BCB77);
  // Input focus border
  static const focusBorder = Color(0xFF6FB3FF);
  // Input fill color for fields
  static const inputFill = Color(0xFF333333);
}
</file>

<file path="flutter_app/lib/utils/debug_logger.dart">
import 'package:flutter/foundation.dart';

/// Simple debug logger used across the app.
/// In debug mode it prints a tagged message to the console only.
void debugLog(String tag, String message) {
  if (!kDebugMode) return;
  // ignore: avoid_print
  print('DEBUG [$tag]: $message');
}
</file>

<file path="flutter_app/linux/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)
</file>

<file path="flutter_app/linux/flutter/generated_plugin_registrant.cc">
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <audioplayers_linux/audioplayers_linux_plugin.h>
#include <flutter_secure_storage_linux/flutter_secure_storage_linux_plugin.h>

void fl_register_plugins(FlPluginRegistry* registry) {
  g_autoptr(FlPluginRegistrar) audioplayers_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "AudioplayersLinuxPlugin");
  audioplayers_linux_plugin_register_with_registrar(audioplayers_linux_registrar);
  g_autoptr(FlPluginRegistrar) flutter_secure_storage_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "FlutterSecureStorageLinuxPlugin");
  flutter_secure_storage_linux_plugin_register_with_registrar(flutter_secure_storage_linux_registrar);
}
</file>

<file path="flutter_app/linux/flutter/generated_plugin_registrant.h">
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_
</file>

<file path="flutter_app/linux/flutter/generated_plugins.cmake">
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  audioplayers_linux
  flutter_secure_storage_linux
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)
</file>

<file path="flutter_app/linux/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
</file>

<file path="flutter_app/linux/runner/main.cc">
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}
</file>

<file path="flutter_app/linux/runner/my_application.cc">
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView *view)
{
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "flutter_app");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "flutter_app");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000 for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb), self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}
</file>

<file path="flutter_app/linux/runner/my_application.h">
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_
</file>

<file path="flutter_app/linux/.gitignore">
flutter/ephemeral
</file>

<file path="flutter_app/linux/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "flutter_app")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.example.flutter_app")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()
</file>

<file path="flutter_app/macos/Flutter/Flutter-Debug.xcconfig">
#include "ephemeral/Flutter-Generated.xcconfig"
</file>

<file path="flutter_app/macos/Flutter/Flutter-Release.xcconfig">
#include "ephemeral/Flutter-Generated.xcconfig"
</file>

<file path="flutter_app/macos/Flutter/GeneratedPluginRegistrant.swift">
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import audioplayers_darwin
import flutter_local_notifications
import flutter_secure_storage_macos
import google_sign_in_ios
import path_provider_foundation
import shared_preferences_foundation

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  AudioplayersDarwinPlugin.register(with: registry.registrar(forPlugin: "AudioplayersDarwinPlugin"))
  FlutterLocalNotificationsPlugin.register(with: registry.registrar(forPlugin: "FlutterLocalNotificationsPlugin"))
  FlutterSecureStoragePlugin.register(with: registry.registrar(forPlugin: "FlutterSecureStoragePlugin"))
  FLTGoogleSignInPlugin.register(with: registry.registrar(forPlugin: "FLTGoogleSignInPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
}
</file>

<file path="flutter_app/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="flutter_app/macos/Runner/Base.lproj/MainMenu.xib">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>
</file>

<file path="flutter_app/macos/Runner/Configs/AppInfo.xcconfig">
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = flutter_app

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright  2025 com.example. All rights reserved.
</file>

<file path="flutter_app/macos/Runner/Configs/Debug.xcconfig">
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"
</file>

<file path="flutter_app/macos/Runner/Configs/Release.xcconfig">
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"
</file>

<file path="flutter_app/macos/Runner/Configs/Warnings.xcconfig">
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES
</file>

<file path="flutter_app/macos/Runner/AppDelegate.swift">
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}
</file>

<file path="flutter_app/macos/Runner/DebugProfile.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/macos/Runner/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>
</file>

<file path="flutter_app/macos/Runner/MainFlutterWindow.swift">
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}
</file>

<file path="flutter_app/macos/Runner/Release.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/macos/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/macos/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "33CC10EC2044A3C60003C045"
               BuildableName = "flutter_app.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "flutter_app.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C80D4294CF70F00263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "flutter_app.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "flutter_app.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="flutter_app/macos/Runner.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* flutter_app.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "flutter_app.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* flutter_app.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* flutter_app.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/flutter_app.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/flutter_app";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/flutter_app.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/flutter_app";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.flutterApp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/flutter_app.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/flutter_app";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}
</file>

<file path="flutter_app/macos/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="flutter_app/macos/Runner.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="flutter_app/macos/RunnerTests/RunnerTests.swift">
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
</file>

<file path="flutter_app/macos/.gitignore">
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/
</file>

<file path="flutter_app/test/pomodoro_controller_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_app/services/pomodoro_controller.dart';

void main() {
  test('start, pause and overdue detection', () async {
    final c = PomodoroController();
    int added = 0;
    bool overdueCalled = false;
    c.onFocusSegmentComplete = (taskId, seconds) {
      added += seconds;
    };
    c.onOverdue = (taskId) {
      overdueCalled = true;
    };

    // start with short durations to exercise quickly
    c.start(
      1,
      focusSec: 2,
      breakSec: 1,
      cycles: 1,
      plannedDurationSec: 3,
      initialFocusedSeconds: 1,
    );
    expect(c.activeTaskId, 1);
    expect(c.isRunning, true);

    // wait 3 seconds for focus to end
    await Future.delayed(const Duration(seconds: 3));

    // after auto-transition, the controller should have called onFocusSegmentComplete
    expect(added > 0, true);
    // plannedDurationSec was 3 and initialFocusedSeconds was 1 so after 2 seconds it should be >=3 -> overdue called
    expect(overdueCalled, true);
    c.dispose();
  });
}
</file>

<file path="flutter_app/test/timer_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_app/services/timer_service.dart';

void main() {
  setUp(() {
    // reset service to a known state before each test
    TimerService.instance.clear();
  });

  test('initial state after clear', () {
    final svc = TimerService.instance;
    expect(svc.activeTaskName, isNull);
    expect(svc.timeRemaining, 0);
    expect(svc.isRunning, isFalse);
    expect(svc.isTimerActive, isFalse);
    expect(svc.currentMode, 'focus');
    expect(svc.plannedDurationSeconds, isNull);
  });

  test('update sets fields and notifies listeners', () {
    final svc = TimerService.instance;
    var notifications = 0;
    void listener() => notifications++;
    svc.addListener(listener);

    svc.update(
      taskName: 'task1',
      remaining: 120,
      running: true,
      active: true,
      plannedDuration: 3600,
      mode: 'break',
    );

    expect(svc.activeTaskName, 'task1');
    expect(svc.timeRemaining, 120);
    expect(svc.isRunning, isTrue);
    expect(svc.isTimerActive, isTrue);
    expect(svc.plannedDurationSeconds, 3600);
    expect(svc.currentMode, 'break');
    expect(notifications, greaterThan(0));

    svc.removeListener(listener);
  });

  test('focused time cache helpers', () {
    final svc = TimerService.instance;
    svc.setFocusedTime('t1', 10);
    expect(svc.getFocusedTime('t1'), 10);

    // empty task name should be ignored (no exception)
    svc.setFocusedTime('', 5);
    expect(svc.getFocusedTime(''), isNull);
  });

  test('toggleRunning flips state and notifies', () {
    final svc = TimerService.instance;
    svc.isRunning = false;
    var notifications = 0;
    void listener() => notifications++;
    svc.addListener(listener);

    svc.toggleRunning();
    expect(svc.isRunning, isTrue);
    expect(notifications, greaterThan(0));

    svc.toggleRunning();
    expect(svc.isRunning, isFalse);

    svc.removeListener(listener);
  });

  test('clear resets state', () {
    final svc = TimerService.instance;
    svc.update(
      taskName: 'x',
      remaining: 10,
      running: true,
      active: true,
      plannedDuration: 5,
      mode: 'focus',
    );
    svc.clear();
    expect(svc.activeTaskName, isNull);
    expect(svc.timeRemaining, 0);
    expect(svc.isRunning, isFalse);
    expect(svc.isTimerActive, isFalse);
    expect(svc.currentMode, 'focus');
    expect(svc.plannedDurationSeconds, isNull);
  });
}
</file>

<file path="flutter_app/test/widget_test.dart">
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutter_app/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
</file>

<file path="flutter_app/web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="flutter_app">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>flutter_app</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="flutter_app/web/manifest.json">
{
    "name": "flutter_app",
    "short_name": "flutter_app",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="flutter_app/windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="flutter_app/windows/flutter/generated_plugin_registrant.cc">
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <audioplayers_windows/audioplayers_windows_plugin.h>
#include <flutter_secure_storage_windows/flutter_secure_storage_windows_plugin.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  AudioplayersWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("AudioplayersWindowsPlugin"));
  FlutterSecureStorageWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FlutterSecureStorageWindowsPlugin"));
}
</file>

<file path="flutter_app/windows/flutter/generated_plugin_registrant.h">
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_
</file>

<file path="flutter_app/windows/flutter/generated_plugins.cmake">
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  audioplayers_windows
  flutter_secure_storage_windows
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  flutter_local_notifications_windows
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)
</file>

<file path="flutter_app/windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="flutter_app/windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="flutter_app/windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="flutter_app/windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"flutter_app", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="flutter_app/windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="flutter_app/windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="flutter_app/windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "flutter_app" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "flutter_app" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "flutter_app.exe" "\0"
            VALUE "ProductName", "flutter_app" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="flutter_app/windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="flutter_app/windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="flutter_app/windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="flutter_app/windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

<file path="flutter_app/windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="flutter_app/windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(flutter_app LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "flutter_app")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path="flutter_app/.gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/
/coverage/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release
</file>

<file path="flutter_app/.metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "20f82749394e68bcfbbeee96bad384abaae09c13"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: android
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: ios
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: linux
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: macos
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: web
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
    - platform: windows
      create_revision: 20f82749394e68bcfbbeee96bad384abaae09c13
      base_revision: 20f82749394e68bcfbbeee96bad384abaae09c13

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="flutter_app/analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="flutter_app/devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
</file>

<file path="flutter_app/README.md">
# flutter_app

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.
</file>

<file path="static/script.js">
document.addEventListener('DOMContentLoaded', () => {
    const todoInput = document.getElementById('todo-input');
    const addButton = document.getElementById('add-button');
    const todoList = document.getElementById('todo-list');
    const completedList = document.getElementById('completed-list');
    const durationHoursInput = document.getElementById('duration-hours');
    const durationMinutesInput = document.getElementById('duration-minutes');

    const todoContainer = document.querySelector('.todo-container');
    const pomodoroContainer = document.querySelector('.pomodoro-container');
    const pomodoroTask = document.getElementById('pomodoro-task');
    const pomodoroSessionDisplay = document.getElementById('pomodoro-session-display');
    const focusDurationInput = document.getElementById('focus-duration');
    const breakDurationInput = document.getElementById('break-duration');
    const cycleCountInput = document.getElementById('cycle-count');
    const pomodoroTimerDisplay = document.querySelector('.pomodoro-timer');
    const pomodoroTimerWrapper = document.querySelector('.pomodoro-timer-wrapper');
    const pomodoroStartPauseBtn = document.getElementById('pomodoro-start-pause');
    const pomodoroSkipBtn = document.getElementById('pomodoro-skip');
    const pomodoroResetBtn = document.getElementById('pomodoro-reset');
    const pomodoroNotification = document.getElementById('pomodoro-notification');
    const pomodoroCloseButton = document.getElementById('pomodoro-close-button');

    const borderFlashes = document.querySelectorAll('.border-flash');

    let timerInterval;
    let progressUpdateInterval;
    let timerState = 'paused';
    let currentMode = 'focus';
    let timeRemaining;
    let totalCycles;
    let currentCycle = 0;
    let currentTaskDuration = 0;
    let currentRunningTaskId = null;
    let focusSessionStartTime = 0;
    let lastFocusedTime = 0;
    let globalProgressCheckerInterval = null;
    // flags to know if user manually edited inputs
    let focusEdited = false;
    let breakEdited = false;
    // store per-task timer state when switching between tasks
    const taskTimerStates = {};
    // last session increment in seconds (most recent active focus session)
    let lastSessionIncrement = 0;

    const TASK_STATE_KEY = 'todo_task_timer_states_v1';

    function persistAllTaskStates() {
        try {
            localStorage.setItem(TASK_STATE_KEY, JSON.stringify(taskTimerStates));
        } catch (e) {
            console.log('DEBUG: persistAllTaskStates failed', e);
        }
    }

    function loadAllTaskStates() {
        try {
            const raw = localStorage.getItem(TASK_STATE_KEY);
            if (raw) {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === 'object') {
                    Object.assign(taskTimerStates, parsed);
                }
            }
        } catch (e) {
            console.log('DEBUG: loadAllTaskStates failed', e);
        }
    }

    function saveTaskTimerState(taskId) {
        if (!taskId) return;
        // compute lastFocusedTime up-to-date if a focus session is active
        let persistedLastFocused = lastFocusedTime;
        if (focusSessionStartTime > 0 && currentRunningTaskId === taskId) {
            const elapsed = Math.floor((Date.now() - focusSessionStartTime) / 1000);
            persistedLastFocused = lastFocusedTime + elapsed;
        }
        taskTimerStates[taskId] = {
            timerState: 'paused', // always pause when switching away
            currentMode: currentMode,
            timeRemaining: timeRemaining || null,
            totalCycles: totalCycles || parseInt(cycleCountInput.value) || null,
            // persist user-editable pomodoro inputs so they restore per-task
            focusDuration: (typeof focusDurationInput !== 'undefined' && focusDurationInput.value) ? parseInt(focusDurationInput.value) || null : null,
            breakDuration: (typeof breakDurationInput !== 'undefined' && breakDurationInput.value) ? parseInt(breakDurationInput.value) || null : null,
            currentCycle: currentCycle || 0,
            lastFocusedTime: persistedLastFocused || 0
        };
    persistAllTaskStates();
    }

    function restoreTaskTimerState(taskId) {
    // ensure we have any persisted states loaded
    if (Object.keys(taskTimerStates).length === 0) loadAllTaskStates();
    const s = taskTimerStates[taskId];
        if (!s) return false;
        // restore fields into global state but keep timer paused
        timerState = 'paused';
        currentMode = s.currentMode || 'focus';
        timeRemaining = (typeof s.timeRemaining !== 'undefined' && s.timeRemaining !== null) ? s.timeRemaining : null;
        totalCycles = s.totalCycles || null;
        currentCycle = s.currentCycle || 0;
        lastFocusedTime = s.lastFocusedTime || 0;
        // update UI
        if (totalCycles) cycleCountInput.value = totalCycles;
        // restore persisted focus/break inputs if present
        if (typeof s.focusDuration !== 'undefined' && s.focusDuration !== null) {
            focusDurationInput.value = s.focusDuration;
        }
        if (typeof s.breakDuration !== 'undefined' && s.breakDuration !== null) {
            breakDurationInput.value = s.breakDuration;
        }
        // clear edit flags since we've just restored values
        focusEdited = false;
        breakEdited = false;
        if (timeRemaining) updateTimerDisplay();
        updateSessionDisplay();
        return true;
    }

    // Add a new to-do item
    addButton.addEventListener('click', () => {
        const todoText = todoInput.value.trim();
        // treat empty hour/minute as 0; require at least one > 0
        const durationHoursRaw = durationHoursInput.value.trim();
        const durationMinutesRaw = durationMinutesInput.value.trim();
        const durationHours = durationHoursRaw === '' ? '0' : durationHoursRaw;
        const durationMinutes = durationMinutesRaw === '' ? '0' : durationMinutesRaw;

        if (!todoText) {
            alert('Task name is required');
            return;
        }
        // require at least one of hours or minutes to be > 0
        if ((parseInt(durationHours) || 0) === 0 && (parseInt(durationMinutes) || 0) === 0) {
            alert('Please enter a duration in hours or minutes');
            return;
        }

        // proceed to create
        if (todoText !== '') {
            fetch('/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: todoText,
                    duration_hours: durationHours,
                    duration_minutes: durationMinutes
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(data.error);
                } else {
                    addTodoItemToDOM(data.id, data.text, data.completed, data.duration_hours, data.duration_minutes, data.focused_time, data.was_overdue, data.overdue_time);
                    todoInput.value = '';
                    durationHoursInput.value = '';
                    durationMinutesInput.value = '';
                    todoInput.focus();
                }
            });
        } else {
            alert('All fields are required');
        }
    });

    todoInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addButton.click();
        }
    });

    // Event listener for all lists
    [todoList, completedList].forEach(list => {
        list.addEventListener('click', (e) => {
            const target = e.target;
            const li = target.closest('li');
            if (!li) return;

            const todoId = li.dataset.id;
            const todoText = li.querySelector('span').textContent;

            if (target.closest('.play-button')) {
                const durationHours = parseInt(li.dataset.durationHours) || 0;
                const durationMinutes = parseInt(li.dataset.durationMinutes) || 0;
                currentTaskDuration = (durationHours * 60) + durationMinutes;
                todoContainer.classList.add('pomodoro-active');
                pomodoroContainer.style.display = 'block';
                pomodoroTask.textContent = todoText;
                // If another task currently has an active focus session, persist and pause it
                // so its progress is not lost when switching to a different task.
                if (currentRunningTaskId && currentRunningTaskId !== todoId) {
                    // save state for previous task
                    saveTaskTimerState(currentRunningTaskId);
                    // If a timer is running (could be focus or break), pause intervals
                    if (timerState === 'running') {
                        pauseTimer();
                    }
                    // If there was an active focus session, stop it and persist elapsed time
                    if (focusSessionStartTime > 0) {
                        stopFocusTimer();
                    }
                }
                // keep the selected task id when resetting UI
                // remove visual highlight from previous task
                const prevActive = document.querySelector('li.active-task');
                if (prevActive && prevActive.dataset.id && prevActive.dataset.id !== todoId) {
                    prevActive.classList.remove('active-task');
                }

                // keep the selected task id when resetting UI
                resetPomodoro();
                currentRunningTaskId = todoId;
                // restore previous saved state if any
                const restored = restoreTaskTimerState(todoId);
                if (!restored) {
                    // set defaults
                    timerState = 'paused';
                    currentMode = 'focus';
                    timeRemaining = null;
                    currentCycle = 0;
                    pomodoroTimerDisplay.textContent = '25:00';
                    cycleCountInput.value = '';
                }
                // highlight the selected task in the list for visibility
                li.classList.add('active-task');
                // ensure default focus/break values (user can change them)
                if (!focusDurationInput.value) focusDurationInput.value = 25;
                if (!breakDurationInput.value) breakDurationInput.value = 5;
                // initialize lastFocusedTime from stored dataset so realtime progress calc is correct
                lastFocusedTime = parseInt(li.dataset.focusedTime) || 0;
                // Render the task name inside the Pomodoro panel with bordered styling
                // If the task is overdue, append a red-dot emoji inline to the name
                const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                const overdueEmoji = (wasOverdue && parseInt(wasOverdue) === 1) ? ' <span class="pomodoro-overdue-emoji"></span>' : '';
                pomodoroTask.innerHTML = `<span class="pomodoro-task-name">${todoText}${overdueEmoji}</span>`;
                // hide the separate overdue hint element (we now show emoji inline)
                const hint = document.getElementById('pomodoro-overdue-hint');
                if (hint) hint.style.display = 'none';
                // Auto-calc cycles if cycles input is empty (applies also for restored overdue tasks)
                updateProgressBar(todoId);
                const focusDurationRaw = parseInt(focusDurationInput.value);
                const focusDuration = (!isNaN(focusDurationRaw) && focusDurationRaw > 0) ? focusDurationRaw : 25;
                if (currentTaskDuration > 0) {
                    // Only auto-calc when user hasn't provided a cycles value
                    if (!cycleCountInput.value || parseInt(cycleCountInput.value) <= 0) {
                        const calculatedCycles = Math.max(1, Math.floor(currentTaskDuration / focusDuration));
                        cycleCountInput.value = calculatedCycles;
                    }
                }
            } else if (target.closest('.done-button')) {
                // Toggle completion status
                const isCurrentlyCompleted = li.classList.contains('completed');
                fetch('/toggle', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: todoId }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.result === 'success') {
                        const doneButtonIcon = li.querySelector('.done-button i');
                        if (isCurrentlyCompleted) { // Task is being uncompleted
                            li.classList.remove('completed');
                            doneButtonIcon.classList.remove('fa-undo');
                            doneButtonIcon.classList.add('fa-check');
                            // If there is an overdue badge, remove it from title and restore card styling
                            const badge = li.querySelector('.overdue-badge');
                            if (badge) badge.remove();
                            // If there was a completed-overdue text indicator, remove it so it doesn't duplicate with active progress bar
                            const compOverEl = li.querySelector('.completed-overdue-text');
                            if (compOverEl) compOverEl.remove();
                            if (li.dataset.wasOverdue == 1 || li.getAttribute('data-was-overdue') == '1') {
                                // restore visual overdue state on the card if still overdue
                                li.classList.add('overdue');
                            }
                            todoList.appendChild(li);
                            // Notify uncompletion? skip notification for uncomplete
                        } else { // Task is being completed
                            li.classList.remove('overdue');
                            // If task was overdue, move visual indicator from card to a small badge next to title
                            const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdue && parseInt(wasOverdue) === 1) {
                                // add red-circle badge emoji
                                addOverdueBadge(li);
                            }

                            li.classList.add('completed');
                            doneButtonIcon.classList.remove('fa-check');
                            doneButtonIcon.classList.add('fa-undo');
                            // remove any live overdue-extra (session-only) to avoid inline display
                            const extraEl = li.querySelector('.overdue-extra'); if (extraEl) extraEl.remove();
                            // Prepend so most-recent completed task appears at the top
                            if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                            else completedList.appendChild(li);
                            // Browser notification and sound for completion
                            try { sendNotification('Task completed', `${todoText}  marked complete`, 'complete'); } catch(e){}
                            // Ensure completed overdue text is placed under the title for consistency
                            const wasOverdueNow = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdueNow && parseInt(wasOverdueNow) === 1) {
                                ensureCompletedOverdueIndicator(li);
                            } else {
                                // add appropriate completed status label
                                ensureCompletedStatusIndicator(li);
                            }

                            if (currentRunningTaskId === todoId) {
                                hidePomodoroTimer();
                            }
                        }
                    }
                });
            } else if (target.closest('.delete-button')) {
                // Delete to-do item
                fetch('/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: todoId }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.result === 'success') {
                        li.remove();
                        if (currentRunningTaskId === todoId) {
                            hidePomodoroTimer();
                        }
                    }
                });
            }
        });
    });

    // Pomodoro Timer Logic
    focusDurationInput.addEventListener('input', () => {
        const focusDuration = parseInt(focusDurationInput.value);
        if (!isNaN(focusDuration) && focusDuration > 0 && currentTaskDuration > 0) {
            const calculatedCycles = Math.floor(currentTaskDuration / focusDuration);
            cycleCountInput.value = calculatedCycles > 0 ? calculatedCycles : 1;
        }
    });

    // track manual edits to focus/break so starting can re-init timer when needed
    focusDurationInput.addEventListener('input', () => { 
        focusEdited = true; 
        if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
    });
    breakDurationInput.addEventListener('input', () => { 
        breakEdited = true; 
        if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
    });

    pomodoroStartPauseBtn.addEventListener('click', () => {
        if (timerState === 'paused') {
            const focusDuration = parseInt(focusDurationInput.value);
            const breakDuration = parseInt(breakDurationInput.value);
            totalCycles = parseInt(cycleCountInput.value);

            // Validate inputs
            if (isNaN(focusDuration) || isNaN(breakDuration) || isNaN(totalCycles) || focusDuration <= 0 || breakDuration <= 0 || totalCycles <= 0) {
                alert('Please enter valid values for focus, break, and cycles.');
                return;
            }

            // If a task is selected, ensure the focus duration does not exceed the task's total planned duration
            // Apply this rule only for normal (non-overdue) tasks. Skip validation for overdue tasks and overdue pomodoro sessions.
            if (currentRunningTaskId) {
                try {
                    const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
                    // Skip validation for overdue tasks (server-reported overdue or UI class)
                    const isOverdue = (li && (li.dataset.wasOverdue && parseInt(li.dataset.wasOverdue) === 1)) || (li && parseInt(li.dataset.overdueTime) > 0) || (li && li.classList && li.classList.contains('overdue'));
                    if (!isOverdue) {
                        const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                        if (rem && typeof rem.total !== 'undefined') {
                            if ((focusDuration * 60) > rem.total) {
                                alert('Focus duration cannot be longer than the task duration. Please reduce the focus duration or increase the task duration.');
                                return;
                            }
                        }
                    }
                } catch (e) {
                    console.log('DEBUG: focus duration validation failed', e);
                }
            }

            // Ensure the session display reflects the newly entered cycles immediately
            updateSessionDisplay();

            // Initialize timeRemaining taking into account manual edits
            if (!timeRemaining) {
                // Cap the initial focus period to the remaining planned time for this task (if available and not overdue)
                if (currentRunningTaskId) {
                    const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                    if (rem && rem.remaining !== undefined && rem.remaining > 0 && rem.remaining < (focusDuration * 60)) {
                        timeRemaining = rem.remaining;
                    } else {
                        timeRemaining = focusDuration * 60;
                    }
                } else {
                    timeRemaining = focusDuration * 60;
                }
                currentCycle++;
                updateSessionDisplay();
            } else if (currentMode === 'focus' && focusEdited && timerState === 'paused') {
                // If user changed focus duration manually while paused but timeRemaining still held old value,
                // reset the timer to the new focus duration for the upcoming start (but keep currentCycle).
                timeRemaining = focusDuration * 60;
                updateTimerDisplay();
                updateSessionDisplay();
            } else if (currentMode === 'break' && breakEdited && timerState === 'paused') {
                timeRemaining = breakDuration * 60;
                updateTimerDisplay();
                updateSessionDisplay();
            }
            startTimer();
        } else {
            pauseTimer();
        }
    });

    // If user edits the cycles input manually, reflect it immediately in UI and state
    cycleCountInput.addEventListener('input', () => {
        const v = parseInt(cycleCountInput.value);
        if (!isNaN(v) && v > 0) {
            totalCycles = v;
            updateSessionDisplay();
            // persist per-task if a task is currently selected
            if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
        }
    });

    pomodoroSkipBtn.addEventListener('click', () => {
    // Debug: trace skip click
    console.log('DEBUG: Skip clicked - currentMode:', currentMode, 'timerState:', timerState, 'currentRunningTaskId:', currentRunningTaskId);

    // Clear running intervals to prepare for mode switch
    clearInterval(timerInterval);
    clearInterval(progressUpdateInterval);

        // Safe defaults
        const DEFAULT_FOCUS_MIN = 25;
        const DEFAULT_BREAK_MIN = 5;

        if (currentMode === 'focus') {
            // Leaving a focus session -> stop tracking and go to break
            stopFocusTimer();
            console.log('DEBUG: switching from focus to break');
            currentMode = 'break';
            let breakDuration = parseInt(breakDurationInput.value);
            if (isNaN(breakDuration) || breakDuration <= 0) {
                breakDuration = DEFAULT_BREAK_MIN;
            }
            timeRemaining = breakDuration * 60;
            console.log('DEBUG: breakDuration (mins):', breakDuration, 'timeRemaining (s):', timeRemaining);
            triggerFlashAnimation('green');
            // start timer in break mode
            startTimer();
        } else {
            // Leaving a break -> go to focus
            currentMode = 'focus';
            console.log('DEBUG: switching from break to focus');
            let focusDuration = parseInt(focusDurationInput.value);
            if (isNaN(focusDuration) || focusDuration <= 0) {
                focusDuration = DEFAULT_FOCUS_MIN;
            }
            // Cap the focus session by remaining planned seconds for the selected task
            if (currentRunningTaskId) {
                const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                if (rem && rem.remaining !== undefined && rem.remaining > 0 && rem.remaining < (focusDuration * 60)) {
                    timeRemaining = rem.remaining;
                } else {
                    timeRemaining = focusDuration * 60;
                }
            } else {
                timeRemaining = focusDuration * 60;
            }
            // increment cycle since user is starting a new focus session
            currentCycle++;
            updateSessionDisplay();
            console.log('DEBUG: focusDuration (mins):', focusDuration, 'timeRemaining (s):', timeRemaining, 'currentCycle:', currentCycle);
            triggerFlashAnimation('red');
            startTimer();
        }
    });

    pomodoroResetBtn.addEventListener('click', () => {
    // Reset UI and subtract only the current session's increment from the task's progress
    resetPomodoroAndProgress(currentRunningTaskId);
    });

    pomodoroCloseButton.addEventListener('click', () => {
        hidePomodoroTimer();
    });

    function startTimer() {
    timerState = 'running';
        pomodoroStartPauseBtn.textContent = 'Pause';
    // user edits applied; clear the edit flags now that timer is running
    focusEdited = false;
    breakEdited = false;
        // Visually mark the currently running task in the list
        if (currentRunningTaskId) {
            const runningLi = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
            if (runningLi) runningLi.classList.add('active-task');
        }
    console.log('DEBUG: startTimer called - mode:', currentMode, 'timeRemaining:', timeRemaining, 'currentRunningTaskId:', currentRunningTaskId, 'progressUpdateInterval id:', progressUpdateInterval);

        document.querySelector('.pomodoro-inputs').style.display = 'none';

        if (currentMode === 'focus') {
            pomodoroSkipBtn.textContent = 'Skip to Break';
            pomodoroTimerWrapper.classList.remove('break-mode');
            pomodoroTimerWrapper.classList.add('focus-mode');
            startFocusTimer();
            // Notify user that focus started
            try { sendNotification('Focus started', 'Focus timer started', 'start'); } catch(e){}
            
            // Clear any existing interval before starting a new one
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }
            
            // Start progress bar update interval
            if (progressUpdateInterval) {
                console.log('DEBUG: clearing existing progressUpdateInterval before creating new one, id=', progressUpdateInterval);
                clearInterval(progressUpdateInterval);
            }
            progressUpdateInterval = setInterval(() => {
                if (currentRunningTaskId && timerState === 'running') {
                    updateProgressBar(currentRunningTaskId);
                }
            }, 1000);
            console.log('DEBUG: progressUpdateInterval set to', progressUpdateInterval);
        } else {
            pomodoroSkipBtn.textContent = 'Skip to Focus';
            pomodoroTimerWrapper.classList.remove('focus-mode');
            pomodoroTimerWrapper.classList.add('break-mode');
            // Notify user that break started
            try { sendNotification('Break started', 'Break timer started', 'break'); } catch(e){}
        }

        timerInterval = setInterval(() => {
            timeRemaining--;
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                timeRemaining = 0;
                updateTimerDisplay();
                handleSessionEnd();
            } else {
                updateTimerDisplay();
            }
        }, 1000);
    }

    function pauseTimer() {
    console.log('DEBUG: pauseTimer called - timeRemaining:', timeRemaining, 'currentMode:', currentMode, 'progressUpdateInterval id:', progressUpdateInterval);
    timerState = 'paused';
        clearInterval(timerInterval);
        if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            console.log('DEBUG: cleared progressUpdateInterval', progressUpdateInterval);
            progressUpdateInterval = null;
        }
        stopFocusTimer();
        // Remove visual highlight when paused
        if (currentRunningTaskId) {
            const runningLi = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
            if (runningLi) runningLi.classList.remove('active-task');
        }
        pomodoroStartPauseBtn.textContent = 'Resume';
    }

    function resetTimer() {
        clearInterval(timerInterval);
        stopFocusTimer();
        timerState = 'paused';
        const focusDuration = parseInt(focusDurationInput.value);
        if (!isNaN(focusDuration) && focusDuration > 0) {
            timeRemaining = focusDuration * 60;
        } else {
            timeRemaining = 25 * 60;
        }
        updateTimerDisplay();
        pomodoroStartPauseBtn.textContent = 'Start';
    }

    // Reset both Pomodoro UI and the task's persisted focused_time (server + UI)
    function resetPomodoroAndProgress(taskId) {
        // Reset UI timer
        resetTimer();
        // Only subtract the last session increment from the focused_time persisted for this task
        if (taskId) {
            const li = document.querySelector(`li[data-id='${taskId}']`);
            if (li) {
                const persisted = parseInt(li.dataset.focusedTime) || 0;
                const subtract = Math.max(0, lastSessionIncrement || 0);
                const newVal = Math.max(0, persisted - subtract);
                li.dataset.focusedTime = newVal;
                // update overdue_time/wasOverdue based on new focused value (server will compute normalization)
                updateFocusTimeOnServer(taskId, newVal);
                // remove only the live extra visual showing session-only overtime
                const extra = li.querySelector('.overdue-extra'); if (extra) extra.remove();
                // update progress bar to reflect new persisted focused time
                updateProgressBar(taskId);
            }
        }
    }

    function resetPomodoro() {
        clearInterval(timerInterval);
        clearInterval(progressUpdateInterval);
        timerState = 'paused';
        currentMode = 'focus';
        timeRemaining = null;
        currentCycle = 0;
        pomodoroTimerDisplay.textContent = '25:00';
        pomodoroStartPauseBtn.textContent = 'Start';
        pomodoroNotification.style.display = 'none';
        pomodoroSessionDisplay.textContent = '';
        pomodoroTimerWrapper.classList.remove('focus-mode', 'break-mode');
        document.querySelector('.pomodoro-inputs').style.display = 'flex';
        focusDurationInput.value = '';
        breakDurationInput.value = '';
    cycleCountInput.value = '';
    // Clear displayed task name and overdue hint
    pomodoroTask.innerHTML = '';
    const hint = document.getElementById('pomodoro-overdue-hint');
    if (hint) hint.style.display = 'none';
    }

    function hidePomodoroTimer() {
        if (timerState === 'running') {
            pauseTimer();
        }
        stopFocusTimer();
        resetPomodoro();
        pomodoroContainer.style.display = 'none';
        todoContainer.classList.remove('pomodoro-active');
        
        // Reset all state variables
    // remove highlight from any active task
    const runningLi = document.querySelector('li.active-task');
    if (runningLi) runningLi.classList.remove('active-task');
    currentRunningTaskId = null;
        lastFocusedTime = 0;
        focusSessionStartTime = 0;
        if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            console.log('DEBUG: hidePomodoroTimer cleared progressUpdateInterval', progressUpdateInterval);
            progressUpdateInterval = null;
        }
    }

    function updateTimerDisplay() {
        const displayTime = timeRemaining < 0 ? 0 : timeRemaining;
        const minutes = Math.floor(displayTime / 60);
        const seconds = displayTime % 60;
        pomodoroTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function updateSessionDisplay() {
        pomodoroSessionDisplay.textContent = `${currentCycle} / ${totalCycles}`;
    }

    // Helper: compute remaining planned seconds for a task from dataset (total - persistedFocused)
    function computeRemainingPlannedSeconds(taskId) {
        const li = document.querySelector(`li[data-id='${taskId}']`);
        if (!li) return null;
        const dh = parseInt(li.dataset.durationHours) || 0;
        const dm = parseInt(li.dataset.durationMinutes) || 0;
        const total = (dh * 3600) + (dm * 60);
        const persisted = parseInt(li.dataset.focusedTime) || 0;
        const remaining = Math.max(0, total - persisted);
        return { total, persisted, remaining };
    }

    function handleSessionEnd() {
        stopFocusTimer();

        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (!li) {
            resetPomodoro(); // or handle error appropriately
            return;
        }

        if (currentMode === 'focus') {
            if (currentCycle >= totalCycles) {
                try { sendNotification('All cycles completed', 'You finished all cycles', 'complete'); } catch(e){}
                const taskName = pomodoroTask.textContent || '';
                showCompletionPrompt(currentRunningTaskId, taskName || 'Task', 'All focus sessions completed');
            } else {
                const breakDuration = parseInt(breakDurationInput.value);
                if (!isNaN(breakDuration) && breakDuration > 0) {
                    currentMode = 'break';
                    timeRemaining = breakDuration * 60;
                    startTimer();
                } else {
                    resetPomodoro();
                }
            }
        } else { // currentMode is 'break'
            currentMode = 'focus';
            currentCycle++;
            updateSessionDisplay();
            const focusDuration = parseInt(focusDurationInput.value);
            if (!isNaN(focusDuration) && focusDuration > 0) {
                timeRemaining = focusDuration * 60;
                showNotification('Break ended! Time to focus.', 'Start Focus');
                try { sendNotification('Break ended', 'Time to focus', 'start'); } catch(e){}
                startTimer();
            } else {
                resetPomodoro();
            }
        }
    }

    // Show completion modal when all cycles finish
    function showCompletionPrompt(todoId, taskName, subtitle) {
        const modal = document.getElementById('global-overdue-modal');
        const messageEl = document.getElementById('global-overdue-message');
        // Reuse modal layout but change buttons and text
        messageEl.innerHTML = `
            <div class="modal-message-main"><span class="modal-task-name">${taskName}</span></div>
            <div style="margin-top:8px; font-size:0.95em;">${subtitle}</div>
        `;
        modal.style.display = 'flex';
        // Hide the Pomodoro UI while showing the completion modal without resetting internal state
        try {
            if (pomodoroContainer) pomodoroContainer.style.display = 'none';
            if (todoContainer) todoContainer.classList.remove('pomodoro-active');
        } catch (e) {
            console.log('DEBUG: showCompletionPrompt hide UI failed', e);
        }
        const markBtn = document.getElementById('modal-mark-complete');
        const contBtn = document.getElementById('modal-continue');
        // Rename buttons: primary -> Close/OK, secondary -> Dismiss
        markBtn.style.display = 'none';
        contBtn.textContent = 'Dismiss';
        // Unbind handlers by cloning
        const contClone = contBtn.cloneNode(true);
        contBtn.parentNode.replaceChild(contClone, contBtn);
        const dismiss = document.getElementById('modal-continue');
        dismiss.addEventListener('click', () => { modal.style.display = 'none'; });
    }

    function showNotification(message, buttonText) {
        pomodoroNotification.textContent = message;
        const nextSessionBtn = document.createElement('button');
        nextSessionBtn.textContent = buttonText;
        nextSessionBtn.addEventListener('click', () => {
            pomodoroNotification.style.display = 'none';
            if (buttonText === 'Reset Pomodoro') {
                resetPomodoro();
            } else {
                startTimer();
            }
        });
        pomodoroNotification.appendChild(nextSessionBtn);
        pomodoroNotification.style.display = 'block';
    }

    function triggerFlashAnimation(color) {
        // Query fresh elements each time to avoid working with detached nodes
        const flashes = document.querySelectorAll('.border-flash');
        console.log('DEBUG: triggerFlashAnimation - color:', color, 'borderFlashes count:', flashes.length);
        flashes.forEach(flash => {
            // Remove any running animation classes
            flash.classList.remove('green-flash-active', 'red-flash-active');
            // Force reflow to restart animation
            // eslint-disable-next-line no-unused-expressions
            void flash.offsetWidth;
            // Add desired animation class
            flash.classList.add(`${color}-flash-active`);
            // Clean up after animation ends
            flash.addEventListener('animationend', function handler() {
                flash.classList.remove('green-flash-active', 'red-flash-active');
                flash.removeEventListener('animationend', handler);
            });
        });
    }

    function addTodoItemToDOM(id, text, completed, durationHours, durationMinutes, focusedTime, wasOverdue, overdueTime) {
    const li = document.createElement('li');
        li.dataset.id = id;
        li.dataset.durationHours = durationHours;
        li.dataset.durationMinutes = durationMinutes;
        li.dataset.focusedTime = focusedTime;
        li.dataset.overdueTime = overdueTime || 0;
        // store persisted overdue flag
        li.dataset.wasOverdue = wasOverdue || 0;

    // Create a left column wrapper that holds the title and any small metadata lines (like overdue text)
    const taskLeft = document.createElement('div');
    taskLeft.classList.add('task-left');

    const span = document.createElement('span');
    span.textContent = text;
    taskLeft.appendChild(span);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('actions');

        const durationStr = [];
        if (durationHours && durationHours > 0) {
            durationStr.push(`${durationHours}h`);
        }
        if (durationMinutes && durationMinutes > 0) {
            durationStr.push(`${durationMinutes}m`);
        }

        if (durationStr.length > 0) {
            const durationSpan = document.createElement('span');
            durationSpan.classList.add('duration');
            durationSpan.textContent = durationStr.join(' ');
            actionsDiv.appendChild(durationSpan);
        }

        const playButton = document.createElement('button');
        playButton.classList.add('play-button');
        playButton.innerHTML = '<i class="fas fa-play"></i>';

        const doneButton = document.createElement('button');
        doneButton.classList.add('done-button');
        doneButton.innerHTML = completed ? '<i class="fas fa-undo"></i>' : '<i class="fas fa-check"></i>';

        const deleteButton = document.createElement('button');
        deleteButton.classList.add('delete-button');
        deleteButton.innerHTML = '<i class="fas fa-trash"></i>';

        actionsDiv.appendChild(playButton);
        actionsDiv.appendChild(doneButton);
        actionsDiv.appendChild(deleteButton);

    // append the left column first, then the actions (which stays aligned right by flex)
    li.appendChild(taskLeft);
    li.appendChild(actionsDiv);

        const progressBarContainer = document.createElement('div');
        progressBarContainer.classList.add('progress-bar-container');
        const progressBar = document.createElement('div');
        progressBar.classList.add('progress-bar');
        progressBarContainer.appendChild(progressBar);
        li.appendChild(progressBarContainer);

            if (completed) {
                // make sure any live extra overdue visuals are removed before showing completed layout
                const extra = li.querySelector('.overdue-extra'); if (extra) extra.remove();
                li.classList.add('completed');
                // Prepend completed items so newest-completed appear at the top
                if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                else completedList.appendChild(li);
                // If this completed task had overdue time persisted, show the small overdue indicator under the title
                if (parseInt(li.dataset.overdueTime) > 0 || parseInt(li.dataset.wasOverdue) === 1) {
                    ensureCompletedOverdueIndicator(li);
                } else {
                    ensureCompletedStatusIndicator(li);
                }
            } else {
                todoList.appendChild(li);
            }

        updateProgressBar(id);
    }

    function updateProgressBar(todoId) {
        const li = document.querySelector(`li[data-id='${todoId}']`);
        if (!li) return;

        const durationHours = parseInt(li.dataset.durationHours) || 0;
        const durationMinutes = parseInt(li.dataset.durationMinutes) || 0;
        const totalDurationInSeconds = (durationHours * 3600) + (durationMinutes * 60);
        
        // Base focused time comes from the stored dataset for this task
        const persistedFocused = parseInt(li.dataset.focusedTime) || 0;
        let currentFocusedTime = persistedFocused;
        // If this task is currently being focused, add the ongoing session time
        let currentSessionTime = 0;
        if (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running') {
            currentSessionTime = Math.floor((Date.now() - focusSessionStartTime) / 1000);
            currentFocusedTime += currentSessionTime;
        }

        // debug snapshot for tracing
        console.log('DEBUG: updateProgressBar snapshot', { todoId, persistedFocused, currentSessionTime, currentFocusedTime, timerState, currentMode, focusSessionStartTime });

    const progressBar = li.querySelector('.progress-bar');
    const progressContainer = li.querySelector('.progress-bar-container');
        if (totalDurationInSeconds > 0) {
            const progress = Math.min((currentFocusedTime / totalDurationInSeconds) * 100, 100);
            progressBar.style.width = `${progress}%`;
            // Mark the task as overdue (red card) when fully completed but not toggled as done
            const previousFocused = parseInt(li.dataset.focusedTime) || 0;
            const crossed = (previousFocused < totalDurationInSeconds) && (currentFocusedTime >= totalDurationInSeconds);
            if (currentFocusedTime >= totalDurationInSeconds && !li.classList.contains('completed')) {
                li.classList.add('overdue');
            } else {
                li.classList.remove('overdue');
            }

            // If progress reached 100% while actively running, immediately pause/stop timers and show modal once.
            // If progress is 100% due to persisted focused time (not actively running) then just mark as crossed
            // and let the global checker handle showing the modal (it skips items under processing).
            if (currentFocusedTime >= totalDurationInSeconds && !li.dataset.overdueNotified && !li.classList.contains('completed')) {
                const isActiveRunning = (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus');
                if (isActiveRunning) {
                    // actively crossed while running  handle immediately
                    console.log('DEBUG: updateProgressBar detected active running crossing for', todoId);
                        triggerOverdueForTaskLocal(todoId, totalDurationInSeconds);
                } else if (crossed) {
                    // Persisted crossing occurred; mark crossed and let global checker decide when to show modal
                    try { li.dataset.overdueCrossed = 1; } catch (e) {}
                    console.log('DEBUG: updateProgressBar marked overdueCrossed for', todoId);
                }
            }
        } else {
            progressBar.style.width = '0%';
        }
        // Show extra overdue time (time worked after planned duration)
    // Show overdue extra only for time actually spent in Pomodoro focus sessions plus any persisted overdue_time
    const persistedOverdue = parseInt(li.dataset.overdueTime) || 0;
    const baseline = parseInt(li.dataset.overdueBaseline) || totalDurationInSeconds;
    let sessionOverdue = 0;
    // Only count session overdue when this task is actively being focused via Pomodoro
    if (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus') {
        const currentSessionTime = Math.floor((Date.now() - focusSessionStartTime) / 1000);
        const persistedFocused = parseInt(li.dataset.focusedTime) || 0;
        const totalFocusedNow = persistedFocused + currentSessionTime;
        // sessionOverdue should represent ONLY the portion of overtime accumulated in THIS active session
        // i.e. totalFocusedNow - baseline minus any persisted overdue already recorded on the server
        const alreadyPersistedOverdue = persistedOverdue;
        if (totalFocusedNow > baseline) {
            sessionOverdue = Math.max(0, (totalFocusedNow - baseline) - alreadyPersistedOverdue);
        }
    }

    // triggerOverdueForTask is implemented in module scope (moved out) so callers outside updateProgressBar can access it.

    const extraSeconds = persistedOverdue + sessionOverdue;
    let extraEl = li.querySelector('.overdue-extra');
    // Ensure a single persistent element per li to avoid DOM thrash when multiple timers call update
    if (!extraEl) {
        extraEl = document.createElement('div');
        extraEl.classList.add('overdue-extra');
        extraEl.style.display = 'none';
        if (progressContainer) progressContainer.parentNode.insertBefore(extraEl, progressContainer.nextSibling);
        else li.appendChild(extraEl);
    }

    // cancel any pending hide timer
    if (li._overdueHideTimer) {
        clearTimeout(li._overdueHideTimer);
        li._overdueHideTimer = null;
    }

    console.log('DEBUG: overdue calc for', todoId, 'persistedOverdue:', persistedOverdue, 'sessionOverdue:', sessionOverdue, 'extraSeconds:', extraSeconds);
    if (extraSeconds > 0 && !li.classList.contains('completed')) {
        extraEl.textContent = `Overdue time: ${formatDuration(extraSeconds)}`;
        extraEl.style.display = 'block';
    } else {
        // debounce hiding to avoid flicker when updateProgressBar is called rapidly from multiple intervals
        li._overdueHideTimer = setTimeout(() => {
            if (extraEl) extraEl.style.display = 'none';
            li._overdueHideTimer = null;
        }, 700);
    }
    }

    function formatDuration(seconds) {
        seconds = Math.floor(seconds);
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        if (hrs > 0) {
            if (mins > 0) return `${hrs}h ${mins}m`;
            return `${hrs}h`;
        }
        if (mins > 0) {
            if (secs > 0) return `${mins}m ${secs}s`;
            return `${mins}m`;
        }
        return `${secs}s`;
    }

    function showOverduePrompt(message) {
        try { sendNotification('Task Overdue', 'Your task is now overdue. Mark complete or continue?', 'complete'); } catch(e){}
        // message param may be overloaded; handle signature showOverduePrompt(todoId, message)
        let todoId = null;
        let text = message;
        if (typeof message === 'string' && arguments.length === 2) {
            // called as showOverduePrompt(todoId, message)
        }
        if (arguments.length === 2) {
            todoId = arguments[0];
            text = arguments[1];
        }
        // We'll use the global modal so prompt appears regardless of Pomodoro visibility
        const modal = document.getElementById('global-overdue-modal');
        const messageEl = document.getElementById('global-overdue-message');

        // small helper to escape HTML when injecting task names
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }
        const markBtn = document.getElementById('modal-mark-complete');
        const contBtn = document.getElementById('modal-continue');

        // Build a clearer message that shows the task name highlighted and a second line with the action
        let taskName = '';
        if (todoId) {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li) taskName = li.querySelector('span') ? li.querySelector('span').textContent : '';
        }

        // Only show the modal once per task reaching overdue: use localStorage key 'overdueModalShown:<id>'
        const storageKey = todoId ? `overdueModalShown:${todoId}` : null;
        if (storageKey && localStorage.getItem(storageKey)) {
            // Already shown before for this task  don't show again
            return;
        }

        // Use a structured message regardless of the `text` param for clarity
        messageEl.innerHTML = `
            <div class="modal-message-main"><span class="modal-task-name">${escapeHtml(taskName)}</span> planned time is completed</div>
            <div style="margin-top:8px; font-size:0.95em;">Mark complete OR continue working on overdue task?</div>
        `;
        modal.style.display = 'flex';
    console.log('DEBUG: showOverduePrompt opened modal for', todoId, 'taskName:', taskName);
        // Unbind previous handlers by cloning
        const markClone = markBtn.cloneNode(true);
        markBtn.parentNode.replaceChild(markClone, markBtn);
        const contClone = contBtn.cloneNode(true);
        contBtn.parentNode.replaceChild(contClone, contBtn);

        // Re-acquire refs
        const mark = document.getElementById('modal-mark-complete');
        const cont = document.getElementById('modal-continue');

    mark.addEventListener('click', () => {
            modal.style.display = 'none';
            if (!todoId) return;
            // mark modal as shown for this task so it won't reappear on refresh or restore
            try { if (todoId) localStorage.setItem(`overdueModalShown:${todoId}`, '1'); } catch(e) {}
            fetch('/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: todoId }),
            })
                        .then(res => res.json())
                    .then(data => {
                        const li = document.querySelector(`li[data-id='${todoId}']`);
                        if (li) {
                            const doneIcon = li.querySelector('.done-button i');
                            // remove any overdue visual styling from completed tasks
                            li.classList.remove('overdue');
                            li.classList.add('completed');
                            if (doneIcon) { doneIcon.classList.remove('fa-check'); doneIcon.classList.add('fa-undo'); }
                            // Prepend so most-recent completed task appears at top
                            if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                            else completedList.appendChild(li);
                            try { sendNotification('Task completed', `${taskName}  marked complete`, 'complete'); } catch(e){}
                            const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdue && parseInt(wasOverdue) === 1) {
                                addOverdueBadge(li);
                                // Move any displayed overdue-extra (live overdue time) to the completed-overdue-text
                                // so it appears on a new line under the title immediately.
                                const extra = li.querySelector('.overdue-extra');
                                if (extra) {
                                    // create/replace completed-overdue-text with the same content but insert inside .task-left
                                    const prev = li.querySelector('.completed-overdue-text');
                                    if (prev) prev.remove();
                                    const text = document.createElement('div');
                                    text.classList.add('completed-overdue-text');
                                    text.textContent = extra.textContent.replace('Overdue time:', 'Overdue:');
                                    text.style.marginTop = '6px';
                                    text.style.color = 'rgba(255,82,82,0.95)';
                                    // ensure .task-left exists and insert after the title span
                                    let container = li.querySelector('.task-left');
                                    if (!container) {
                                        const currentSpan = li.querySelector('span');
                                        if (currentSpan) {
                                            const wrapper = document.createElement('div');
                                            wrapper.classList.add('task-left');
                                            wrapper.appendChild(currentSpan.cloneNode(true));
                                            currentSpan.remove();
                                            li.insertBefore(wrapper, li.firstChild);
                                            container = wrapper;
                                        }
                                    }
                                    if (container) {
                                        const titleSpan = container.querySelector('span');
                                        if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                                        else container.appendChild(text);
                                    } else {
                                        li.appendChild(text);
                                    }
                                    // remove live extra to avoid duplication
                                    extra.remove();
                                } else {
                                    ensureCompletedOverdueIndicator(li);
                                }
                            }
                            // clear the notified flag, baseline and any continue flag
                            if (li.dataset.overdueNotified) delete li.dataset.overdueNotified;
                            if (li.dataset.overdueBaseline) delete li.dataset.overdueBaseline;
                            if (li.dataset.overdueInContinue) delete li.dataset.overdueInContinue;
                            hidePomodoroTimer();
                        }
                    });
        });

        cont.addEventListener('click', () => {
            modal.style.display = 'none';
            // mark modal as shown so it won't reappear on refresh
            try { if (todoId) localStorage.setItem(`overdueModalShown:${todoId}`, '1'); } catch(e) {}
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li && !li.dataset.overdueBaseline) {
                const dh = parseInt(li.dataset.durationHours) || 0;
                const dm = parseInt(li.dataset.durationMinutes) || 0;
                li.dataset.overdueBaseline = (dh * 3600) + (dm * 60);
            }
            // mark that the user chose to continue working if they later start a Pomodoro
            if (li) li.dataset.overdueInContinue = 1;
            // Do NOT start timers here. The actual focus session should begin only when the user
            // opens the Pomodoro and presses Start for this task (or presses the Play button on the task).
            // Leaving timers stopped avoids the overdue counter incrementing before the user actively starts.
        });
    }

    function addOverdueBadge(li) {
        if (!li) return;
        // ensure no duplicate badge
        let badge = li.querySelector('.overdue-badge');
        if (!badge) {
            const span = li.querySelector('span');
            badge = document.createElement('span');
            badge.classList.add('overdue-badge');
            badge.textContent = '';
            badge.title = 'This task was completed overdue';
            span.appendChild(badge);
        }
    }

    // For completed tasks, add a subtle overdue indicator (text) beneath the task name
    function ensureCompletedOverdueIndicator(li) {
        if (!li) return;
        // remove any overdue class that may add a red border
        li.classList.remove('overdue');
        // remove previous indicator to avoid duplicates
        const prev = li.querySelector('.completed-overdue-text');
        if (prev) prev.remove();
        // Remove any live session-only overtime element
        const liveExtra = li.querySelector('.overdue-extra'); if (liveExtra) liveExtra.remove();

        const overdueSeconds = parseInt(li.dataset.overdueTime) || 0;
        if (overdueSeconds > 0) {
            const text = document.createElement('div');
            text.classList.add('completed-overdue-text');
            text.textContent = `Overdue: ${formatDuration(overdueSeconds)}`;
            text.style.marginTop = '6px';
            text.style.color = 'rgba(255,82,82,0.95)';
            // Prefer to insert inside the .task-left wrapper immediately after the title span
            let container = li.querySelector('.task-left');
            if (!container) {
                // migrate existing single span into a .task-left wrapper
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                // remove any old completed-overdue-text inside container to avoid ordering issues
                const prevInside = container.querySelector('.completed-overdue-text'); if (prevInside) prevInside.remove();
                // insert after the title span
                const titleSpan = container.querySelector('span');
                if (titleSpan) {
                    titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                } else {
                    container.appendChild(text);
                }
            } else {
                // fallback: append to li so it appears on its own line
                li.appendChild(text);
            }
        }
    }

    // --- Browser notifications + sound helpers ---
    function playSound(soundType) {
        let soundFile = '';
        if (soundType === 'break') {
            soundFile = '/static/sounds/Break timer start.wav';
        } else if (soundType === 'start') {
            soundFile = '/static/sounds/Focus timer start.wav';
        } else if (soundType === 'complete') {
            soundFile = '/static/sounds/progress bar full.wav';
        }

        if (soundFile) {
            const audio = new Audio(soundFile);
            audio.play().catch(e => console.log('Audio play failed', e));
        }
    }

    function ensureNotificationPermission() {
        if (!('Notification' in window)) return Promise.resolve(false);
        if (Notification.permission === 'granted') return Promise.resolve(true);
        if (Notification.permission === 'denied') return Promise.resolve(false);
        return Notification.requestPermission().then(p => p === 'granted');
    }

    function sendNotification(title, body, soundType) {
        ensureNotificationPermission().then(ok => {
            if (!ok) return;
            try {
                const n = new Notification(title, { body });
                // play a short sound for the notification
                try { playSound(soundType); } catch(e) { console.log('playSound failed', e); }
                // close after a few seconds
                setTimeout(() => { try { n.close(); } catch(e) {} }, 5000);
            } catch (e) {
                console.log('Notification failed', e);
            }
        });
    }

    // For completed tasks, add a label below title:
    // - If task was marked completed BEFORE reaching full planned progress => 'Underdue task' (yellow)
    // - If task reached planned progress (no overdue) => 'Completed task' (green)
    function ensureCompletedStatusIndicator(li) {
        if (!li) return;
        // remove any previous status indicators
        const prevOverdue = li.querySelector('.completed-overdue-text'); if (prevOverdue) prevOverdue.remove();
        const prevUnderdue = li.querySelector('.completed-underdue-text'); if (prevUnderdue) prevUnderdue.remove();
        const prevComplete = li.querySelector('.completed-complete-text'); if (prevComplete) prevComplete.remove();

        // compute whether task was completed before planned duration or after
        const focused = parseInt(li.dataset.focusedTime) || 0;
        const overdue = parseInt(li.dataset.overdueTime) || 0;
        const dh = parseInt(li.dataset.durationHours) || 0;
        const dm = parseInt(li.dataset.durationMinutes) || 0;
        const total = (dh * 3600) + (dm * 60);

        // If there is overdue time, show overdue indicator (handled by ensureCompletedOverdueIndicator)
        if (overdue > 0) {
            ensureCompletedOverdueIndicator(li);
            return;
        }

        // If no planned duration, do nothing
        if (total <= 0) return;

        // If focusedTime < total when marked complete => underdue
        if (focused < total) {
            const text = document.createElement('div');
            text.classList.add('completed-underdue-text');
            text.textContent = 'Underdue task';
            // Prefer inserting inside .task-left under the title span
            let container = li.querySelector('.task-left');
            if (!container) {
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                // insert after the title span inside the wrapper
                const titleSpan = container.querySelector('span');
                if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                else container.appendChild(text);
            } else {
                li.appendChild(text);
            }
            return;
        }

        // If reached planned duration and no overdue => Completed task
        if (focused >= total && overdue === 0) {
            const text = document.createElement('div');
            text.classList.add('completed-complete-text');
            text.textContent = 'Completed task';
            let container = li.querySelector('.task-left');
            if (!container) {
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                const titleSpan = container.querySelector('span');
                if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                else container.appendChild(text);
            } else {
                li.appendChild(text);
            }
            return;
        }
    }

    function startFocusTimer() {
        focusSessionStartTime = Date.now();
        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (li) {
            lastFocusedTime = parseInt(li.dataset.focusedTime) || 0;
            // clear any transient crossed flag when user actively starts a session
            try { if (li.dataset.overdueCrossed) { delete li.dataset.overdueCrossed; console.log('DEBUG: startFocusTimer cleared overdueCrossed for', currentRunningTaskId); } } catch (e) {}
            console.log('DEBUG: startFocusTimer - task', currentRunningTaskId, 'lastFocusedTime(dataset):', li.dataset.focusedTime, 'lastFocusedTime(var):', lastFocusedTime, 'focusSessionStartTime:', focusSessionStartTime);
        }
    }

    function stopFocusTimer() {
        if (focusSessionStartTime === 0) return;

        const elapsedSeconds = Math.floor((Date.now() - focusSessionStartTime) / 1000);
        focusSessionStartTime = 0; // Reset start time BEFORE calculating new focused time
        lastSessionIncrement = elapsedSeconds;
        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (li) {
            try { li.dataset.processing = 1; console.log('DEBUG: stopFocusTimer set processing for', li.dataset.id); } catch (e) { /* ignore */ }
            const newFocusedTime = lastFocusedTime + elapsedSeconds;
            const CLAMP_MAX = 24 * 3600; // 1 day
            const clampedFocusedTime = Math.min(newFocusedTime, CLAMP_MAX);
            console.log('DEBUG: stopFocusTimer - elapsedSeconds:', elapsedSeconds, 'newFocusedTime:', newFocusedTime, 'clamped:', clampedFocusedTime);
            li.dataset.focusedTime = clampedFocusedTime;
            updateFocusTimeOnServer(currentRunningTaskId, clampedFocusedTime);
            lastFocusedTime = newFocusedTime;
            updateProgressBar(currentRunningTaskId);
        }
    }

    function updateFocusTimeOnServer(todoId, focusedTime) {
        fetch('/update_focus_time', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: todoId, focused_time: focusedTime }),
        })
        .then(resp => resp.json())
        .then(data => {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li && typeof data.was_overdue !== 'undefined') {
                li.dataset.wasOverdue = data.was_overdue;
                if (data.was_overdue == 1 && !li.classList.contains('completed')) {
                    li.classList.add('overdue');
                }
                // Always ensure overdueTime is set (default 0)
                const reportedOverdue = parseInt(data.overdue_time) || 0;
                li.dataset.overdueTime = reportedOverdue;
                // if the server reports an overdue_time, set baseline so UI shows extra as only post-baseline
                const durationSeconds = (parseInt(li.dataset.durationHours) || 0) * 3600 + (parseInt(li.dataset.durationMinutes) || 0) * 60;
                if (reportedOverdue > 0) {
                    li.dataset.overdueBaseline = durationSeconds; // baseline is planned duration
                }
                // Sync normalized focused_time sent back by server
                if (typeof data.focused_time !== 'undefined') {
                    const norm = parseInt(data.focused_time) || 0;
                    li.dataset.focusedTime = norm;
                    // also update lastFocusedTime so subsequent session adds are correct
                    lastFocusedTime = norm;
                }
                // clear any temporary processing flag now that server responded
                try { delete li.dataset.processing; console.log('DEBUG: updateFocusTimeOnServer cleared processing for', todoId); } catch (e) {}
            }
        });
        // Fallback: clear processing after 1.5s in case server is slow or network fails
        setTimeout(() => {
            try { const li = document.querySelector(`li[data-id='${todoId}']`); if (li && li.dataset && li.dataset.processing) { delete li.dataset.processing; console.log('DEBUG: updateFocusTimeOnServer fallback cleared processing for', todoId); } } catch (e) {}
        }, 1500);
    }

        // Centralized handler to pause/stop timers and show the overdue prompt for a task.
        // Placed in module scope so it is callable from the global checker and other places.
        function triggerOverdueForTaskLocal(todoId, baselineSeconds) {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (!li) return;
            if (li.dataset.overdueNotified) return;
            // mark processing so global checker skips this item while we handle overdue
            try { li.dataset.processing = 1; console.log('DEBUG: triggerOverdueForTask set processing for', todoId); } catch (e) { /* ignore */ }
            li.dataset.overdueNotified = 1;
            if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = baselineSeconds || (parseInt(li.dataset.durationHours || 0) * 3600) + (parseInt(li.dataset.durationMinutes || 0) * 60);
            console.log('DEBUG: triggerOverdueForTask - pausing timers and showing modal for', todoId);
            try {
                // Pause UI timers and clear intervals
                pauseTimer();
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask pauseTimer failed', e);
            }
            try {
                // Ensure any active focus session is stopped and persisted
                stopFocusTimer();
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask stopFocusTimer failed', e);
            }
            // Also hide the Pomodoro UI without resetting internal pomodoro state
            try {
                if (pomodoroContainer) pomodoroContainer.style.display = 'none';
                if (todoContainer) todoContainer.classList.remove('pomodoro-active');
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask hide UI failed', e);
            }
            // ensure processing flag is cleared after a short grace period in case server doesn't respond
            setTimeout(() => {
                try { delete li.dataset.processing; console.log('DEBUG: triggerOverdueForTask cleared processing for', todoId); } catch (e) {}
            }, 800);
            // Decide whether to actually show the modal: require the rendered progress bar to be full
            try {
                const pb = li.querySelector('.progress-bar');
                let renderedPct = 0;
                if (pb && pb.style && pb.style.width && pb.style.width.endsWith('%')) {
                    renderedPct = parseFloat(pb.style.width.replace('%','')) || 0;
                } else {
                    const dh = parseInt(li.dataset.durationHours) || 0;
                    const dm = parseInt(li.dataset.durationMinutes) || 0;
                    const total = (dh * 3600) + (dm * 60);
                    const ft = parseInt(li.dataset.focusedTime) || 0;
                    renderedPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                }
                const isActiveRunning = (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus');
                console.log('DEBUG: triggerOverdueForTask renderedPct for', todoId, renderedPct, 'isActiveRunning:', isActiveRunning);
                if (renderedPct < 100 && !isActiveRunning) {
                    // Not visually full yet  mark crossed and defer showing modal to global checker once UI stabilizes
                    try { li.dataset.overdueCrossed = 1; } catch (e) {}
                    // clear processing flag we set earlier since we're not showing modal now
                    try { delete li.dataset.processing; } catch (e) {}
                    console.log('DEBUG: triggerOverdueForTask deferred modal for', todoId, 'renderedPct:', renderedPct);
                } else {
                    // Finally show modal to let the user choose
                    showOverduePrompt(todoId, 'Planned time reached  mark complete or continue working on overdue task?');
                }
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask modal decision error', e);
                showOverduePrompt(todoId, 'Planned time reached  mark complete or continue working on overdue task?');
            }
        }

    // Initial progress bar update and restore overdue state from dataset
    // Ensure completed-list shows newest-first by sorting existing items by data-id descending
    const completedItemsInitial = Array.from(document.querySelectorAll('#completed-list li'));
    if (completedItemsInitial.length > 1) {
        completedItemsInitial.sort((a, b) => parseInt(b.dataset.id) - parseInt(a.dataset.id));
        const completedListEl = document.getElementById('completed-list');
        completedItemsInitial.forEach(item => completedListEl.appendChild(item));
    }

    // Note: callers use triggerOverdueForTaskLocal directly.

    document.querySelectorAll('#todo-list li, #completed-list li').forEach(li => {
        // set overdue class from data-was-overdue (templates render this attribute)
        const wasOverdue = li.dataset.wasOverdue || li.dataset.was_overdue || li.getAttribute('data-was-overdue');
        if (wasOverdue && parseInt(wasOverdue) === 1 && !li.classList.contains('completed')) {
            li.classList.add('overdue');
        }
        // For completed tasks, ensure overdue text is placed under title (no red border)
        if (li.classList.contains('completed')) {
            // ensure left column wrapper exists  migrate simple span into task-left if needed
            const currentSpan = li.querySelector('span');
            if (currentSpan && !li.querySelector('.task-left')) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('task-left');
                wrapper.appendChild(currentSpan.cloneNode(true));
                // replace original span with wrapper
                currentSpan.remove();
                li.insertBefore(wrapper, li.firstChild);
            }
            // Show the appropriate completed label (overdue / underdue / completed)
            if (parseInt(li.dataset.overdueTime) > 0 || parseInt(li.dataset.wasOverdue) === 1) {
                ensureCompletedOverdueIndicator(li);
            } else {
                ensureCompletedStatusIndicator(li);
            }
        }
        updateProgressBar(li.dataset.id);
    });

    // Start a global progress checker so overdue modal appears even if user didn't press play
    if (!globalProgressCheckerInterval) {
        globalProgressCheckerInterval = setInterval(() => {
            document.querySelectorAll('#todo-list li').forEach(li => {
                // If this li is in processing state (just persisted by client/server sync), skip to avoid race
                if (li.dataset.processing) {
                    // short debug trace
                    console.log('DEBUG: global checker skipping processing li', li.dataset.id);
                    return;
                }
                const id = li.dataset.id;
                try {
                    const ft = parseInt(li.dataset.focusedTime) || 0;
                    const dh = parseInt(li.dataset.durationHours) || 0;
                    const dm = parseInt(li.dataset.durationMinutes) || 0;
                    const total = (dh * 3600) + (dm * 60);
                    const pct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                    if (pct >= 90) console.log('DEBUG: global checker', id, 'focusedTime:', ft, 'total:', total, 'pct:', pct);

                    // Update UI progress
                    updateProgressBar(id);

                    // Use the actual rendered progress bar width when available to decide if UI is truly at 100%.
                    let progressPct = 0;
                    try {
                        const pb = li.querySelector('.progress-bar');
                        if (pb && pb.style && pb.style.width && pb.style.width.endsWith('%')) {
                            progressPct = parseFloat(pb.style.width.replace('%','')) || 0;
                        } else {
                            progressPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                        }
                    } catch (e) {
                        progressPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                    }

                    // Force show modal only when rendered progress is 100% AND:
                    // - server reports overdue (li.dataset.overdueTime > 0), OR
                    // - this is an active running focus session (we're over while running), OR
                    // - we previously marked it as crossed (deferred handling)
                    if (total > 0 && progressPct >= 100 && !li.classList.contains('completed') && !li.dataset.overdueNotified) {
                        const persistedOverdue = parseInt(li.dataset.overdueTime) || 0;
                        console.log('DEBUG: global checker found progressPct >= 100 for', id, 'pct:', progressPct, 'persistedOverdue:', persistedOverdue, 'processing:', !!li.dataset.processing);

                        // If there's no server-reported overdue and the task is not actively running,
                        // it's likely a small persisted overage or race; skip triggering until real activity.
                        const isActiveRunning = (currentRunningTaskId && currentRunningTaskId === id && timerState === 'running' && currentMode === 'focus');
                        const wasCrossed = !!li.dataset.overdueCrossed;

                        if (!isActiveRunning && persistedOverdue === 0 && !wasCrossed) {
                            console.log('DEBUG: global checker skipping trigger for', id, ' no server-overdue and not actively running');
                            // set baseline so future checks know the planned time
                            if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = total;
                            return;
                        }

                        console.log('DEBUG: global checker triggering overdue handler for', id, 'isActiveRunning:', isActiveRunning, 'wasCrossed:', wasCrossed);
                        if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = total;
                        // If active running, defer to trigger handler to pause and show modal
                        triggerOverdueForTaskLocal(id, total);
                    }
                } catch (e) {
                    console.log('DEBUG: error reading li dataset', e);
                }
            });
        }, 1000);
    }

    // Clear on unload
    window.addEventListener('beforeunload', () => {
        if (globalProgressCheckerInterval) clearInterval(globalProgressCheckerInterval);
    });

    // Wire completed list toggle
    const completedToggle = document.getElementById('completed-toggle');
    const completedListEl = document.getElementById('completed-list');
    if (completedToggle && completedListEl) {
        completedToggle.addEventListener('click', () => {
            const expanded = completedToggle.getAttribute('aria-expanded') === 'true';
            if (expanded) {
                completedListEl.style.display = 'none';
                completedToggle.setAttribute('aria-expanded', 'false');
            } else {
                completedListEl.style.display = 'block';
                completedToggle.setAttribute('aria-expanded', 'true');
            }
        });
    }

    // Clear All completed tasks handler
    const clearCompletedBtn = document.getElementById('clear-completed-button');
    if (clearCompletedBtn) {
        clearCompletedBtn.addEventListener('click', () => {
            const completedItems = Array.from(document.querySelectorAll('#completed-list li'));
            if (completedItems.length === 0) return;
            // Confirm destructive action
            if (!confirm(`Clear ${completedItems.length} completed task(s)? This cannot be undone.`)) return;

            // Optimistically remove from UI and issue delete requests
            completedItems.forEach(li => {
                const id = li.dataset.id;
                // Remove from DOM immediately for responsiveness
                li.remove();
                // Call server to delete
                fetch('/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id }),
                })
                .then(res => res.json())
                .then(data => {
                    if (!data || data.result !== 'success') {
                        console.log('DEBUG: failed to delete completed todo', id, data);
                        // On failure, we could refresh the page to reconcile, but keep simple for now
                    }
                })
                .catch(err => console.log('DEBUG: error deleting completed todo', id, err));
            });
        });
    }

    // Debug helpers: expose functions so user can force-check overdue and open modal from console
    window.forceCheckOverdue = function() {
        console.log('DEBUG: forceCheckOverdue called');
        document.querySelectorAll('#todo-list li').forEach(li => updateProgressBar(li.dataset.id));
    };

    window.showModalFor = function(id) {
        console.log('DEBUG: showModalFor', id);
        showOverduePrompt(id, 'Test: Planned time reached  mark complete or continue?');
    };

    // Test helper: reset a task's focused time to zero (client + server) for clean reproduction
    window.resetTaskProgress = function(id) {
        try {
            const li = document.querySelector(`li[data-id='${id}']`);
            if (li) {
                li.dataset.focusedTime = 0;
                li.dataset.overdueTime = 0;
                li.dataset.wasOverdue = 0;
                li.classList.remove('overdue');
                updateProgressBar(id);
            }
            // Also ask server to reset
            fetch('/update_focus_time', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: id, focused_time: 0 }) })
            .then(r => r.json()).then(() => { console.log('DEBUG: resetTaskProgress server responded for', id); }).catch(e => console.log('DEBUG: resetTaskProgress server error', e));
        } catch (e) { console.log('DEBUG: resetTaskProgress failed', e); }
    };
});
</file>

<file path="static/style.css">
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #1a1a1a 0%, #000000 100%);
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    color: #fff;
    font-size: 18px;
}

.main-container {
    display: flex;
    width: 100%;
    max-width: 800px; /* Default narrow width */
    transition: all 0.5s ease;
    margin: 0 auto; /* Centered */
    gap: 20px; /* Added gap for spacing between sections */
}

.main-container:has(.todo-container.pomodoro-active) {
    max-width: 1400px; /* Wider width when pomodoro is active */
}

.todo-container {
    background-color: rgba(255, 255, 255, 0.05);
    padding: 60px;
    padding-bottom: 80px; /* extra space so bottom-centered logout doesn't overlap content */
    border-radius: 15px;
    box-shadow: 0 8px 32px 0 rgba(255, 235, 59, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 235, 59, 0.18);
    width: 100%;
    transition: width 0.5s ease;
    min-height: 500px;
    position: relative; /* allow absolute positioning of logout button */
}

.todo-container.pomodoro-active {
    width: 50%;
}

.pomodoro-container {
    width: 50%;
    padding: 60px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    position: relative; /* Added for positioning close button */
    min-height: 500px;
    /* Removed margin-left: 20px; */
    /* Removed text-align: center; */
}

.pomodoro-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.pomodoro-controls > div {
    display: flex;
    justify-content: center;
}

h1, h2 {
    text-align: center;
    font-weight: 600;
    margin-bottom: 30px;
    font-size: 3em;
    color: #ffeb3b;
}

.input-container {
    display: flex;
    gap: 10px; /* Added gap for spacing */
    align-items: center; /* Vertically align items */
    margin-bottom: 30px;
    background: rgba(255, 235, 59, 0.03);
    padding: 8px;
    border-radius: 10px;
    border: 1px solid rgba(255,235,59,0.06);
}

#todo-input {
    flex: 1;
    min-width: 100px; /* Ensure it doesn't become too small */
    padding: 15px;
    border: none;
    border-radius: 8px;
    font-size: 18px;
    background-color: rgba(255, 255, 255, 0.1);
    color: #fff;
    outline: none;
}

#duration-hours, #duration-minutes {
    width: 60px; /* Adjusted width */
    padding: 15px;
    border: none;
    border-radius: 8px;
    font-size: 18px;
    background-color: rgba(255, 255, 255, 0.1);
    color: #fff;
    outline: none;
    /* Removed margin-left: 10px; */
    flex-shrink: 0; /* Prevent shrinking */
}

#todo-input::placeholder, #duration-hours::placeholder, #duration-minutes::placeholder {
    color: rgba(255, 255, 255, 0.7);
}

#add-button {
    background-color: #ffeb3b;
    color: #000;
    border: none;
    padding: 15px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    /* Removed margin-left: 10px; */
    transition: background-color 0.3s ease;
    font-weight: 600;
    flex-shrink: 0; /* Prevent shrinking */
}

#add-button:hover {
    background-color: #fdd835;
}

#todo-list, #completed-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

li {
    background-color: rgba(255, 255, 255, 0.05);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap; /* Allow items to wrap */
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s ease;
    word-break: break-word;
}

li:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 16px rgba(255, 235, 59, 0.1);
}

li span:first-child {
    flex-grow: 1;
}

li.completed span {
    color: rgba(255, 255, 255, 0.5);
    font-style: normal; /* show completed tasks in normal font */
}

/* Overdue task style: make the whole card red and more prominent */
li.overdue {
    background-color: rgba(231, 76, 60, 0.15);
    border: 1px solid rgba(231, 76, 60, 0.6);
}

li.overdue span {
    color: #ffebee;
}

.overdue-badge {
    display: inline-block;
    color: #fff;
    background: rgba(231,76,60,0.9);
    padding: 2px 6px;
    margin-left: 10px;
    border-radius: 4px;
    font-size: 0.8em;
}

/* Hide progress bar for completed tasks */
li.completed .progress-bar-container {
    display: none;
}

/* Overdue badge for completed tasks: use a red circle emoji */
.overdue-badge {
    background: transparent;
    padding: 0;
    margin-left: 8px;
    font-size: 1.2em;
}

/* Highlight currently running task in Pomodoro with a yellow border */
li.active-task {
    /* Keep a subtle glow for the whole card, but do not add a border to the card itself. */
    box-shadow: 0 6px 24px rgba(255, 235, 59, 0.12);
}

/* Only the title span inside the active task should receive the yellow border */
li.active-task span:first-child {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 6px;
    border: 2px solid rgba(255, 235, 59, 0.95);
    background: rgba(255, 235, 59, 0.04);
    margin-right: 8px;
}

.overdue-extra {
    font-size: 0.9em;
    color: rgba(255, 82, 82, 0.95);
    margin-top: 6px;
}

.actions {
    display: flex;
    align-items: center;
}

.duration {
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.7);
    margin-right: 15px;
}

.play-button, .done-button, .delete-button {
    background: none;
    border: none;
    color: #fff;
    cursor: pointer;
    font-size: 1.2em;
    margin-left: 10px;
    transition: color 0.3s ease;
}

li.completed .play-button {
    display: none;
}

.play-button:hover {
    color: #ffeb3b;
}

.done-button:hover {
    color: #2ecc71;
}

.delete-button:hover {
    color: #e74c3c;
}

.login-container, .user-info {
    text-align: center;
    margin-bottom: 20px;
}

.login-button, .logout-button {
    display: inline-block;
    background-color: #ffeb3b;
    color: #000;
    padding: 12px 25px;
    border-radius: 8px;
    text-decoration: none;
    font-size: 16px;
    transition: background-color 0.3s ease;
    font-weight: 600;
}

.login-button:hover, .logout-button:hover {
    background-color: #fdd835;
}

/* Keep logout button pinned to the bottom center of the todo card */
.todo-container .logout-button {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 18px;
    z-index: 2000;
}

.user-info p {
    margin-bottom: 15px;
    font-size: 1.1em;
}

.separator {
    border: none;
    height: 3px;
    background-color: #ffeb3b;
    margin: 30px 0;
    border-radius: 2px;
}

.completed-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

#completed-toggle {
    background: none;
    border: none;
    color: #fff;
    font-size: 1.1em;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
}

#clear-completed-button {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.08);
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
}

#clear-completed-button:hover {
    background: rgba(255,235,59,0.06);
    border-color: rgba(255,235,59,0.16);
}

.toggle-arrow {
    display: inline-block;
    transition: transform 0.2s ease;
}

#completed-toggle[aria-expanded="true"] .toggle-arrow {
    transform: rotate(90deg);
}

/* Modal for overdue prompt */
.global-modal {
    position: fixed;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.global-modal .modal-card {
    background: #111;
    padding: 20px 24px;
    border-radius: 10px;
    border: 1px solid rgba(255,235,59,0.12);
    max-width: 420px;
    width: 90%;
    color: #fff;
    text-align: center;
}

.global-modal .modal-card .modal-actions {
    margin-top: 12px;
    display: flex;
    gap: 10px;
    justify-content: center;
}

.global-modal .modal-card button {
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
}

.global-modal .modal-card .btn-primary { background: #ffeb3b; color: #000; }
.global-modal .modal-card .btn-secondary { background: rgba(255,255,255,0.08); color: #fff; }

/* Pomodoro Styles */
#pomodoro-task {
    font-size: 1.2em;
    font-weight: 600;
    margin-bottom: 20px;
    text-align: center;
}

/* Pomodoro task name in timer window - highlighted with yellow border */
#pomodoro-task .pomodoro-task-name {
    display: inline-block;
    padding: 6px 10px;
    border-radius: 6px;
    border: 2px solid rgba(255,235,59,0.95);
    background: rgba(255,235,59,0.03);
}

#pomodoro-task .pomodoro-overdue-emoji {
    margin-left: 8px;
    font-size: 1.05rem;
    vertical-align: middle;
}

    /* Pomodoro overdue hint: simplified  only show red text with emoji, no box */
    .pomodoro-overdue-hint {
    margin-top: 12px;
    padding: 6px 0;
    background: transparent;
    color: rgba(231,76,60,0.95);
    font-size: 1.05rem;
    text-align: center;
    }

#pomodoro-session-display {
    font-size: 1.4em;
    text-align: center;
    margin-bottom: 10px;
    color: rgba(255, 255, 255, 0.92);
    font-weight: 600;
    letter-spacing: 0.6px;
}

.pomodoro-inputs {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 20px;
    align-items: center;
}

.pomodoro-inputs input {
    width: 110px;
    padding: 12px;
    border: 1px solid rgba(255,235,59,0.08);
    border-radius: 10px;
    font-size: 15px;
    background-color: rgba(255, 255, 255, 0.04);
    color: #fff;
    outline: none;
    margin: 0 4px;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.35) inset;
}

.pomodoro-inputs input:focus {
    border-color: rgba(255,235,59,0.22);
    background-color: rgba(255,255,255,0.06);
}

.pomodoro-timer-wrapper {
    border: 3px solid transparent;
    border-radius: 15px;
    padding: 10px 10px; /* Added 10px horizontal padding */
    margin-bottom: 20px;
    transition: border-color 0.3s ease;
    display: flex; /* Changed from inline-block */
    justify-content: center; /* Center content horizontally */
    align-items: center; /* Center content vertically */
    max-width: fit-content; /* Shrink-wrap content */
    margin: 0 auto 20px auto; /* Center the wrapper itself */
}

.pomodoro-timer-wrapper.focus-mode {
    border-color: #e74c3c;
}

.pomodoro-timer-wrapper.break-mode {
    border-color: #2ecc71;
}

.pomodoro-timer {
    font-size: 5.2em;
    font-weight: 700;
    text-align: center;
    line-height: 0.95;
}

.pomodoro-controls button {
    background-color: #ffeb3b;
    color: #000;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    margin: 0 5px;
    transition: background-color 0.3s ease;
    font-weight: 600;
}

.pomodoro-controls button:hover {
    background-color: #fdd835;
}

.close-button {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    color: #fff;
    font-size: 2em;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close-button:hover {
    color: #ffeb3b;
}

#pomodoro-notification {
    text-align: center;
    margin-top: 20px;
    font-size: 1.1em;
}

/* Border Flash Animation */
.border-flash {
    position: fixed;
    background-color: transparent;
    z-index: 9999;
    pointer-events: none;
    opacity: 0;
}

.border-flash.top, .border-flash.bottom {
    left: 0;
    width: 100%;
    height: 5vh; /* Thicker */
}

.border-flash.left, .border-flash.right {
    top: 0;
    height: 100%;
    width: 5vw; /* Thicker */
}

.border-flash.top { top: 0; }
.border-flash.bottom { bottom: 0; }
.border-flash.left { left: 0; }
.border-flash.right { right: 0; }

@keyframes flash-green-border {
    0% { opacity: 0; background-color: transparent; }
    50% { opacity: 0.7; background-color: rgba(46, 204, 113, 0.7); } /* More visible */
    100% { opacity: 0; background-color: transparent; }
}

@keyframes flash-red-border {
    0% { opacity: 0; background-color: transparent; }
    50% { opacity: 0.7; background-color: rgba(231, 76, 60, 0.7); } /* More visible */
    100% { opacity: 0; background-color: transparent; }
}

.border-flash.green-flash-active {
    animation: flash-green-border 1s ease-out forwards; /* 1 second duration */
}

.border-flash.red-flash-active {
    animation: flash-red-border 1s ease-out forwards; /* 1 second duration */
}

.progress-bar-container {
    width: 100%;
    height: 16px; /* thicker */
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 999px; /* pill */
    margin-top: 12px;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.45);
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #ffeb3b 0%, #ffd54f 100%);
    border-radius: 999px;
    width: 0%;
    transition: width 0.35s ease;
    box-shadow: 0 4px 10px rgba(255, 235, 59, 0.12);
}

/* Left column inside a todo li to hold title and small metadata lines */
.task-left {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* left align text */
    flex-grow: 1;
}

/* Keep actions aligned right */
li .actions {
    margin-left: auto;
}

/* Completed overdue small text (placed under title) */
.completed-overdue-text {
    font-size: 0.9em;
    color: rgba(255,82,82,0.95);
    margin-top: 6px;
    text-align: left;
}

/* Completed before planned duration */
.completed-underdue-text {
    font-size: 0.9em;
    color: rgba(255, 193, 7, 0.95); /* yellow */
    margin-top: 6px;
    text-align: left;
}

/* Completed and reached planned duration (no overdue) */
.completed-complete-text {
    font-size: 0.9em;
    color: rgba(46, 204, 113, 0.95); /* green */
    margin-top: 6px;
    text-align: left;
}

/* Modal task name highlight */
.modal-message-main { text-align: center; }
.modal-task-name {
    font-weight: 700;
    display: inline-block;
    padding: 6px 10px;
    border-radius: 6px;
    border: 2px solid rgba(255, 235, 59, 0.95); /* yellow border */
    background: rgba(255,235,59,0.04);
}
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="main-container">
        <div class="todo-container">
            <h1>To-Do App</h1>
            {% if user %}
                <div class="user-info">
                    <p>Welcome, {{ user.name }}!</p>
                    <a href="/logout" class="logout-button">Logout</a>
                </div>
                <div class="input-container">
                    <input type="text" id="todo-input" placeholder="Add a new to-do...">
                    <input type="number" id="duration-hours" placeholder="Hours" min="0">
                    <input type="number" id="duration-minutes" placeholder="Mins" min="0" max="59">
                    <button id="add-button">Add</button>
                </div>
                <ul id="todo-list">
                    {% for todo in todos %}
                        {% if not todo.completed %}
                            <li data-id="{{ todo.id }}" data-duration-hours="{{ todo.duration_hours }}" data-duration-minutes="{{ todo.duration_minutes }}" data-focused-time="{{ todo.focused_time }}" data-was-overdue="{{ todo.was_overdue if 'was_overdue' in todo.keys() else 0 }}" data-overdue-time="{{ todo.overdue_time if 'overdue_time' in todo.keys() else 0 }}">
                                <span>{{ todo.text }}</span>
                                <div class="actions">
                                    {% set duration_str = [] %}
                                    {% if todo.duration_hours and todo.duration_hours > 0 %}
                                        {% set _ = duration_str.append(todo.duration_hours ~ 'h') %}
                                    {% endif %}
                                    {% if todo.duration_minutes and todo.duration_minutes > 0 %}
                                        {% set _ = duration_str.append(todo.duration_minutes ~ 'm') %}
                                    {% endif %}
                                    {% if duration_str %}
                                        <span class="duration">{{ duration_str | join(' ') }}</span>
                                    {% endif %}
                                    <button class="play-button"><i class="fas fa-play"></i></button>
                                    <button class="done-button"><i class="fas fa-check"></i></button>
                                    <button class="delete-button"><i class="fas fa-trash"></i></button>
                                </div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar"></div>
                                </div>
                            </li>
                        {% endif %}
                    {% endfor %}
                </ul>
                <hr class="separator">
                <div class="completed-header">
                    <button id="completed-toggle" aria-expanded="false"><span class="toggle-arrow"></span> Completed</button>
                    <button id="clear-completed-button">Clear All</button>
                </div>
                <ul id="completed-list" style="display: none;">
                    {% for todo in todos %}
                        {% if todo.completed %}
                            <li data-id="{{ todo.id }}" data-duration-hours="{{ todo.duration_hours }}" data-duration-minutes="{{ todo.duration_minutes }}" data-focused-time="{{ todo.focused_time }}" data-was-overdue="{{ todo.was_overdue if 'was_overdue' in todo.keys() else 0 }}" data-overdue-time="{{ todo.overdue_time if 'overdue_time' in todo.keys() else 0 }}" class="completed">
                                <span>{{ todo.text }}</span>
                                <div class="actions">
                                    {% set duration_str = [] %}
                                    {% if todo.duration_hours and todo.duration_hours > 0 %}
                                        {% set _ = duration_str.append(todo.duration_hours ~ 'h') %}
                                    {% endif %}
                                    {% if todo.duration_minutes and todo.duration_minutes > 0 %}
                                        {% set _ = duration_str.append(todo.duration_minutes ~ 'm') %}
                                    {% endif %}
                                    {% if duration_str %}
                                        <span class="duration">{{ duration_str | join(' ') }}</span>
                                    {% endif %}
                                    <button class="play-button"><i class="fas fa-play"></i></button>
                                    <button class="done-button"><i class="fas fa-undo"></i></button>
                                    <button class="delete-button"><i class="fas fa-trash"></i></button>
                                </div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar"></div>
                                </div>
                            </li>
                        {% endif %}
                    {% endfor %}
                </ul>
            {% else %}
                <div class="login-container">
                    <p>Please log in to use the To-Do App.</p>
                    <a href="/login" class="login-button">Login with Google</a>
                </div>
            {% endif %}
        </div>
        <div class="pomodoro-container" style="display: none;">
            <h2>Pomodoro Timer</h2>
            <div id="pomodoro-task"></div>
            <!-- Overdue hint shown when working on an overdue task -->
            <div id="pomodoro-overdue-hint" class="pomodoro-overdue-hint" style="display:none;"> Overdue task</div>
            <div class="pomodoro-inputs">
                <input type="number" id="focus-duration" placeholder="Focus (mins)" min="1">
                <input type="number" id="break-duration" placeholder="Break (mins)" min="1">
                <input type="number" id="cycle-count" placeholder="Cycles" min="1">
            </div>
            <div id="pomodoro-session-display"></div>
            <div class="pomodoro-timer-wrapper">
                <div class="pomodoro-timer">25:00</div>
            </div>
            <div class="pomodoro-controls">
                <div>
                    <button id="pomodoro-start-pause">Start</button>
                    <button id="pomodoro-skip">Skip to Break</button>
                    <button id="pomodoro-reset">Reset</button>
                </div>
                </div>
            <div id="pomodoro-notification" style="display: none;"></div>
            <button id="pomodoro-close-button" class="close-button">&times;</button>
        </div>
    </div>
    <div class="border-flash top"></div>
    <div class="border-flash bottom"></div>
    <div class="border-flash left"></div>
    <div class="border-flash right"></div>
    <!-- Global modal placeholder for overdue prompt -->
    <div id="global-overdue-modal" class="global-modal" style="display:none;">
        <div class="modal-card">
            <div id="global-overdue-message">Planned time reached</div>
            <div class="modal-actions">
                <button id="modal-mark-complete" class="btn-primary">Mark Complete</button>
                <button id="modal-continue" class="btn-secondary">Continue</button>
            </div>
        </div>
    </div>
    {% if user %}
    <script src="{{ url_for('static', filename='script.js') }}"></script>
    {% endif %}
</body>
</html>
</file>

<file path=".gitignore">
# Environment variables
.env

# Python cache
__pycache__/
*.pyc

# OS files
.DS_Store
</file>

<file path="build_plan.txt">
f course. Here is a detailed description of the to-do application's UI, logic, and user experience, designed to be used as a prompt for an AI agent to
  recreate a similar app in Flutter.

  ---

  App Concept: A To-Do List with an Integrated Pomodoro Timer

  The application is a task management tool that combines a standard to-do list with a feature-rich Pomodoro timer. The core idea is to help users not
  only manage their tasks but also focus on them effectively using the Pomdoro technique. The app should allow users to log in with their Google
  account to persist their to-do list across sessions.

  Main UI Layout

  The main screen is divided into two main sections: a to-do list on the left and a Pomodoro timer on the right. Initially, only the to-do list is
  visible. The Pomodoro timer panel appears on the right when a user decides to start a focus session on a specific task.

  To-Do List Functionality

  1. Adding a New To-Do Item

   * UI Elements:
       * An input field for the task's name (e.g., "Write a report").
       * Two numerical input fields for the estimated duration of the task: one for hours and one for minutes.
       * An "Add" button.
   * Logic:
       * When the user types a task name, specifies a duration, and clicks "Add," a new task is created.
       * The new task appears at the bottom of the "To-Do" list.

  2. Displaying To-Do Items

   * UI Elements:
       * Each task is a list item.
       * Each item displays:
           * The task name.
           * The estimated duration (e.g., "1h 30m").
           * A set of action buttons: "Play," "Done," and "Delete."
           * A progress bar underneath the task name.
   * Logic:
       * The list is divided into two sections: "To-Do" (active tasks) and "Completed" (finished tasks).

  3. Task Actions

   * Play Button (Icon: `fa-play`)
       * Action: When clicked, this button activates the Pomodoro timer for the selected task.
       * UI Change: The Pomodoro timer panel becomes visible on the right side of the screen, and the selected task is highlighted in the to-do list.
   * Done Button (Icon: `fa-check`)
       * Action: Marks the task as complete.
       * UI Change: The task is moved from the "To-Do" list to the "Completed" list. The "Done" button's icon changes to an "Undo" icon (fa-undo).
   * Delete Button (Icon: `fa-trash`)
       * Action: Permanently deletes the task from the user's list.

  4. Progress Bar

   * UI Element: A horizontal bar at the bottom of each task item.
   * Logic:
       * The progress bar visually represents the amount of time the user has focused on the task, relative to the total estimated duration.
       * For example, if a task has an estimated duration of 1 hour and the user has focused for 30 minutes, the progress bar will be 50% full.
       * The progress bar updates in real-time during a focus session.

  5. Completed Tasks Section

   * UI Element: A collapsible section below the active to-do list, labeled "Completed."
   * Logic:
       * When a task is marked as "Done," it moves to this section.
       * The "Done" button on a completed task becomes an "Undo" button. Clicking it moves the task back to the active to-do list.
       * There is a "Clear All" button to permanently delete all completed tasks.

  Pomodoro Timer Functionality

  1. Activating the Pomodoro Timer

   * Logic: The timer is activated by clicking the "Play" button on any task in the to-do list. The timer is then associated with that specific task.

  2. Timer Display and Controls

   * UI Elements:
       * Task Name: The name of the task the user is currently focused on is displayed at the top of the timer panel.
       * Timer Display: A large, digital clock-style display shows the remaining time in the current session (e.g., "24:59").
       * Session Display: Shows the current Pomodoro cycle (e.g., "1 / 4").
       * Input Fields: For setting the duration of focus and break sessions, and the number of cycles.
       * Buttons:
           * Start/Pause: Starts or pauses the timer. The button text toggles between "Start" and "Pause."
           * Skip: Skips the current session. If in a focus session, it skips to the break. If in a break, it skips to the next focus session.
           * Reset: Resets the timer to its initial state for the current task.
           * Close: Hides the Pomodoro timer panel.

  3. Timer States: Focus and Break

   * Logic:
       * The timer alternates between "focus" and "break" modes.
       * When a focus session ends, a break session automatically begins, and vice versa.
   * UI Change: The UI provides visual feedback for the current mode. For example, the timer's border or background color could change (e.g., red for
     focus, green for break).

  4. Overdue Tasks

   * Logic:
       * If the total focused time on a task exceeds its estimated duration, the task is marked as "overdue."
   * UI Change:
       * The overdue task is visually distinguished in the to-do list (e.g., with a red border or an icon).
       * When the Pomodoro timer is active for an overdue task, an "Overdue" indicator is displayed in the timer panel.

  User Authentication

   * Logic:
       * The app uses Google for user authentication.
       * If a user is not logged in, the to-do list is hidden, and a "Login with Google" button is displayed.
       * Upon successful login, the user's to-do list is fetched from the server, and their name is displayed.
       * A "Logout" button is available for logged-in users.

  Notifications and Sounds

   * Logic: The app provides audio-visual cues for important events.
   * Browser Notifications:
       * When a focus or break session starts.
       * When a task is completed.
       * When a task becomes overdue.
   * Sound Effects:
       * A distinct sound effect is played for each type of notification (e.g., a "tick-tock" for the start of a session, a "chime" for completion).

  Modals and Pop-ups

   * Overdue Task Prompt:
       * Trigger: When a task's focused time equals its estimated duration, a modal pops up.
       * Content: The modal asks the user, "Planned time is completed. Mark complete or continue working on the overdue task?"
       * Actions:
           * Mark Complete: Marks the task as complete.
           * Continue: Closes the modal and allows the user to continue the focus session, now in "overdue" mode.
   * Completion Prompt:
       * Trigger: When all the planned Pomodoro cycles for a task are completed.
       * Content: A modal appears, informing the user that they have finished all cycles for the task.

  Data Persistence

   * Backend (Server-side):
       * The user's to-do list (task names, durations, completion status, etc.) is stored in a database on the server, linked to their Google account.
   * Frontend (Client-side):
       * The state of the Pomodoro timer for each task (e.g., the current cycle, remaining time) is saved in the browser's local storage. This ensures
         that if the user accidentally refreshes the page, the timer's state is not lost.
</file>

<file path="package.json">
{
  "name": "todoapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/newprayas/Todoapp.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/newprayas/Todoapp/issues"
  },
  "homepage": "https://github.com/newprayas/Todoapp#readme",
  "devDependencies": {
    "@playwright/test": "^1.55.0"
  }
}
</file>

<file path="schema.sql">
DROP TABLE IF EXISTS todos;

CREATE TABLE todos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    text TEXT NOT NULL,
    completed INTEGER NOT NULL DEFAULT 0,
    duration_hours INTEGER,
    duration_minutes INTEGER,
    focused_time INTEGER NOT NULL DEFAULT 0
);
</file>

<file path="Script.js">
document.addEventListener('DOMContentLoaded', () => {
    const todoInput = document.getElementById('todo-input');
    const addButton = document.getElementById('add-button');
    const todoList = document.getElementById('todo-list');
    const completedList = document.getElementById('completed-list');
    const durationHoursInput = document.getElementById('duration-hours');
    const durationMinutesInput = document.getElementById('duration-minutes');

    const todoContainer = document.querySelector('.todo-container');
    const pomodoroContainer = document.querySelector('.pomodoro-container');
    const pomodoroTask = document.getElementById('pomodoro-task');
    const pomodoroSessionDisplay = document.getElementById('pomodoro-session-display');
    const focusDurationInput = document.getElementById('focus-duration');
    const breakDurationInput = document.getElementById('break-duration');
    const cycleCountInput = document.getElementById('cycle-count');
    const pomodoroTimerDisplay = document.querySelector('.pomodoro-timer');
    const pomodoroTimerWrapper = document.querySelector('.pomodoro-timer-wrapper');
    const pomodoroStartPauseBtn = document.getElementById('pomodoro-start-pause');
    const pomodoroSkipBtn = document.getElementById('pomodoro-skip');
    const pomodoroResetBtn = document.getElementById('pomodoro-reset');
    const pomodoroNotification = document.getElementById('pomodoro-notification');
    const pomodoroCloseButton = document.getElementById('pomodoro-close-button');

    const borderFlashes = document.querySelectorAll('.border-flash');

    let timerInterval;
    let progressUpdateInterval;
    let timerState = 'paused';
    let currentMode = 'focus';
    let timeRemaining;
    let totalCycles;
    let currentCycle = 0;
    let currentTaskDuration = 0;
    let currentRunningTaskId = null;
    let focusSessionStartTime = 0;
    let lastFocusedTime = 0;
    let globalProgressCheckerInterval = null;
    // flags to know if user manually edited inputs
    let focusEdited = false;
    let breakEdited = false;
    // store per-task timer state when switching between tasks
    const taskTimerStates = {};
    // last session increment in seconds (most recent active focus session)
    let lastSessionIncrement = 0;

    const TASK_STATE_KEY = 'todo_task_timer_states_v1';

    function persistAllTaskStates() {
        try {
            localStorage.setItem(TASK_STATE_KEY, JSON.stringify(taskTimerStates));
        } catch (e) {
            console.log('DEBUG: persistAllTaskStates failed', e);
        }
    }

    function loadAllTaskStates() {
        try {
            const raw = localStorage.getItem(TASK_STATE_KEY);
            if (raw) {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === 'object') {
                    Object.assign(taskTimerStates, parsed);
                }
            }
        } catch (e) {
            console.log('DEBUG: loadAllTaskStates failed', e);
        }
    }

    function saveTaskTimerState(taskId) {
        if (!taskId) return;
        // compute lastFocusedTime up-to-date if a focus session is active
        let persistedLastFocused = lastFocusedTime;
        if (focusSessionStartTime > 0 && currentRunningTaskId === taskId) {
            const elapsed = Math.floor((Date.now() - focusSessionStartTime) / 1000);
            persistedLastFocused = lastFocusedTime + elapsed;
        }
        taskTimerStates[taskId] = {
            timerState: 'paused', // always pause when switching away
            currentMode: currentMode,
            timeRemaining: timeRemaining || null,
            totalCycles: totalCycles || parseInt(cycleCountInput.value) || null,
            // persist user-editable pomodoro inputs so they restore per-task
            focusDuration: (typeof focusDurationInput !== 'undefined' && focusDurationInput.value) ? parseInt(focusDurationInput.value) || null : null,
            breakDuration: (typeof breakDurationInput !== 'undefined' && breakDurationInput.value) ? parseInt(breakDurationInput.value) || null : null,
            currentCycle: currentCycle || 0,
            lastFocusedTime: persistedLastFocused || 0
        };
    persistAllTaskStates();
    }

    function restoreTaskTimerState(taskId) {
    // ensure we have any persisted states loaded
    if (Object.keys(taskTimerStates).length === 0) loadAllTaskStates();
    const s = taskTimerStates[taskId];
        if (!s) return false;
        // restore fields into global state but keep timer paused
        timerState = 'paused';
        currentMode = s.currentMode || 'focus';
        timeRemaining = (typeof s.timeRemaining !== 'undefined' && s.timeRemaining !== null) ? s.timeRemaining : null;
        totalCycles = s.totalCycles || null;
        currentCycle = s.currentCycle || 0;
        lastFocusedTime = s.lastFocusedTime || 0;
        // update UI
        if (totalCycles) cycleCountInput.value = totalCycles;
        // restore persisted focus/break inputs if present
        if (typeof s.focusDuration !== 'undefined' && s.focusDuration !== null) {
            focusDurationInput.value = s.focusDuration;
        }
        if (typeof s.breakDuration !== 'undefined' && s.breakDuration !== null) {
            breakDurationInput.value = s.breakDuration;
        }
        // clear edit flags since we've just restored values
        focusEdited = false;
        breakEdited = false;
        if (timeRemaining) updateTimerDisplay();
        updateSessionDisplay();
        return true;
    }

    // Add a new to-do item
    addButton.addEventListener('click', () => {
        const todoText = todoInput.value.trim();
        // treat empty hour/minute as 0; require at least one > 0
        const durationHoursRaw = durationHoursInput.value.trim();
        const durationMinutesRaw = durationMinutesInput.value.trim();
        const durationHours = durationHoursRaw === '' ? '0' : durationHoursRaw;
        const durationMinutes = durationMinutesRaw === '' ? '0' : durationMinutesRaw;

        if (!todoText) {
            alert('Task name is required');
            return;
        }
        // require at least one of hours or minutes to be > 0
        if ((parseInt(durationHours) || 0) === 0 && (parseInt(durationMinutes) || 0) === 0) {
            alert('Please enter a duration in hours or minutes');
            return;
        }

        // proceed to create
        if (todoText !== '') {
            fetch('/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: todoText,
                    duration_hours: durationHours,
                    duration_minutes: durationMinutes
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(data.error);
                } else {
                    addTodoItemToDOM(data.id, data.text, data.completed, data.duration_hours, data.duration_minutes, data.focused_time, data.was_overdue, data.overdue_time);
                    todoInput.value = '';
                    durationHoursInput.value = '';
                    durationMinutesInput.value = '';
                    todoInput.focus();
                }
            });
        } else {
            alert('All fields are required');
        }
    });

    todoInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addButton.click();
        }
    });

    // Event listener for all lists
    [todoList, completedList].forEach(list => {
        list.addEventListener('click', (e) => {
            const target = e.target;
            const li = target.closest('li');
            if (!li) return;

            const todoId = li.dataset.id;
            const todoText = li.querySelector('span').textContent;

            if (target.closest('.play-button')) {
                const durationHours = parseInt(li.dataset.durationHours) || 0;
                const durationMinutes = parseInt(li.dataset.durationMinutes) || 0;
                currentTaskDuration = (durationHours * 60) + durationMinutes;
                todoContainer.classList.add('pomodoro-active');
                pomodoroContainer.style.display = 'block';
                pomodoroTask.textContent = todoText;
                // If another task currently has an active focus session, persist and pause it
                // so its progress is not lost when switching to a different task.
                if (currentRunningTaskId && currentRunningTaskId !== todoId) {
                    // save state for previous task
                    saveTaskTimerState(currentRunningTaskId);
                    // If a timer is running (could be focus or break), pause intervals
                    if (timerState === 'running') {
                        pauseTimer();
                    }
                    // If there was an active focus session, stop it and persist elapsed time
                    if (focusSessionStartTime > 0) {
                        stopFocusTimer();
                    }
                }
                // keep the selected task id when resetting UI
                // remove visual highlight from previous task
                const prevActive = document.querySelector('li.active-task');
                if (prevActive && prevActive.dataset.id && prevActive.dataset.id !== todoId) {
                    prevActive.classList.remove('active-task');
                }

                // keep the selected task id when resetting UI
                resetPomodoro();
                currentRunningTaskId = todoId;
                // restore previous saved state if any
                const restored = restoreTaskTimerState(todoId);
                if (!restored) {
                    // set defaults
                    timerState = 'paused';
                    currentMode = 'focus';
                    timeRemaining = null;
                    currentCycle = 0;
                    pomodoroTimerDisplay.textContent = '25:00';
                    cycleCountInput.value = '';
                }
                // highlight the selected task in the list for visibility
                li.classList.add('active-task');
                // ensure default focus/break values (user can change them)
                if (!focusDurationInput.value) focusDurationInput.value = 25;
                if (!breakDurationInput.value) breakDurationInput.value = 5;
                // initialize lastFocusedTime from stored dataset so realtime progress calc is correct
                lastFocusedTime = parseInt(li.dataset.focusedTime) || 0;
                // Render the task name inside the Pomodoro panel with bordered styling
                // If the task is overdue, append a red-dot emoji inline to the name
                const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                const overdueEmoji = (wasOverdue && parseInt(wasOverdue) === 1) ? ' <span class="pomodoro-overdue-emoji"></span>' : '';
                pomodoroTask.innerHTML = `<span class="pomodoro-task-name">${todoText}${overdueEmoji}</span>`;
                // hide the separate overdue hint element (we now show emoji inline)
                const hint = document.getElementById('pomodoro-overdue-hint');
                if (hint) hint.style.display = 'none';
                // Auto-calc cycles if cycles input is empty (applies also for restored overdue tasks)
                updateProgressBar(todoId);
                const focusDurationRaw = parseInt(focusDurationInput.value);
                const focusDuration = (!isNaN(focusDurationRaw) && focusDurationRaw > 0) ? focusDurationRaw : 25;
                if (currentTaskDuration > 0) {
                    // Only auto-calc when user hasn't provided a cycles value
                    if (!cycleCountInput.value || parseInt(cycleCountInput.value) <= 0) {
                        const calculatedCycles = Math.max(1, Math.floor(currentTaskDuration / focusDuration));
                        cycleCountInput.value = calculatedCycles;
                    }
                }
            } else if (target.closest('.done-button')) {
                // Toggle completion status
                const isCurrentlyCompleted = li.classList.contains('completed');
                fetch('/toggle', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: todoId }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.result === 'success') {
                        const doneButtonIcon = li.querySelector('.done-button i');
                        if (isCurrentlyCompleted) { // Task is being uncompleted
                            li.classList.remove('completed');
                            doneButtonIcon.classList.remove('fa-undo');
                            doneButtonIcon.classList.add('fa-check');
                            // If there is an overdue badge, remove it from title and restore card styling
                            const badge = li.querySelector('.overdue-badge');
                            if (badge) badge.remove();
                            // If there was a completed-overdue text indicator, remove it so it doesn't duplicate with active progress bar
                            const compOverEl = li.querySelector('.completed-overdue-text');
                            if (compOverEl) compOverEl.remove();
                            if (li.dataset.wasOverdue == 1 || li.getAttribute('data-was-overdue') == '1') {
                                // restore visual overdue state on the card if still overdue
                                li.classList.add('overdue');
                            }
                            todoList.appendChild(li);
                            // Notify uncompletion? skip notification for uncomplete
                        } else { // Task is being completed
                            li.classList.remove('overdue');
                            // If task was overdue, move visual indicator from card to a small badge next to title
                            const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdue && parseInt(wasOverdue) === 1) {
                                // add red-circle badge emoji
                                addOverdueBadge(li);
                            }

                            li.classList.add('completed');
                            doneButtonIcon.classList.remove('fa-check');
                            doneButtonIcon.classList.add('fa-undo');
                            // remove any live overdue-extra (session-only) to avoid inline display
                            const extraEl = li.querySelector('.overdue-extra'); if (extraEl) extraEl.remove();
                            // Prepend so most-recent completed task appears at the top
                            if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                            else completedList.appendChild(li);
                            // Browser notification and sound for completion
                            try { sendNotification('Task completed', `${todoText}  marked complete`, 'complete'); } catch(e){}
                            // Ensure completed overdue text is placed under the title for consistency
                            const wasOverdueNow = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdueNow && parseInt(wasOverdueNow) === 1) {
                                ensureCompletedOverdueIndicator(li);
                            } else {
                                // add appropriate completed status label
                                ensureCompletedStatusIndicator(li);
                            }

                            if (currentRunningTaskId === todoId) {
                                hidePomodoroTimer();
                            }
                        }
                    }
                });
            } else if (target.closest('.delete-button')) {
                // Delete to-do item
                fetch('/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: todoId }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.result === 'success') {
                        li.remove();
                        if (currentRunningTaskId === todoId) {
                            hidePomodoroTimer();
                        }
                    }
                });
            }
        });
    });

    // Pomodoro Timer Logic
    focusDurationInput.addEventListener('input', () => {
        const focusDuration = parseInt(focusDurationInput.value);
        if (!isNaN(focusDuration) && focusDuration > 0 && currentTaskDuration > 0) {
            const calculatedCycles = Math.floor(currentTaskDuration / focusDuration);
            cycleCountInput.value = calculatedCycles > 0 ? calculatedCycles : 1;
        }
    });

    // track manual edits to focus/break so starting can re-init timer when needed
    focusDurationInput.addEventListener('input', () => { 
        focusEdited = true; 
        if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
    });
    breakDurationInput.addEventListener('input', () => { 
        breakEdited = true; 
        if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
    });

    pomodoroStartPauseBtn.addEventListener('click', () => {
        if (timerState === 'paused') {
            const focusDuration = parseInt(focusDurationInput.value);
            const breakDuration = parseInt(breakDurationInput.value);
            totalCycles = parseInt(cycleCountInput.value);

            // Validate inputs
            if (isNaN(focusDuration) || isNaN(breakDuration) || isNaN(totalCycles) || focusDuration <= 0 || breakDuration <= 0 || totalCycles <= 0) {
                alert('Please enter valid values for focus, break, and cycles.');
                return;
            }

            // If a task is selected, ensure the focus duration does not exceed the task's total planned duration
            // Apply this rule only for normal (non-overdue) tasks. Skip validation for overdue tasks and overdue pomodoro sessions.
            if (currentRunningTaskId) {
                try {
                    const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
                    // Skip validation for overdue tasks (server-reported overdue or UI class)
                    const isOverdue = (li && (li.dataset.wasOverdue && parseInt(li.dataset.wasOverdue) === 1)) || (li && parseInt(li.dataset.overdueTime) > 0) || (li && li.classList && li.classList.contains('overdue'));
                    if (!isOverdue) {
                        const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                        if (rem && typeof rem.total !== 'undefined') {
                            if ((focusDuration * 60) > rem.total) {
                                alert('Focus duration cannot be longer than the task duration. Please reduce the focus duration or increase the task duration.');
                                return;
                            }
                        }
                    }
                } catch (e) {
                    console.log('DEBUG: focus duration validation failed', e);
                }
            }

            // Ensure the session display reflects the newly entered cycles immediately
            updateSessionDisplay();

            // Initialize timeRemaining taking into account manual edits
            if (!timeRemaining) {
                // Cap the initial focus period to the remaining planned time for this task (if available and not overdue)
                if (currentRunningTaskId) {
                    const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                    if (rem && rem.remaining !== undefined && rem.remaining > 0 && rem.remaining < (focusDuration * 60)) {
                        timeRemaining = rem.remaining;
                    } else {
                        timeRemaining = focusDuration * 60;
                    }
                } else {
                    timeRemaining = focusDuration * 60;
                }
                currentCycle++;
                updateSessionDisplay();
            } else if (currentMode === 'focus' && focusEdited && timerState === 'paused') {
                // If user changed focus duration manually while paused but timeRemaining still held old value,
                // reset the timer to the new focus duration for the upcoming start (but keep currentCycle).
                timeRemaining = focusDuration * 60;
                updateTimerDisplay();
                updateSessionDisplay();
            } else if (currentMode === 'break' && breakEdited && timerState === 'paused') {
                timeRemaining = breakDuration * 60;
                updateTimerDisplay();
                updateSessionDisplay();
            }
            startTimer();
        } else {
            pauseTimer();
        }
    });

    // If user edits the cycles input manually, reflect it immediately in UI and state
    cycleCountInput.addEventListener('input', () => {
        const v = parseInt(cycleCountInput.value);
        if (!isNaN(v) && v > 0) {
            totalCycles = v;
            updateSessionDisplay();
            // persist per-task if a task is currently selected
            if (currentRunningTaskId) saveTaskTimerState(currentRunningTaskId);
        }
    });

    pomodoroSkipBtn.addEventListener('click', () => {
    // Debug: trace skip click
    console.log('DEBUG: Skip clicked - currentMode:', currentMode, 'timerState:', timerState, 'currentRunningTaskId:', currentRunningTaskId);

    // Clear running intervals to prepare for mode switch
    clearInterval(timerInterval);
    clearInterval(progressUpdateInterval);

        // Safe defaults
        const DEFAULT_FOCUS_MIN = 25;
        const DEFAULT_BREAK_MIN = 5;

        if (currentMode === 'focus') {
            // Leaving a focus session -> stop tracking and go to break
            stopFocusTimer();
            console.log('DEBUG: switching from focus to break');
            currentMode = 'break';
            let breakDuration = parseInt(breakDurationInput.value);
            if (isNaN(breakDuration) || breakDuration <= 0) {
                breakDuration = DEFAULT_BREAK_MIN;
            }
            timeRemaining = breakDuration * 60;
            console.log('DEBUG: breakDuration (mins):', breakDuration, 'timeRemaining (s):', timeRemaining);
            triggerFlashAnimation('green');
            // start timer in break mode
            startTimer();
        } else {
            // Leaving a break -> go to focus
            currentMode = 'focus';
            console.log('DEBUG: switching from break to focus');
            let focusDuration = parseInt(focusDurationInput.value);
            if (isNaN(focusDuration) || focusDuration <= 0) {
                focusDuration = DEFAULT_FOCUS_MIN;
            }
            // Cap the focus session by remaining planned seconds for the selected task
            if (currentRunningTaskId) {
                const rem = computeRemainingPlannedSeconds(currentRunningTaskId);
                if (rem && rem.remaining !== undefined && rem.remaining > 0 && rem.remaining < (focusDuration * 60)) {
                    timeRemaining = rem.remaining;
                } else {
                    timeRemaining = focusDuration * 60;
                }
            } else {
                timeRemaining = focusDuration * 60;
            }
            // increment cycle since user is starting a new focus session
            currentCycle++;
            updateSessionDisplay();
            console.log('DEBUG: focusDuration (mins):', focusDuration, 'timeRemaining (s):', timeRemaining, 'currentCycle:', currentCycle);
            triggerFlashAnimation('red');
            startTimer();
        }
    });

    pomodoroResetBtn.addEventListener('click', () => {
    // Reset UI and subtract only the current session's increment from the task's progress
    resetPomodoroAndProgress(currentRunningTaskId);
    });

    pomodoroCloseButton.addEventListener('click', () => {
        hidePomodoroTimer();
    });

    function startTimer() {
    timerState = 'running';
        pomodoroStartPauseBtn.textContent = 'Pause';
    // user edits applied; clear the edit flags now that timer is running
    focusEdited = false;
    breakEdited = false;
        // Visually mark the currently running task in the list
        if (currentRunningTaskId) {
            const runningLi = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
            if (runningLi) runningLi.classList.add('active-task');
        }
    console.log('DEBUG: startTimer called - mode:', currentMode, 'timeRemaining:', timeRemaining, 'currentRunningTaskId:', currentRunningTaskId, 'progressUpdateInterval id:', progressUpdateInterval);

        document.querySelector('.pomodoro-inputs').style.display = 'none';

        if (currentMode === 'focus') {
            pomodoroSkipBtn.textContent = 'Skip to Break';
            pomodoroTimerWrapper.classList.remove('break-mode');
            pomodoroTimerWrapper.classList.add('focus-mode');
            startFocusTimer();
            // Notify user that focus started
            try { sendNotification('Focus started', 'Focus timer started', 'start'); } catch(e){}
            
            // Clear any existing interval before starting a new one
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }
            
            // Start progress bar update interval
            if (progressUpdateInterval) {
                console.log('DEBUG: clearing existing progressUpdateInterval before creating new one, id=', progressUpdateInterval);
                clearInterval(progressUpdateInterval);
            }
            progressUpdateInterval = setInterval(() => {
                if (currentRunningTaskId && timerState === 'running') {
                    updateProgressBar(currentRunningTaskId);
                }
            }, 1000);
            console.log('DEBUG: progressUpdateInterval set to', progressUpdateInterval);
        } else {
            pomodoroSkipBtn.textContent = 'Skip to Focus';
            pomodoroTimerWrapper.classList.remove('focus-mode');
            pomodoroTimerWrapper.classList.add('break-mode');
            // Notify user that break started
            try { sendNotification('Break started', 'Break timer started', 'break'); } catch(e){}
        }

        timerInterval = setInterval(() => {
            timeRemaining--;
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                timeRemaining = 0;
                updateTimerDisplay();
                handleSessionEnd();
            } else {
                updateTimerDisplay();
            }
        }, 1000);
    }

    function pauseTimer() {
    console.log('DEBUG: pauseTimer called - timeRemaining:', timeRemaining, 'currentMode:', currentMode, 'progressUpdateInterval id:', progressUpdateInterval);
    timerState = 'paused';
        clearInterval(timerInterval);
        if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            console.log('DEBUG: cleared progressUpdateInterval', progressUpdateInterval);
            progressUpdateInterval = null;
        }
        stopFocusTimer();
        // Remove visual highlight when paused
        if (currentRunningTaskId) {
            const runningLi = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
            if (runningLi) runningLi.classList.remove('active-task');
        }
        pomodoroStartPauseBtn.textContent = 'Resume';
    }

    function resetTimer() {
        clearInterval(timerInterval);
        stopFocusTimer();
        timerState = 'paused';
        const focusDuration = parseInt(focusDurationInput.value);
        if (!isNaN(focusDuration) && focusDuration > 0) {
            timeRemaining = focusDuration * 60;
        } else {
            timeRemaining = 25 * 60;
        }
        updateTimerDisplay();
        pomodoroStartPauseBtn.textContent = 'Start';
    }

    // Reset both Pomodoro UI and the task's persisted focused_time (server + UI)
    function resetPomodoroAndProgress(taskId) {
        // Reset UI timer
        resetTimer();
        // Only subtract the last session increment from the focused_time persisted for this task
        if (taskId) {
            const li = document.querySelector(`li[data-id='${taskId}']`);
            if (li) {
                const persisted = parseInt(li.dataset.focusedTime) || 0;
                const subtract = Math.max(0, lastSessionIncrement || 0);
                const newVal = Math.max(0, persisted - subtract);
                li.dataset.focusedTime = newVal;
                // update overdue_time/wasOverdue based on new focused value (server will compute normalization)
                updateFocusTimeOnServer(taskId, newVal);
                // remove only the live extra visual showing session-only overtime
                const extra = li.querySelector('.overdue-extra'); if (extra) extra.remove();
                // update progress bar to reflect new persisted focused time
                updateProgressBar(taskId);
            }
        }
    }

    function resetPomodoro() {
        clearInterval(timerInterval);
        clearInterval(progressUpdateInterval);
        timerState = 'paused';
        currentMode = 'focus';
        timeRemaining = null;
        currentCycle = 0;
        pomodoroTimerDisplay.textContent = '25:00';
        pomodoroStartPauseBtn.textContent = 'Start';
        pomodoroNotification.style.display = 'none';
        pomodoroSessionDisplay.textContent = '';
        pomodoroTimerWrapper.classList.remove('focus-mode', 'break-mode');
        document.querySelector('.pomodoro-inputs').style.display = 'flex';
        focusDurationInput.value = '';
        breakDurationInput.value = '';
    cycleCountInput.value = '';
    // Clear displayed task name and overdue hint
    pomodoroTask.innerHTML = '';
    const hint = document.getElementById('pomodoro-overdue-hint');
    if (hint) hint.style.display = 'none';
    }

    function hidePomodoroTimer() {
        if (timerState === 'running') {
            pauseTimer();
        }
        stopFocusTimer();
        resetPomodoro();
        pomodoroContainer.style.display = 'none';
        todoContainer.classList.remove('pomodoro-active');
        
        // Reset all state variables
    // remove highlight from any active task
    const runningLi = document.querySelector('li.active-task');
    if (runningLi) runningLi.classList.remove('active-task');
    currentRunningTaskId = null;
        lastFocusedTime = 0;
        focusSessionStartTime = 0;
        if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            console.log('DEBUG: hidePomodoroTimer cleared progressUpdateInterval', progressUpdateInterval);
            progressUpdateInterval = null;
        }
    }

    function updateTimerDisplay() {
        const displayTime = timeRemaining < 0 ? 0 : timeRemaining;
        const minutes = Math.floor(displayTime / 60);
        const seconds = displayTime % 60;
        pomodoroTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function updateSessionDisplay() {
        pomodoroSessionDisplay.textContent = `${currentCycle} / ${totalCycles}`;
    }

    // Helper: compute remaining planned seconds for a task from dataset (total - persistedFocused)
    function computeRemainingPlannedSeconds(taskId) {
        const li = document.querySelector(`li[data-id='${taskId}']`);
        if (!li) return null;
        const dh = parseInt(li.dataset.durationHours) || 0;
        const dm = parseInt(li.dataset.durationMinutes) || 0;
        const total = (dh * 3600) + (dm * 60);
        const persisted = parseInt(li.dataset.focusedTime) || 0;
        const remaining = Math.max(0, total - persisted);
        return { total, persisted, remaining };
    }

    function handleSessionEnd() {
        stopFocusTimer();

        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (!li) {
            resetPomodoro(); // or handle error appropriately
            return;
        }

        if (currentMode === 'focus') {
            if (currentCycle >= totalCycles) {
                try { sendNotification('All cycles completed', 'You finished all cycles', 'complete'); } catch(e){}
                const taskName = pomodoroTask.textContent || '';
                showCompletionPrompt(currentRunningTaskId, taskName || 'Task', 'All focus sessions completed');
            } else {
                const breakDuration = parseInt(breakDurationInput.value);
                if (!isNaN(breakDuration) && breakDuration > 0) {
                    currentMode = 'break';
                    timeRemaining = breakDuration * 60;
                    startTimer();
                } else {
                    resetPomodoro();
                }
            }
        } else { // currentMode is 'break'
            currentMode = 'focus';
            currentCycle++;
            updateSessionDisplay();
            const focusDuration = parseInt(focusDurationInput.value);
            if (!isNaN(focusDuration) && focusDuration > 0) {
                timeRemaining = focusDuration * 60;
                showNotification('Break ended! Time to focus.', 'Start Focus');
                try { sendNotification('Break ended', 'Time to focus', 'start'); } catch(e){}
                startTimer();
            } else {
                resetPomodoro();
            }
        }
    }

    // Show completion modal when all cycles finish
    function showCompletionPrompt(todoId, taskName, subtitle) {
        const modal = document.getElementById('global-overdue-modal');
        const messageEl = document.getElementById('global-overdue-message');
        // Reuse modal layout but change buttons and text
        messageEl.innerHTML = `
            <div class="modal-message-main"><span class="modal-task-name">${taskName}</span></div>
            <div style="margin-top:8px; font-size:0.95em;">${subtitle}</div>
        `;
        modal.style.display = 'flex';
        // Hide the Pomodoro UI while showing the completion modal without resetting internal state
        try {
            if (pomodoroContainer) pomodoroContainer.style.display = 'none';
            if (todoContainer) todoContainer.classList.remove('pomodoro-active');
        } catch (e) {
            console.log('DEBUG: showCompletionPrompt hide UI failed', e);
        }
        const markBtn = document.getElementById('modal-mark-complete');
        const contBtn = document.getElementById('modal-continue');
        // Rename buttons: primary -> Close/OK, secondary -> Dismiss
        markBtn.style.display = 'none';
        contBtn.textContent = 'Dismiss';
        // Unbind handlers by cloning
        const contClone = contBtn.cloneNode(true);
        contBtn.parentNode.replaceChild(contClone, contBtn);
        const dismiss = document.getElementById('modal-continue');
        dismiss.addEventListener('click', () => { modal.style.display = 'none'; });
    }

    function showNotification(message, buttonText) {
        pomodoroNotification.textContent = message;
        const nextSessionBtn = document.createElement('button');
        nextSessionBtn.textContent = buttonText;
        nextSessionBtn.addEventListener('click', () => {
            pomodoroNotification.style.display = 'none';
            if (buttonText === 'Reset Pomodoro') {
                resetPomodoro();
            } else {
                startTimer();
            }
        });
        pomodoroNotification.appendChild(nextSessionBtn);
        pomodoroNotification.style.display = 'block';
    }

    function triggerFlashAnimation(color) {
        // Query fresh elements each time to avoid working with detached nodes
        const flashes = document.querySelectorAll('.border-flash');
        console.log('DEBUG: triggerFlashAnimation - color:', color, 'borderFlashes count:', flashes.length);
        flashes.forEach(flash => {
            // Remove any running animation classes
            flash.classList.remove('green-flash-active', 'red-flash-active');
            // Force reflow to restart animation
            // eslint-disable-next-line no-unused-expressions
            void flash.offsetWidth;
            // Add desired animation class
            flash.classList.add(`${color}-flash-active`);
            // Clean up after animation ends
            flash.addEventListener('animationend', function handler() {
                flash.classList.remove('green-flash-active', 'red-flash-active');
                flash.removeEventListener('animationend', handler);
            });
        });
    }

    function addTodoItemToDOM(id, text, completed, durationHours, durationMinutes, focusedTime, wasOverdue, overdueTime) {
    const li = document.createElement('li');
        li.dataset.id = id;
        li.dataset.durationHours = durationHours;
        li.dataset.durationMinutes = durationMinutes;
        li.dataset.focusedTime = focusedTime;
        li.dataset.overdueTime = overdueTime || 0;
        // store persisted overdue flag
        li.dataset.wasOverdue = wasOverdue || 0;

    // Create a left column wrapper that holds the title and any small metadata lines (like overdue text)
    const taskLeft = document.createElement('div');
    taskLeft.classList.add('task-left');

    const span = document.createElement('span');
    span.textContent = text;
    taskLeft.appendChild(span);

        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('actions');

        const durationStr = [];
        if (durationHours && durationHours > 0) {
            durationStr.push(`${durationHours}h`);
        }
        if (durationMinutes && durationMinutes > 0) {
            durationStr.push(`${durationMinutes}m`);
        }

        if (durationStr.length > 0) {
            const durationSpan = document.createElement('span');
            durationSpan.classList.add('duration');
            durationSpan.textContent = durationStr.join(' ');
            actionsDiv.appendChild(durationSpan);
        }

        const playButton = document.createElement('button');
        playButton.classList.add('play-button');
        playButton.innerHTML = '<i class="fas fa-play"></i>';

        const doneButton = document.createElement('button');
        doneButton.classList.add('done-button');
        doneButton.innerHTML = completed ? '<i class="fas fa-undo"></i>' : '<i class="fas fa-check"></i>';

        const deleteButton = document.createElement('button');
        deleteButton.classList.add('delete-button');
        deleteButton.innerHTML = '<i class="fas fa-trash"></i>';

        actionsDiv.appendChild(playButton);
        actionsDiv.appendChild(doneButton);
        actionsDiv.appendChild(deleteButton);

    // append the left column first, then the actions (which stays aligned right by flex)
    li.appendChild(taskLeft);
    li.appendChild(actionsDiv);

        const progressBarContainer = document.createElement('div');
        progressBarContainer.classList.add('progress-bar-container');
        const progressBar = document.createElement('div');
        progressBar.classList.add('progress-bar');
        progressBarContainer.appendChild(progressBar);
        li.appendChild(progressBarContainer);

            if (completed) {
                // make sure any live extra overdue visuals are removed before showing completed layout
                const extra = li.querySelector('.overdue-extra'); if (extra) extra.remove();
                li.classList.add('completed');
                // Prepend completed items so newest-completed appear at the top
                if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                else completedList.appendChild(li);
                // If this completed task had overdue time persisted, show the small overdue indicator under the title
                if (parseInt(li.dataset.overdueTime) > 0 || parseInt(li.dataset.wasOverdue) === 1) {
                    ensureCompletedOverdueIndicator(li);
                } else {
                    ensureCompletedStatusIndicator(li);
                }
            } else {
                todoList.appendChild(li);
            }

        updateProgressBar(id);
    }

    function updateProgressBar(todoId) {
        const li = document.querySelector(`li[data-id='${todoId}']`);
        if (!li) return;

        const durationHours = parseInt(li.dataset.durationHours) || 0;
        const durationMinutes = parseInt(li.dataset.durationMinutes) || 0;
        const totalDurationInSeconds = (durationHours * 3600) + (durationMinutes * 60);
        
        // Base focused time comes from the stored dataset for this task
        const persistedFocused = parseInt(li.dataset.focusedTime) || 0;
        let currentFocusedTime = persistedFocused;
        // If this task is currently being focused, add the ongoing session time
        let currentSessionTime = 0;
        if (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running') {
            currentSessionTime = Math.floor((Date.now() - focusSessionStartTime) / 1000);
            currentFocusedTime += currentSessionTime;
        }

        // debug snapshot for tracing
        console.log('DEBUG: updateProgressBar snapshot', { todoId, persistedFocused, currentSessionTime, currentFocusedTime, timerState, currentMode, focusSessionStartTime });

    const progressBar = li.querySelector('.progress-bar');
    const progressContainer = li.querySelector('.progress-bar-container');
        if (totalDurationInSeconds > 0) {
            const progress = Math.min((currentFocusedTime / totalDurationInSeconds) * 100, 100);
            progressBar.style.width = `${progress}%`;
            // Mark the task as overdue (red card) when fully completed but not toggled as done
            const previousFocused = parseInt(li.dataset.focusedTime) || 0;
            const crossed = (previousFocused < totalDurationInSeconds) && (currentFocusedTime >= totalDurationInSeconds);
            if (currentFocusedTime >= totalDurationInSeconds && !li.classList.contains('completed')) {
                li.classList.add('overdue');
            } else {
                li.classList.remove('overdue');
            }

            // If progress reached 100% while actively running, immediately pause/stop timers and show modal once.
            // If progress is 100% due to persisted focused time (not actively running) then just mark as crossed
            // and let the global checker handle showing the modal (it skips items under processing).
            if (currentFocusedTime >= totalDurationInSeconds && !li.dataset.overdueNotified && !li.classList.contains('completed')) {
                const isActiveRunning = (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus');
                if (isActiveRunning) {
                    // actively crossed while running  handle immediately
                    console.log('DEBUG: updateProgressBar detected active running crossing for', todoId);
                        triggerOverdueForTaskLocal(todoId, totalDurationInSeconds);
                } else if (crossed) {
                    // Persisted crossing occurred; mark crossed and let global checker decide when to show modal
                    try { li.dataset.overdueCrossed = 1; } catch (e) {}
                    console.log('DEBUG: updateProgressBar marked overdueCrossed for', todoId);
                }
            }
        } else {
            progressBar.style.width = '0%';
        }
        // Show extra overdue time (time worked after planned duration)
    // Show overdue extra only for time actually spent in Pomodoro focus sessions plus any persisted overdue_time
    const persistedOverdue = parseInt(li.dataset.overdueTime) || 0;
    const baseline = parseInt(li.dataset.overdueBaseline) || totalDurationInSeconds;
    let sessionOverdue = 0;
    // Only count session overdue when this task is actively being focused via Pomodoro
    if (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus') {
        const currentSessionTime = Math.floor((Date.now() - focusSessionStartTime) / 1000);
        const persistedFocused = parseInt(li.dataset.focusedTime) || 0;
        const totalFocusedNow = persistedFocused + currentSessionTime;
        // sessionOverdue should represent ONLY the portion of overtime accumulated in THIS active session
        // i.e. totalFocusedNow - baseline minus any persisted overdue already recorded on the server
        const alreadyPersistedOverdue = persistedOverdue;
        if (totalFocusedNow > baseline) {
            sessionOverdue = Math.max(0, (totalFocusedNow - baseline) - alreadyPersistedOverdue);
        }
    }

    // triggerOverdueForTask is implemented in module scope (moved out) so callers outside updateProgressBar can access it.

    const extraSeconds = persistedOverdue + sessionOverdue;
    let extraEl = li.querySelector('.overdue-extra');
    // Ensure a single persistent element per li to avoid DOM thrash when multiple timers call update
    if (!extraEl) {
        extraEl = document.createElement('div');
        extraEl.classList.add('overdue-extra');
        extraEl.style.display = 'none';
        if (progressContainer) progressContainer.parentNode.insertBefore(extraEl, progressContainer.nextSibling);
        else li.appendChild(extraEl);
    }

    // cancel any pending hide timer
    if (li._overdueHideTimer) {
        clearTimeout(li._overdueHideTimer);
        li._overdueHideTimer = null;
    }

    console.log('DEBUG: overdue calc for', todoId, 'persistedOverdue:', persistedOverdue, 'sessionOverdue:', sessionOverdue, 'extraSeconds:', extraSeconds);
    if (extraSeconds > 0 && !li.classList.contains('completed')) {
        extraEl.textContent = `Overdue time: ${formatDuration(extraSeconds)}`;
        extraEl.style.display = 'block';
    } else {
        // debounce hiding to avoid flicker when updateProgressBar is called rapidly from multiple intervals
        li._overdueHideTimer = setTimeout(() => {
            if (extraEl) extraEl.style.display = 'none';
            li._overdueHideTimer = null;
        }, 700);
    }
    }

    function formatDuration(seconds) {
        seconds = Math.floor(seconds);
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        if (hrs > 0) {
            if (mins > 0) return `${hrs}h ${mins}m`;
            return `${hrs}h`;
        }
        if (mins > 0) {
            if (secs > 0) return `${mins}m ${secs}s`;
            return `${mins}m`;
        }
        return `${secs}s`;
    }

    function showOverduePrompt(message) {
        try { sendNotification('Task Overdue', 'Your task is now overdue. Mark complete or continue?', 'complete'); } catch(e){}
        // message param may be overloaded; handle signature showOverduePrompt(todoId, message)
        let todoId = null;
        let text = message;
        if (typeof message === 'string' && arguments.length === 2) {
            // called as showOverduePrompt(todoId, message)
        }
        if (arguments.length === 2) {
            todoId = arguments[0];
            text = arguments[1];
        }
        // We'll use the global modal so prompt appears regardless of Pomodoro visibility
        const modal = document.getElementById('global-overdue-modal');
        const messageEl = document.getElementById('global-overdue-message');

        // small helper to escape HTML when injecting task names
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }
        const markBtn = document.getElementById('modal-mark-complete');
        const contBtn = document.getElementById('modal-continue');

        // Build a clearer message that shows the task name highlighted and a second line with the action
        let taskName = '';
        if (todoId) {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li) taskName = li.querySelector('span') ? li.querySelector('span').textContent : '';
        }

        // Only show the modal once per task reaching overdue: use localStorage key 'overdueModalShown:<id>'
        const storageKey = todoId ? `overdueModalShown:${todoId}` : null;
        if (storageKey && localStorage.getItem(storageKey)) {
            // Already shown before for this task  don't show again
            return;
        }

        // Use a structured message regardless of the `text` param for clarity
        messageEl.innerHTML = `
            <div class="modal-message-main"><span class="modal-task-name">${escapeHtml(taskName)}</span> planned time is completed</div>
            <div style="margin-top:8px; font-size:0.95em;">Mark complete OR continue working on overdue task?</div>
        `;
        modal.style.display = 'flex';
    console.log('DEBUG: showOverduePrompt opened modal for', todoId, 'taskName:', taskName);
        // Unbind previous handlers by cloning
        const markClone = markBtn.cloneNode(true);
        markBtn.parentNode.replaceChild(markClone, markBtn);
        const contClone = contBtn.cloneNode(true);
        contBtn.parentNode.replaceChild(contClone, contBtn);

        // Re-acquire refs
        const mark = document.getElementById('modal-mark-complete');
        const cont = document.getElementById('modal-continue');

    mark.addEventListener('click', () => {
            modal.style.display = 'none';
            if (!todoId) return;
            // mark modal as shown for this task so it won't reappear on refresh or restore
            try { if (todoId) localStorage.setItem(`overdueModalShown:${todoId}`, '1'); } catch(e) {}
            fetch('/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: todoId }),
            })
                        .then(res => res.json())
                    .then(data => {
                        const li = document.querySelector(`li[data-id='${todoId}']`);
                        if (li) {
                            const doneIcon = li.querySelector('.done-button i');
                            // remove any overdue visual styling from completed tasks
                            li.classList.remove('overdue');
                            li.classList.add('completed');
                            if (doneIcon) { doneIcon.classList.remove('fa-check'); doneIcon.classList.add('fa-undo'); }
                            // Prepend so most-recent completed task appears at top
                            if (completedList.firstChild) completedList.insertBefore(li, completedList.firstChild);
                            else completedList.appendChild(li);
                            try { sendNotification('Task completed', `${taskName}  marked complete`, 'complete'); } catch(e){}
                            const wasOverdue = li.dataset.wasOverdue || li.getAttribute('data-was-overdue');
                            if (wasOverdue && parseInt(wasOverdue) === 1) {
                                addOverdueBadge(li);
                                // Move any displayed overdue-extra (live overdue time) to the completed-overdue-text
                                // so it appears on a new line under the title immediately.
                                const extra = li.querySelector('.overdue-extra');
                                if (extra) {
                                    // create/replace completed-overdue-text with the same content but insert inside .task-left
                                    const prev = li.querySelector('.completed-overdue-text');
                                    if (prev) prev.remove();
                                    const text = document.createElement('div');
                                    text.classList.add('completed-overdue-text');
                                    text.textContent = extra.textContent.replace('Overdue time:', 'Overdue:');
                                    text.style.marginTop = '6px';
                                    text.style.color = 'rgba(255,82,82,0.95)';
                                    // ensure .task-left exists and insert after the title span
                                    let container = li.querySelector('.task-left');
                                    if (!container) {
                                        const currentSpan = li.querySelector('span');
                                        if (currentSpan) {
                                            const wrapper = document.createElement('div');
                                            wrapper.classList.add('task-left');
                                            wrapper.appendChild(currentSpan.cloneNode(true));
                                            currentSpan.remove();
                                            li.insertBefore(wrapper, li.firstChild);
                                            container = wrapper;
                                        }
                                    }
                                    if (container) {
                                        const titleSpan = container.querySelector('span');
                                        if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                                        else container.appendChild(text);
                                    } else {
                                        li.appendChild(text);
                                    }
                                    // remove live extra to avoid duplication
                                    extra.remove();
                                } else {
                                    ensureCompletedOverdueIndicator(li);
                                }
                            }
                            // clear the notified flag, baseline and any continue flag
                            if (li.dataset.overdueNotified) delete li.dataset.overdueNotified;
                            if (li.dataset.overdueBaseline) delete li.dataset.overdueBaseline;
                            if (li.dataset.overdueInContinue) delete li.dataset.overdueInContinue;
                            hidePomodoroTimer();
                        }
                    });
        });

        cont.addEventListener('click', () => {
            modal.style.display = 'none';
            // mark modal as shown so it won't reappear on refresh
            try { if (todoId) localStorage.setItem(`overdueModalShown:${todoId}`, '1'); } catch(e) {}
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li && !li.dataset.overdueBaseline) {
                const dh = parseInt(li.dataset.durationHours) || 0;
                const dm = parseInt(li.dataset.durationMinutes) || 0;
                li.dataset.overdueBaseline = (dh * 3600) + (dm * 60);
            }
            // mark that the user chose to continue working if they later start a Pomodoro
            if (li) li.dataset.overdueInContinue = 1;
            // Do NOT start timers here. The actual focus session should begin only when the user
            // opens the Pomodoro and presses Start for this task (or presses the Play button on the task).
            // Leaving timers stopped avoids the overdue counter incrementing before the user actively starts.
        });
    }

    function addOverdueBadge(li) {
        if (!li) return;
        // ensure no duplicate badge
        let badge = li.querySelector('.overdue-badge');
        if (!badge) {
            const span = li.querySelector('span');
            badge = document.createElement('span');
            badge.classList.add('overdue-badge');
            badge.textContent = '';
            badge.title = 'This task was completed overdue';
            span.appendChild(badge);
        }
    }

    // For completed tasks, add a subtle overdue indicator (text) beneath the task name
    function ensureCompletedOverdueIndicator(li) {
        if (!li) return;
        // remove any overdue class that may add a red border
        li.classList.remove('overdue');
        // remove previous indicator to avoid duplicates
        const prev = li.querySelector('.completed-overdue-text');
        if (prev) prev.remove();
        // Remove any live session-only overtime element
        const liveExtra = li.querySelector('.overdue-extra'); if (liveExtra) liveExtra.remove();

        const overdueSeconds = parseInt(li.dataset.overdueTime) || 0;
        if (overdueSeconds > 0) {
            const text = document.createElement('div');
            text.classList.add('completed-overdue-text');
            text.textContent = `Overdue: ${formatDuration(overdueSeconds)}`;
            text.style.marginTop = '6px';
            text.style.color = 'rgba(255,82,82,0.95)';
            // Prefer to insert inside the .task-left wrapper immediately after the title span
            let container = li.querySelector('.task-left');
            if (!container) {
                // migrate existing single span into a .task-left wrapper
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                // remove any old completed-overdue-text inside container to avoid ordering issues
                const prevInside = container.querySelector('.completed-overdue-text'); if (prevInside) prevInside.remove();
                // insert after the title span
                const titleSpan = container.querySelector('span');
                if (titleSpan) {
                    titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                } else {
                    container.appendChild(text);
                }
            } else {
                // fallback: append to li so it appears on its own line
                li.appendChild(text);
            }
        }
    }

    // --- Browser notifications + sound helpers ---
    function playSound(soundType) {
        let soundFile = '';
        if (soundType === 'break') {
            soundFile = '/static/sounds/Break timer start.wav';
        } else if (soundType === 'start') {
            soundFile = '/static/sounds/Focus timer start.wav';
        } else if (soundType === 'complete') {
            soundFile = '/static/sounds/progress bar full.wav';
        }

        if (soundFile) {
            const audio = new Audio(soundFile);
            audio.play().catch(e => console.log('Audio play failed', e));
        }
    }

    function ensureNotificationPermission() {
        if (!('Notification' in window)) return Promise.resolve(false);
        if (Notification.permission === 'granted') return Promise.resolve(true);
        if (Notification.permission === 'denied') return Promise.resolve(false);
        return Notification.requestPermission().then(p => p === 'granted');
    }

    function sendNotification(title, body, soundType) {
        ensureNotificationPermission().then(ok => {
            if (!ok) return;
            try {
                const n = new Notification(title, { body });
                // play a short sound for the notification
                try { playSound(soundType); } catch(e) { console.log('playSound failed', e); }
                // close after a few seconds
                setTimeout(() => { try { n.close(); } catch(e) {} }, 5000);
            } catch (e) {
                console.log('Notification failed', e);
            }
        });
    }

    // For completed tasks, add a label below title:
    // - If task was marked completed BEFORE reaching full planned progress => 'Underdue task' (yellow)
    // - If task reached planned progress (no overdue) => 'Completed task' (green)
    function ensureCompletedStatusIndicator(li) {
        if (!li) return;
        // remove any previous status indicators
        const prevOverdue = li.querySelector('.completed-overdue-text'); if (prevOverdue) prevOverdue.remove();
        const prevUnderdue = li.querySelector('.completed-underdue-text'); if (prevUnderdue) prevUnderdue.remove();
        const prevComplete = li.querySelector('.completed-complete-text'); if (prevComplete) prevComplete.remove();

        // compute whether task was completed before planned duration or after
        const focused = parseInt(li.dataset.focusedTime) || 0;
        const overdue = parseInt(li.dataset.overdueTime) || 0;
        const dh = parseInt(li.dataset.durationHours) || 0;
        const dm = parseInt(li.dataset.durationMinutes) || 0;
        const total = (dh * 3600) + (dm * 60);

        // If there is overdue time, show overdue indicator (handled by ensureCompletedOverdueIndicator)
        if (overdue > 0) {
            ensureCompletedOverdueIndicator(li);
            return;
        }

        // If no planned duration, do nothing
        if (total <= 0) return;

        // If focusedTime < total when marked complete => underdue
        if (focused < total) {
            const text = document.createElement('div');
            text.classList.add('completed-underdue-text');
            text.textContent = 'Underdue task';
            // Prefer inserting inside .task-left under the title span
            let container = li.querySelector('.task-left');
            if (!container) {
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                // insert after the title span inside the wrapper
                const titleSpan = container.querySelector('span');
                if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                else container.appendChild(text);
            } else {
                li.appendChild(text);
            }
            return;
        }

        // If reached planned duration and no overdue => Completed task
        if (focused >= total && overdue === 0) {
            const text = document.createElement('div');
            text.classList.add('completed-complete-text');
            text.textContent = 'Completed task';
            let container = li.querySelector('.task-left');
            if (!container) {
                const currentSpan = li.querySelector('span');
                if (currentSpan) {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('task-left');
                    wrapper.appendChild(currentSpan.cloneNode(true));
                    currentSpan.remove();
                    li.insertBefore(wrapper, li.firstChild);
                    container = wrapper;
                }
            }
            if (container) {
                const titleSpan = container.querySelector('span');
                if (titleSpan) titleSpan.parentNode.insertBefore(text, titleSpan.nextSibling);
                else container.appendChild(text);
            } else {
                li.appendChild(text);
            }
            return;
        }
    }

    function startFocusTimer() {
        focusSessionStartTime = Date.now();
        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (li) {
            lastFocusedTime = parseInt(li.dataset.focusedTime) || 0;
            // clear any transient crossed flag when user actively starts a session
            try { if (li.dataset.overdueCrossed) { delete li.dataset.overdueCrossed; console.log('DEBUG: startFocusTimer cleared overdueCrossed for', currentRunningTaskId); } } catch (e) {}
            console.log('DEBUG: startFocusTimer - task', currentRunningTaskId, 'lastFocusedTime(dataset):', li.dataset.focusedTime, 'lastFocusedTime(var):', lastFocusedTime, 'focusSessionStartTime:', focusSessionStartTime);
        }
    }

    function stopFocusTimer() {
        if (focusSessionStartTime === 0) return;

        const elapsedSeconds = Math.floor((Date.now() - focusSessionStartTime) / 1000);
        focusSessionStartTime = 0; // Reset start time BEFORE calculating new focused time
        lastSessionIncrement = elapsedSeconds;
        const li = document.querySelector(`li[data-id='${currentRunningTaskId}']`);
        if (li) {
            try { li.dataset.processing = 1; console.log('DEBUG: stopFocusTimer set processing for', li.dataset.id); } catch (e) { /* ignore */ }
            const newFocusedTime = lastFocusedTime + elapsedSeconds;
            const CLAMP_MAX = 24 * 3600; // 1 day
            const clampedFocusedTime = Math.min(newFocusedTime, CLAMP_MAX);
            console.log('DEBUG: stopFocusTimer - elapsedSeconds:', elapsedSeconds, 'newFocusedTime:', newFocusedTime, 'clamped:', clampedFocusedTime);
            li.dataset.focusedTime = clampedFocusedTime;
            updateFocusTimeOnServer(currentRunningTaskId, clampedFocusedTime);
            lastFocusedTime = newFocusedTime;
            updateProgressBar(currentRunningTaskId);
        }
    }

    function updateFocusTimeOnServer(todoId, focusedTime) {
        fetch('/update_focus_time', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: todoId, focused_time: focusedTime }),
        })
        .then(resp => resp.json())
        .then(data => {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (li && typeof data.was_overdue !== 'undefined') {
                li.dataset.wasOverdue = data.was_overdue;
                if (data.was_overdue == 1 && !li.classList.contains('completed')) {
                    li.classList.add('overdue');
                }
                // Always ensure overdueTime is set (default 0)
                const reportedOverdue = parseInt(data.overdue_time) || 0;
                li.dataset.overdueTime = reportedOverdue;
                // if the server reports an overdue_time, set baseline so UI shows extra as only post-baseline
                const durationSeconds = (parseInt(li.dataset.durationHours) || 0) * 3600 + (parseInt(li.dataset.durationMinutes) || 0) * 60;
                if (reportedOverdue > 0) {
                    li.dataset.overdueBaseline = durationSeconds; // baseline is planned duration
                }
                // Sync normalized focused_time sent back by server
                if (typeof data.focused_time !== 'undefined') {
                    const norm = parseInt(data.focused_time) || 0;
                    li.dataset.focusedTime = norm;
                    // also update lastFocusedTime so subsequent session adds are correct
                    lastFocusedTime = norm;
                }
                // clear any temporary processing flag now that server responded
                try { delete li.dataset.processing; console.log('DEBUG: updateFocusTimeOnServer cleared processing for', todoId); } catch (e) {}
            }
        });
        // Fallback: clear processing after 1.5s in case server is slow or network fails
        setTimeout(() => {
            try { const li = document.querySelector(`li[data-id='${todoId}']`); if (li && li.dataset && li.dataset.processing) { delete li.dataset.processing; console.log('DEBUG: updateFocusTimeOnServer fallback cleared processing for', todoId); } } catch (e) {}
        }, 1500);
    }

        // Centralized handler to pause/stop timers and show the overdue prompt for a task.
        // Placed in module scope so it is callable from the global checker and other places.
        function triggerOverdueForTaskLocal(todoId, baselineSeconds) {
            const li = document.querySelector(`li[data-id='${todoId}']`);
            if (!li) return;
            if (li.dataset.overdueNotified) return;
            // mark processing so global checker skips this item while we handle overdue
            try { li.dataset.processing = 1; console.log('DEBUG: triggerOverdueForTask set processing for', todoId); } catch (e) { /* ignore */ }
            li.dataset.overdueNotified = 1;
            if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = baselineSeconds || (parseInt(li.dataset.durationHours || 0) * 3600) + (parseInt(li.dataset.durationMinutes || 0) * 60);
            console.log('DEBUG: triggerOverdueForTask - pausing timers and showing modal for', todoId);
            try {
                // Pause UI timers and clear intervals
                pauseTimer();
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask pauseTimer failed', e);
            }
            try {
                // Ensure any active focus session is stopped and persisted
                stopFocusTimer();
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask stopFocusTimer failed', e);
            }
            // Also hide the Pomodoro UI without resetting internal pomodoro state
            try {
                if (pomodoroContainer) pomodoroContainer.style.display = 'none';
                if (todoContainer) todoContainer.classList.remove('pomodoro-active');
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask hide UI failed', e);
            }
            // ensure processing flag is cleared after a short grace period in case server doesn't respond
            setTimeout(() => {
                try { delete li.dataset.processing; console.log('DEBUG: triggerOverdueForTask cleared processing for', todoId); } catch (e) {}
            }, 800);
            // Decide whether to actually show the modal: require the rendered progress bar to be full
            try {
                const pb = li.querySelector('.progress-bar');
                let renderedPct = 0;
                if (pb && pb.style && pb.style.width && pb.style.width.endsWith('%')) {
                    renderedPct = parseFloat(pb.style.width.replace('%','')) || 0;
                } else {
                    const dh = parseInt(li.dataset.durationHours) || 0;
                    const dm = parseInt(li.dataset.durationMinutes) || 0;
                    const total = (dh * 3600) + (dm * 60);
                    const ft = parseInt(li.dataset.focusedTime) || 0;
                    renderedPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                }
                const isActiveRunning = (focusSessionStartTime > 0 && currentRunningTaskId === todoId && timerState === 'running' && currentMode === 'focus');
                console.log('DEBUG: triggerOverdueForTask renderedPct for', todoId, renderedPct, 'isActiveRunning:', isActiveRunning);
                if (renderedPct < 100 && !isActiveRunning) {
                    // Not visually full yet  mark crossed and defer showing modal to global checker once UI stabilizes
                    try { li.dataset.overdueCrossed = 1; } catch (e) {}
                    // clear processing flag we set earlier since we're not showing modal now
                    try { delete li.dataset.processing; } catch (e) {}
                    console.log('DEBUG: triggerOverdueForTask deferred modal for', todoId, 'renderedPct:', renderedPct);
                } else {
                    // Finally show modal to let the user choose
                    showOverduePrompt(todoId, 'Planned time reached  mark complete or continue working on overdue task?');
                }
            } catch (e) {
                console.log('DEBUG: triggerOverdueForTask modal decision error', e);
                showOverduePrompt(todoId, 'Planned time reached  mark complete or continue working on overdue task?');
            }
        }

    // Initial progress bar update and restore overdue state from dataset
    // Ensure completed-list shows newest-first by sorting existing items by data-id descending
    const completedItemsInitial = Array.from(document.querySelectorAll('#completed-list li'));
    if (completedItemsInitial.length > 1) {
        completedItemsInitial.sort((a, b) => parseInt(b.dataset.id) - parseInt(a.dataset.id));
        const completedListEl = document.getElementById('completed-list');
        completedItemsInitial.forEach(item => completedListEl.appendChild(item));
    }

    // Note: callers use triggerOverdueForTaskLocal directly.

    document.querySelectorAll('#todo-list li, #completed-list li').forEach(li => {
        // set overdue class from data-was-overdue (templates render this attribute)
        const wasOverdue = li.dataset.wasOverdue || li.dataset.was_overdue || li.getAttribute('data-was-overdue');
        if (wasOverdue && parseInt(wasOverdue) === 1 && !li.classList.contains('completed')) {
            li.classList.add('overdue');
        }
        // For completed tasks, ensure overdue text is placed under title (no red border)
        if (li.classList.contains('completed')) {
            // ensure left column wrapper exists  migrate simple span into task-left if needed
            const currentSpan = li.querySelector('span');
            if (currentSpan && !li.querySelector('.task-left')) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('task-left');
                wrapper.appendChild(currentSpan.cloneNode(true));
                // replace original span with wrapper
                currentSpan.remove();
                li.insertBefore(wrapper, li.firstChild);
            }
            // Show the appropriate completed label (overdue / underdue / completed)
            if (parseInt(li.dataset.overdueTime) > 0 || parseInt(li.dataset.wasOverdue) === 1) {
                ensureCompletedOverdueIndicator(li);
            } else {
                ensureCompletedStatusIndicator(li);
            }
        }
        updateProgressBar(li.dataset.id);
    });

    // Start a global progress checker so overdue modal appears even if user didn't press play
    if (!globalProgressCheckerInterval) {
        globalProgressCheckerInterval = setInterval(() => {
            document.querySelectorAll('#todo-list li').forEach(li => {
                // If this li is in processing state (just persisted by client/server sync), skip to avoid race
                if (li.dataset.processing) {
                    // short debug trace
                    console.log('DEBUG: global checker skipping processing li', li.dataset.id);
                    return;
                }
                const id = li.dataset.id;
                try {
                    const ft = parseInt(li.dataset.focusedTime) || 0;
                    const dh = parseInt(li.dataset.durationHours) || 0;
                    const dm = parseInt(li.dataset.durationMinutes) || 0;
                    const total = (dh * 3600) + (dm * 60);
                    const pct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                    if (pct >= 90) console.log('DEBUG: global checker', id, 'focusedTime:', ft, 'total:', total, 'pct:', pct);

                    // Update UI progress
                    updateProgressBar(id);

                    // Use the actual rendered progress bar width when available to decide if UI is truly at 100%.
                    let progressPct = 0;
                    try {
                        const pb = li.querySelector('.progress-bar');
                        if (pb && pb.style && pb.style.width && pb.style.width.endsWith('%')) {
                            progressPct = parseFloat(pb.style.width.replace('%','')) || 0;
                        } else {
                            progressPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                        }
                    } catch (e) {
                        progressPct = total > 0 ? Math.min((ft / total) * 100, 100) : 0;
                    }

                    // Force show modal only when rendered progress is 100% AND:
                    // - server reports overdue (li.dataset.overdueTime > 0), OR
                    // - this is an active running focus session (we're over while running), OR
                    // - we previously marked it as crossed (deferred handling)
                    if (total > 0 && progressPct >= 100 && !li.classList.contains('completed') && !li.dataset.overdueNotified) {
                        const persistedOverdue = parseInt(li.dataset.overdueTime) || 0;
                        console.log('DEBUG: global checker found progressPct >= 100 for', id, 'pct:', progressPct, 'persistedOverdue:', persistedOverdue, 'processing:', !!li.dataset.processing);

                        // If there's no server-reported overdue and the task is not actively running,
                        // it's likely a small persisted overage or race; skip triggering until real activity.
                        const isActiveRunning = (currentRunningTaskId && currentRunningTaskId === id && timerState === 'running' && currentMode === 'focus');
                        const wasCrossed = !!li.dataset.overdueCrossed;

                        if (!isActiveRunning && persistedOverdue === 0 && !wasCrossed) {
                            console.log('DEBUG: global checker skipping trigger for', id, ' no server-overdue and not actively running');
                            // set baseline so future checks know the planned time
                            if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = total;
                            return;
                        }

                        console.log('DEBUG: global checker triggering overdue handler for', id, 'isActiveRunning:', isActiveRunning, 'wasCrossed:', wasCrossed);
                        if (!li.dataset.overdueBaseline) li.dataset.overdueBaseline = total;
                        // If active running, defer to trigger handler to pause and show modal
                        triggerOverdueForTaskLocal(id, total);
                    }
                } catch (e) {
                    console.log('DEBUG: error reading li dataset', e);
                }
            });
        }, 1000);
    }

    // Clear on unload
    window.addEventListener('beforeunload', () => {
        if (globalProgressCheckerInterval) clearInterval(globalProgressCheckerInterval);
    });

    // Wire completed list toggle
    const completedToggle = document.getElementById('completed-toggle');
    const completedListEl = document.getElementById('completed-list');
    if (completedToggle && completedListEl) {
        completedToggle.addEventListener('click', () => {
            const expanded = completedToggle.getAttribute('aria-expanded') === 'true';
            if (expanded) {
                completedListEl.style.display = 'none';
                completedToggle.setAttribute('aria-expanded', 'false');
            } else {
                completedListEl.style.display = 'block';
                completedToggle.setAttribute('aria-expanded', 'true');
            }
        });
    }

    // Clear All completed tasks handler
    const clearCompletedBtn = document.getElementById('clear-completed-button');
    if (clearCompletedBtn) {
        clearCompletedBtn.addEventListener('click', () => {
            const completedItems = Array.from(document.querySelectorAll('#completed-list li'));
            if (completedItems.length === 0) return;
            // Confirm destructive action
            if (!confirm(`Clear ${completedItems.length} completed task(s)? This cannot be undone.`)) return;

            // Optimistically remove from UI and issue delete requests
            completedItems.forEach(li => {
                const id = li.dataset.id;
                // Remove from DOM immediately for responsiveness
                li.remove();
                // Call server to delete
                fetch('/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id }),
                })
                .then(res => res.json())
                .then(data => {
                    if (!data || data.result !== 'success') {
                        console.log('DEBUG: failed to delete completed todo', id, data);
                        // On failure, we could refresh the page to reconcile, but keep simple for now
                    }
                })
                .catch(err => console.log('DEBUG: error deleting completed todo', id, err));
            });
        });
    }

    // Debug helpers: expose functions so user can force-check overdue and open modal from console
    window.forceCheckOverdue = function() {
        console.log('DEBUG: forceCheckOverdue called');
        document.querySelectorAll('#todo-list li').forEach(li => updateProgressBar(li.dataset.id));
    };

    window.showModalFor = function(id) {
        console.log('DEBUG: showModalFor', id);
        showOverduePrompt(id, 'Test: Planned time reached  mark complete or continue?');
    };

    // Test helper: reset a task's focused time to zero (client + server) for clean reproduction
    window.resetTaskProgress = function(id) {
        try {
            const li = document.querySelector(`li[data-id='${id}']`);
            if (li) {
                li.dataset.focusedTime = 0;
                li.dataset.overdueTime = 0;
                li.dataset.wasOverdue = 0;
                li.classList.remove('overdue');
                updateProgressBar(id);
            }
            // Also ask server to reset
            fetch('/update_focus_time', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: id, focused_time: 0 }) })
            .then(r => r.json()).then(() => { console.log('DEBUG: resetTaskProgress server responded for', id); }).catch(e => console.log('DEBUG: resetTaskProgress server error', e));
        } catch (e) { console.log('DEBUG: resetTaskProgress failed', e); }
    };
});
</file>

<file path="flutter_app/lib/models/task_timer_state.dart">
class TaskTimerState {
  final String? taskId;
  final String timerState; // 'paused'|'running'
  final String currentMode; // 'focus'|'break'
  final int? timeRemaining;
  final int? totalCycles;
  final int currentCycle;
  final int lastFocusedTime;
  final int? focusDuration;
  final int? breakDuration;
  // New session tracking fields
  final int completedSessions;
  final bool isProgressBarFull;
  final bool allSessionsComplete;

  TaskTimerState({
    this.taskId,
    this.timerState = 'paused',
    this.currentMode = 'focus',
    this.timeRemaining,
    this.totalCycles,
    this.currentCycle = 0,
    this.lastFocusedTime = 0,
    this.focusDuration,
    this.breakDuration,
    this.completedSessions = 0,
    this.isProgressBarFull = false,
    this.allSessionsComplete = false,
  });

  Map<String, dynamic> toJson() {
    return {
      'taskId': taskId,
      'timerState': timerState,
      'currentMode': currentMode,
      'timeRemaining': timeRemaining,
      'totalCycles': totalCycles,
      'currentCycle': currentCycle,
      'lastFocusedTime': lastFocusedTime,
      'focusDuration': focusDuration,
      'breakDuration': breakDuration,
      'completedSessions': completedSessions,
      'isProgressBarFull': isProgressBarFull,
      'allSessionsComplete': allSessionsComplete,
    };
  }

  factory TaskTimerState.fromJson(Map<String, dynamic> j) {
    return TaskTimerState(
      taskId: j['taskId'],
      timerState: j['timerState'] ?? 'paused',
      currentMode: j['currentMode'] ?? 'focus',
      timeRemaining: j['timeRemaining'],
      totalCycles: j['totalCycles'],
      currentCycle: j['currentCycle'] ?? 0,
      lastFocusedTime: j['lastFocusedTime'] ?? 0,
      focusDuration: j['focusDuration'],
      breakDuration: j['breakDuration'],
      completedSessions: j['completedSessions'] ?? 0,
      isProgressBarFull: j['isProgressBarFull'] ?? false,
      allSessionsComplete: j['allSessionsComplete'] ?? false,
    );
  }
}
</file>

<file path="flutter_app/lib/screens/login_screen.dart">
import 'package:flutter/material.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';

class LoginScreen extends StatefulWidget {
  final ApiService api;
  final AuthService auth;
  const LoginScreen({required this.api, required this.auth, super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  bool _isSigningIn = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Center(
        child: _isSigningIn
            ? const CircularProgressIndicator()
            : ElevatedButton.icon(
                icon: const Icon(Icons.login),
                label: const Text('Sign in with Google'),
                onPressed: () async {
                  setState(() {
                    _isSigningIn = true;
                  });
                  final success = await widget.auth.signInWithGoogle();
                  if (!mounted) return;
                  if (success) {
                    Navigator.of(context).pushReplacementNamed('/todos');
                  } else {
                    setState(() {
                      _isSigningIn = false;
                    });
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text(
                          'Google Sign-In failed. Please try again.',
                        ),
                      ),
                    );
                  }
                },
              ),
      ),
    );
  }
}
</file>

<file path="flutter_app/lib/services/auth_service.dart">
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'api_service.dart';

class AuthService {
  final FlutterSecureStorage _secure = const FlutterSecureStorage();
  final ApiService api;
  final GoogleSignIn _googleSignIn = GoogleSignIn.instance;

  AuthService(this.api);

  Future<bool> signInWithGoogle() async {
    try {
      final GoogleSignInAccount account = await _googleSignIn.authenticate();
      final GoogleSignInAuthentication auth = account.authentication;
      if (auth.idToken == null) {
        return false;
      }
      return await signInWithIdToken(auth.idToken!);
    } catch (error) {
      if (kDebugMode) debugPrint("Google Sign-In error: $error");
      return false;
    }
  }

  Future<bool> signInWithIdToken(String idToken) async {
    final resp = await api.authWithIdToken(idToken);
    final token = resp['token'];
    if (token != null) {
      await _secure.write(key: 'server_token', value: token);
      api.setAuthToken(token);
      return true;
    }
    return false;
  }

  Future<void> signOut() async {
    await _googleSignIn.signOut();
    await _secure.delete(key: 'server_token');
    api.setAuthToken(null);
  }

  Future<void> loadSavedToken() async {
    // Ensure GoogleSignIn is initialized before any authenticate/signIn calls.
    await _googleSignIn.initialize();
    final t = await _secure.read(key: 'server_token');
    if (t != null) api.setAuthToken(t);
  }
}
</file>

<file path="flutter_app/lib/services/pomodoro_controller.dart">
import 'dart:async';

import 'package:flutter/foundation.dart';

enum PomodoroMode { focus, breakMode }

/// A lightweight Pomodoro controller. Designed to be UI-agnostic and testable.
class PomodoroController extends ChangeNotifier {
  // Public state
  int activeTaskId = -1;
  PomodoroMode mode = PomodoroMode.focus;
  bool isRunning = false;
  int timeRemaining = 0; // seconds
  int currentCycle = 1;
  int totalCycles = 4;

  // Durations (seconds)
  int focusDuration = 25 * 60;
  int breakDuration = 5 * 60;

  // Planned duration and server-known focused time (seconds)
  int plannedDurationSeconds = 0;
  int _serverKnownFocusedSeconds = 0;

  // Callbacks consumers can attach
  /// Called when a focus segment completes (or is paused) with number of seconds to add.
  void Function(int taskId, int addedSeconds)? onFocusSegmentComplete;

  /// Called when a task becomes overdue (total focused >= plannedDurationSeconds)
  void Function(int taskId)? onOverdue;

  /// Called on session transitions (focus->break, break->focus)
  void Function(PomodoroMode newMode)? onSessionTransition;

  Timer? _ticker;
  DateTime? _focusStart;
  // previously used for run-accumulation; removed to satisfy analyzer

  PomodoroController();

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  void _startTicker() {
    if (_ticker != null) return;
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
  }

  void _stopTicker() {
    _ticker?.cancel();
    _ticker = null;
  }

  void _tick() {
    if (!isRunning) return;
    timeRemaining = (timeRemaining - 1).clamp(0, 24 * 3600);
    notifyListeners();
    if (timeRemaining <= 0) {
      // session ended
      if (mode == PomodoroMode.focus) {
        _handleFocusEnd(fullSession: true);
      } else {
        _handleBreakEnd();
      }
    }
  }

  /// Start or resume a Pomodoro session for a task.
  /// [initialFocusedSeconds] is the current focused_time known on server so we can detect overdue correctly.
  void start(
    int taskId, {
    int? focusSec,
    int? breakSec,
    int? cycles,
    int plannedDurationSec = 0,
    int initialFocusedSeconds = 0,
  }) {
    // If switching tasks, reset run-accumulators
    if (activeTaskId != taskId) {
      currentCycle = 1;
      mode = PomodoroMode.focus;
    }
    activeTaskId = taskId;
    focusDuration = focusSec ?? focusDuration;
    breakDuration = breakSec ?? breakDuration;
    totalCycles = cycles ?? totalCycles;
    plannedDurationSeconds = plannedDurationSec;
    _serverKnownFocusedSeconds = initialFocusedSeconds;

    if (mode == PomodoroMode.focus) {
      timeRemaining = timeRemaining > 0 ? timeRemaining : focusDuration;
      _focusStart ??= DateTime.now();
    } else {
      timeRemaining = timeRemaining > 0 ? timeRemaining : breakDuration;
    }

    isRunning = true;
    _startTicker();
    notifyListeners();
  }

  /// Pause the timer and flush any partial focus seconds
  Future<void> pause() async {
    if (!isRunning) return;
    isRunning = false;
    _stopTicker();
    // If we were in focus mode, compute elapsed since _focusStart
    if (mode == PomodoroMode.focus && _focusStart != null) {
      final elapsed = DateTime.now().difference(_focusStart!).inSeconds;
      final added = elapsed.clamp(0, focusDuration - (timeRemaining));
      if (added > 0) {
        _serverKnownFocusedSeconds += added;
        onFocusSegmentComplete?.call(activeTaskId, added);
        // Overdue detection
        if (plannedDurationSeconds > 0 &&
            _serverKnownFocusedSeconds >= plannedDurationSeconds) {
          onOverdue?.call(activeTaskId);
        }
      }
    }
    _focusStart = null;
    notifyListeners();
  }

  void _handleFocusEnd({bool fullSession = false}) {
    // compute added seconds: if fullSession true we add the remaining focusDuration,
    // else compute from _focusStart
    int added = 0;
    if (fullSession) {
      added = focusDuration - (timeRemaining < 0 ? 0 : 0);
      // safer: assume full focusDuration elapsed
      added = focusDuration;
    } else if (_focusStart != null) {
      added = DateTime.now().difference(_focusStart!).inSeconds;
    }
    added = added.clamp(0, focusDuration);
    _serverKnownFocusedSeconds += added;
    onFocusSegmentComplete?.call(activeTaskId, added);

    // Check overdue
    if (plannedDurationSeconds > 0 &&
        _serverKnownFocusedSeconds >= plannedDurationSeconds) {
      onOverdue?.call(activeTaskId);
    }

    // move to break
    mode = PomodoroMode.breakMode;
    timeRemaining = breakDuration;
    _focusStart = null;
    notifyListeners();
    onSessionTransition?.call(mode);
  }

  void _handleBreakEnd() {
    // finished a break, move to next cycle
    currentCycle = (currentCycle + 1).clamp(1, totalCycles);
    mode = PomodoroMode.focus;
    timeRemaining = focusDuration;
    _focusStart = DateTime.now();
    notifyListeners();
    onSessionTransition?.call(mode);
    // If we've reached total cycles, stop
    if (currentCycle > totalCycles) {
      // finalize
      isRunning = false;
      _stopTicker();
      notifyListeners();
    }
  }

  /// Skip the current session and start the next
  Future<void> skip() async {
    if (mode == PomodoroMode.focus) {
      // flush partial focus seconds (computed by elapsed)
      if (_focusStart != null) {
        final elapsed = DateTime.now().difference(_focusStart!).inSeconds;
        final added = elapsed.clamp(0, focusDuration - (timeRemaining));
        if (added > 0) {
          _serverKnownFocusedSeconds += added;
          onFocusSegmentComplete?.call(activeTaskId, added);
          if (plannedDurationSeconds > 0 &&
              _serverKnownFocusedSeconds >= plannedDurationSeconds) {
            onOverdue?.call(activeTaskId);
          }
        }
      }
      // switch to break
      mode = PomodoroMode.breakMode;
      timeRemaining = breakDuration;
      _focusStart = null;
      // Auto-start next session
      isRunning = true;
      _startTicker();
      notifyListeners();
      onSessionTransition?.call(mode);
    } else {
      // skip break -> focus
      mode = PomodoroMode.focus;
      timeRemaining = focusDuration;
      _focusStart = DateTime.now();
      // Auto-start next session
      isRunning = true;
      _startTicker();
      notifyListeners();
      onSessionTransition?.call(mode);
    }
  }

  /// Reset the current run: stop timer and set timeRemaining back to focus duration.
  /// Returns the number of seconds that were part of the partial focus (if any)  caller may subtract this from server value.
  int reset() {
    int partial = 0;
    if (mode == PomodoroMode.focus && _focusStart != null) {
      partial = DateTime.now().difference(_focusStart!).inSeconds;
      partial = partial.clamp(0, focusDuration);
    }
    isRunning = false;
    _stopTicker();
    mode = PomodoroMode.focus;
    timeRemaining = focusDuration;
    _focusStart = null;
    // reset any partial-run accumulation (no-op without accumulator)
    notifyListeners();
    return partial;
  }
}
</file>

<file path="flutter_app/lib/widgets/progress_bar.dart">
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import '../theme/app_colors.dart';

class ProgressBar extends StatelessWidget {
  final int focusedSeconds;
  final int plannedSeconds;
  final double barHeight;

  const ProgressBar({
    required this.focusedSeconds,
    required this.plannedSeconds,
    this.barHeight = 16.0, // Default height for standard progress bars
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final double progress = (plannedSeconds <= 0)
        ? 0.0
        : (focusedSeconds / plannedSeconds).clamp(0.0, 1.0);
    if (kDebugMode) {
      debugPrint(
        'PROGRESS_BAR: focused=$focusedSeconds planned=$plannedSeconds progress=$progress',
      );
    }
    final fillColor = AppColors.brightYellow; // Always use yellow as requested
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 1.0, // Corrected from 16.0 to fit within parent SizedBox
        horizontal: 8.0,
      ), // Increased padding
      child: LayoutBuilder(
        builder: (ctx, constraints) {
          final width = constraints.maxWidth;
          final progressWidth = width * progress;
          if (kDebugMode) {
            debugPrint(
              'PROGRESS_BAR_UI: maxWidth=$width, progress=$progress, calculatedWidth=$progressWidth, maxHeight=${constraints.maxHeight}',
            );
          }
          // Determine text color based on progress for better visibility
          final textColor = progress > 0.5
              ? Colors.black
              : Colors.white.withAlpha((255 * 0.9).round());

          return Stack(
            children: [
              Container(
                width: width,
                height: barHeight,
                decoration: BoxDecoration(
                  color:
                      Colors.grey[900], // Darker background for better contrast
                  borderRadius: BorderRadius.circular(barHeight),
                ),
              ),
              AnimatedContainer(
                duration: const Duration(milliseconds: 400),
                width: progressWidth,
                height: barHeight,
                decoration: BoxDecoration(
                  color: fillColor,
                  borderRadius: BorderRadius.circular(barHeight),
                  boxShadow: [
                    BoxShadow(
                      color: fillColor.withAlpha((255 * 0.18).round()),
                      blurRadius: 8,
                      spreadRadius: 0.5,
                    ),
                  ],
                ),
              ),
              if (kDebugMode)
                Positioned.fill(
                  child: Align(
                    alignment: Alignment.center,
                    child: Text(
                      '${(progress * 100).toStringAsFixed(0)}%',
                      style: TextStyle(
                        color: textColor,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }
}
</file>

<file path="flutter_app/pubspec.lock">
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  audioplayers:
    dependency: "direct main"
    description:
      name: audioplayers
      sha256: e653f162ddfcec1da2040ba2d8553fff1662b5c2a5c636f4c21a3b11bee497de
      url: "https://pub.dev"
    source: hosted
    version: "6.5.0"
  audioplayers_android:
    dependency: transitive
    description:
      name: audioplayers_android
      sha256: "60a6728277228413a85755bd3ffd6fab98f6555608923813ce383b190a360605"
      url: "https://pub.dev"
    source: hosted
    version: "5.2.1"
  audioplayers_darwin:
    dependency: transitive
    description:
      name: audioplayers_darwin
      sha256: "0811d6924904ca13f9ef90d19081e4a87f7297ddc19fc3d31f60af1aaafee333"
      url: "https://pub.dev"
    source: hosted
    version: "6.3.0"
  audioplayers_linux:
    dependency: transitive
    description:
      name: audioplayers_linux
      sha256: f75bce1ce864170ef5e6a2c6a61cd3339e1a17ce11e99a25bae4474ea491d001
      url: "https://pub.dev"
    source: hosted
    version: "4.2.1"
  audioplayers_platform_interface:
    dependency: transitive
    description:
      name: audioplayers_platform_interface
      sha256: "0e2f6a919ab56d0fec272e801abc07b26ae7f31980f912f24af4748763e5a656"
      url: "https://pub.dev"
    source: hosted
    version: "7.1.1"
  audioplayers_web:
    dependency: transitive
    description:
      name: audioplayers_web
      sha256: "1c0f17cec68455556775f1e50ca85c40c05c714a99c5eb1d2d57cc17ba5522d7"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  audioplayers_windows:
    dependency: transitive
    description:
      name: audioplayers_windows
      sha256: "4048797865105b26d47628e6abb49231ea5de84884160229251f37dfcbe52fd7"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.1"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "79e0c23480ff85dc68de79e2cd6334add97e48f7f4865d17686dd6ea81a47e8c"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.11"
  dio:
    dependency: "direct main"
    description:
      name: dio
      sha256: d90ee57923d1828ac14e492ca49440f65477f4bb1263575900be731a3dac66a9
      url: "https://pub.dev"
    source: hosted
    version: "5.9.0"
  dio_web_adapter:
    dependency: transitive
    description:
      name: dio_web_adapter
      sha256: "7586e476d70caecaf1686d21eee7247ea43ef5c345eab9e0cc3583ff13378d78"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "289279317b4b16eb2bb7e271abccd4bf84ec9bdcbe999e278a94b804f5630418"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_local_notifications:
    dependency: "direct main"
    description:
      name: flutter_local_notifications
      sha256: "20ca0a9c82ce0c855ac62a2e580ab867f3fbea82680a90647f7953832d0850ae"
      url: "https://pub.dev"
    source: hosted
    version: "19.4.0"
  flutter_local_notifications_linux:
    dependency: transitive
    description:
      name: flutter_local_notifications_linux
      sha256: e3c277b2daab8e36ac5a6820536668d07e83851aeeb79c446e525a70710770a5
      url: "https://pub.dev"
    source: hosted
    version: "6.0.0"
  flutter_local_notifications_platform_interface:
    dependency: transitive
    description:
      name: flutter_local_notifications_platform_interface
      sha256: "277d25d960c15674ce78ca97f57d0bae2ee401c844b6ac80fcd972a9c99d09fe"
      url: "https://pub.dev"
    source: hosted
    version: "9.1.0"
  flutter_local_notifications_windows:
    dependency: transitive
    description:
      name: flutter_local_notifications_windows
      sha256: ed46d7ae4ec9d19e4c8fa2badac5fe27ba87a3fe387343ce726f927af074ec98
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  flutter_redux:
    dependency: "direct main"
    description:
      name: flutter_redux
      sha256: "3b20be9e08d0038e1452fbfa1fdb1ea0a7c3738c997734530b3c6d0bb5fcdbdc"
      url: "https://pub.dev"
    source: hosted
    version: "0.10.0"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: "9cad52d75ebc511adfae3d447d5d13da15a55a92c9410e50f67335b6d21d16ea"
      url: "https://pub.dev"
    source: hosted
    version: "9.2.4"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: be76c1d24a97d0b98f8b54bce6b481a380a6590df992d0098f868ad54dc8f688
      url: "https://pub.dev"
    source: hosted
    version: "1.2.3"
  flutter_secure_storage_macos:
    dependency: transitive
    description:
      name: flutter_secure_storage_macos
      sha256: "6c0a2795a2d1de26ae202a0d78527d163f4acbb11cde4c75c670f3a0fc064247"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: cf91ad32ce5adef6fba4d736a542baca9daf3beac4db2d04be350b87f69ac4a8
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: f4ebff989b4f07b2656fb16b47852c0aab9fed9b4ec1c70103368337bc1886a9
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: b20b07cb5ed4ed74fc567b78a72936203f587eba460af1df11281c9326cd3709
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  google_fonts:
    dependency: "direct main"
    description:
      name: google_fonts
      sha256: df9763500dadba0155373e9cb44e202ce21bd9ed5de6bdbd05c5854e86839cb8
      url: "https://pub.dev"
    source: hosted
    version: "6.3.0"
  google_identity_services_web:
    dependency: transitive
    description:
      name: google_identity_services_web
      sha256: "5d187c46dc59e02646e10fe82665fc3884a9b71bc1c90c2b8b749316d33ee454"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.3+1"
  google_sign_in:
    dependency: "direct main"
    description:
      name: google_sign_in
      sha256: dba1a1a79368d8ca464bf36ef94f528851efa9925e4a28bfc4aaefb1f5da2fc4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  google_sign_in_android:
    dependency: transitive
    description:
      name: google_sign_in_android
      sha256: f256b8f0e6c09d135c166fe20b25256e24d60fe1a72e6bdc112a200bd0d555b4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.3"
  google_sign_in_ios:
    dependency: transitive
    description:
      name: google_sign_in_ios
      sha256: c7ee744ebbcd98353966dbdee735d4fca085226f6bf725c6bea8a5c8fe0055bc
      url: "https://pub.dev"
    source: hosted
    version: "6.1.0"
  google_sign_in_platform_interface:
    dependency: transitive
    description:
      name: google_sign_in_platform_interface
      sha256: "8736443134d2cccadd4f228d600177cb3947e36683466a6ab96877ce6932885a"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  google_sign_in_web:
    dependency: transitive
    description:
      name: google_sign_in_web
      sha256: "09ac306b2787b48f19c857b9f93375b654f774643c75bd6a1a078c85f4f7b468"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  http:
    dependency: transitive
    description:
      name: http
      sha256: bb2ce4590bc2667c96f318d68cac1b5a7987ec819351d32b1c987239a815e007
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  js:
    dependency: transitive
    description:
      name: js
      sha256: f2c445dce49627136094980615a031419f7f3eb393237e4ecd97ac15dea343f3
      url: "https://pub.dev"
    source: hosted
    version: "0.6.7"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "8dcda04c3fc16c14f48a7bb586d4be1f0d1572731b6d81d51772ef47c02081e0"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.1"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_provider:
    dependency: transitive
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: d0d310befe2c8ab9e7f393288ccbb11b60c019c6b5afc21973eeee4dda2b35e9
      url: "https://pub.dev"
    source: hosted
    version: "2.2.17"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: "16eef174aacb07e09c351502740fa6254c165757638eba1e9116b0a781201bbd"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "1a97266a94f7350d30ae522c0af07890c70b8e62c71e8e3920d1db4d23c057d1"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  redux:
    dependency: transitive
    description:
      name: redux
      sha256: "1e86ed5b1a9a717922d0a0ca41f9bf49c1a587d50050e9426fc65b14e85ec4d7"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  shared_preferences:
    dependency: "direct main"
    description:
      name: shared_preferences
      sha256: "6e8bf70b7fef813df4e9a36f658ac46d107db4b4cfe1048b477d4e453a8159f5"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.3"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "5bcf0772a761b04f8c6bf814721713de6f3e5d9d89caf8d3fe031b02a342379e"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.11"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "6a52cfcdaeac77cad8c97b539ff688ccfc458c007b4db12be584fbe5c0e49e03"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: c49bd060261c9a3f0ff445892695d6212ff603ef3115edbb448509d407600019
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  sprintf:
    dependency: transitive
    description:
      name: sprintf
      sha256: "1fc9ffe69d4df602376b52949af107d8f5703b77cda567c4d7d86a0693120f23"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  synchronized:
    dependency: transitive
    description:
      name: synchronized
      sha256: c254ade258ec8282947a0acbbc90b9575b4f19673533ee46f2f6e9b3aeefd7c0
      url: "https://pub.dev"
    source: hosted
    version: "3.4.0"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "522f00f556e73044315fa4585ec3270f1808a4b186c936e612cab0b565ff1e00"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.6"
  timezone:
    dependency: transitive
    description:
      name: timezone
      sha256: dd14a3b83cfd7cb19e7888f1cbc20f258b8d71b54c06f79ac585f14093a287d1
      url: "https://pub.dev"
    source: hosted
    version: "0.10.1"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: transitive
    description:
      name: uuid
      sha256: a5be9ef6618a7ac1e964353ef476418026db906c4facdedaa299b7a2e71690ff
      url: "https://pub.dev"
    source: hosted
    version: "4.5.1"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: "66814138c3562338d05613a6e368ed8cfb237ad6d64a9e9334be3f309acfca03"
      url: "https://pub.dev"
    source: hosted
    version: "5.14.0"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
sdks:
  dart: ">=3.9.0 <4.0.0"
  flutter: ">=3.29.0"
</file>

<file path="flutter_app/pubspec.yaml">
name: flutter_app
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  flutter_redux: ^0.10.0
  dio: ^5.9.0
  google_sign_in: 7.0.0
  flutter_secure_storage: ^9.2.4
  shared_preferences: ^2.5.3
  flutter_local_notifications: ^19.4.0
  audioplayers: ^6.5.0
  google_fonts: ^6.3.0

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  assets:
    - assets/sounds/

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
</file>

<file path="GEMINI.md">
# MAIN RULE - MUST FOLLOW - always run the temrinal command 
    afplay "/Users/pustak/Documents/VS code projects/Todoapp flutter copy gemini code/static/sounds/Focus timer start.wav" 
    When you FINISH your response. RUN THIS IN THE PROJECT'S TERMINAL WIHTOUT ASKING USER FOR PERMISSION  


# GOOD WAY TO RESPOND - FOLLOW THIS 
    For every repsone 

    FIRST Make a paln on what is asked and how do you paln to implement this 
    THEN execude the paln in the same response (do not ask for user to say yes to execute)
    Then after execution - play the sound 
    Then give the summary of what you did 
    And then give suggestions for next step 
    then STOP - CONCLUDE YOUR RESPONSE 

# IMPORTANT - GOOD USER EXPSEIRNCE 
    (IMPOETNAT) - MUST FOLLOW THIS  -  ALWAYS RUN FLUTTER ANALYZE after you have made all code changes - EVERYTIMEAfter making any code chagnes, always assess for any ERRORS in the code - maybe use flutter analyze and then FIX those error before giving the final response to the user 

    After every operation give a berif report in bullet points - of what changes you made, why it was not working, what are the potential next steps to be taken by you (the coding agent) and the user (if rquired) - make it in bullet point format and be simple in your langauge so even non coders would understand (IMPORTANT)

     ! ALWYAS FOLLOW : CAUTION -  ONLY BUILD ONE FEATURE AT ONCE - ALWAYS ASK THE USER BEFORE PROCEEDING TO BUILD ANY FEATURE (Suggest features to build user) - after asking the USER for next steps STOP your response. 
                # DO NOT CONTINUE NEXT FEATURE - STOP YOUR RESPONSE UNTIL USER GIVE PERMISSION TO PROCEED 
                # DO NOT KEEP RESPONDING FOR LONG TIMES BULIDNG NEW FEATURES - work on only the feature the user has asekd and then STOP after fnisninh 


      IMPORTANT -   STOP the response once you play the sound and give the user a summary of what did you do. CONCLUDE YOUR OUTPUT. DO NOT WAIT FOR USER'S Response - JUST STOP. 

# CAUTION - MUST FOLLOW - AVOID LOOPS - FOLLOW CORRECT LOGIC 
    Why is This Happening?
        The root cause is a disconnect between the agent's state (its knowledge of the file) and its actions (the plan it tries to execute).
        The agent's logic is flawed like this:
            If replace fails:
            Assume file has changed.
            Read the file again to update my knowledge.
            BUG: Re-run the previous command that was built on my old knowledge.
    The correct logic should be:
        If replace fails:
        Assume file has changed.
        Read the file again to update my knowledge.
        FIX: Discard the old plan. Generate a brand new replace command based on the newly read file content.
# RUN SERVER FIRST _ IMPORATNAT 
    The project now uses a Dart backend in `backend/`. Start the Dart server with the
    instructions in `backend/README.md`. Do not run the old Flask server.  


# OUTILE OF THE APP - This is the overall outline of the app (what we are suppose to build)


Here is a detailed description of the to-do application's UI, logic, and user experience, designed to be used as a prompt for an AI agent torecreate a similar app in Flutter for MOBILE devl (the app was desinged for website - change to mobile deisgn princples).

# ALWAYS keep the overall outline of the app in mind while creating features 
 ! ALWYAS FOLLOW : CAUTION -  ONLY BUILD ONE FEATURE AT ONCE - ALWAYS ASK THE USER BEFORE PROCEEDING TO BUILD ANY FEATURE (Suggest features to build user) 

    # DO NOT CONTINUE NEXT FEATURE - STOP YOUR RESPONSE UNTIL USER GIVE PERMISSION TO PROCEED 
  ---

  App Concept: A To-Do List with an Integrated Pomodoro Timer

  The application is a task management tool that combines a standard to-do list with a feature-rich Pomodoro timer. The core idea is to help users not
  only manage their tasks but also focus on them effectively using the Pomdoro technique. The app should allow users to log in with their Google
  account to persist their to-do list across sessions.

  Main UI Layout

  The main screen is divided into two main sections: a to-do list on the left and a Pomodoro timer on the right. Initially, only the to-do list is
  visible. The Pomodoro timer panel appears on the right when a user decides to start a focus session on a specific task.

  To-Do List Functionality

  1. Adding a New To-Do Item

   * UI Elements:
       * An input field for the task's name (e.g., "Write a report").
       * Two numerical input fields for the estimated duration of the task: one for hours and one for minutes.
       * An "Add" button.
   * Logic:
       * When the user types a task name, specifies a duration, and clicks "Add," a new task is created.
       * The new task appears at the bottom of the "To-Do" list.

  2. Displaying To-Do Items

   * UI Elements:
       * Each task is a list item.
       * Each item displays:
           * The task name.
           * The estimated duration (e.g., "1h 30m").
           * A set of action buttons: "Play," "Done," and "Delete."
           * A progress bar underneath the task name.
   * Logic:
       * The list is divided into two sections: "To-Do" (active tasks) and "Completed" (finished tasks).

  3. Task Actions

   * Play Button (Icon: `fa-play`)
       * Action: When clicked, this button activates the Pomodoro timer for the selected task.
       * UI Change: The Pomodoro timer panel becomes visible on the right side of the screen, and the selected task is highlighted in the to-do list.
   * Done Button (Icon: `fa-check`)
       * Action: Marks the task as complete.
       * UI Change: The task is moved from the "To-Do" list to the "Completed" list. The "Done" button's icon changes to an "Undo" icon (fa-undo).
   * Delete Button (Icon: `fa-trash`)
       * Action: Permanently deletes the task from the user's list.

  4. Progress Bar

   * UI Element: A horizontal bar at the bottom of each task item.
   * Logic:
       * The progress bar visually represents the amount of time the user has focused on the task, relative to the total estimated duration.
       * For example, if a task has an estimated duration of 1 hour and the user has focused for 30 minutes, the progress bar will be 50% full.
       * The progress bar updates in real-time during a focus session.

  5. Completed Tasks Section

   * UI Element: A collapsible section below the active to-do list, labeled "Completed."
   * Logic:
       * When a task is marked as "Done," it moves to this section.
       * The "Done" button on a completed task becomes an "Undo" button. Clicking it moves the task back to the active to-do list.
       * There is a "Clear All" button to permanently delete all completed tasks.

  Pomodoro Timer Functionality

  1. Activating the Pomodoro Timer

   * Logic: The timer is activated by clicking the "Play" button on any task in the to-do list. The timer is then associated with that specific task.

  2. Timer Display and Controls

   * UI Elements:
       * Task Name: The name of the task the user is currently focused on is displayed at the top of the timer panel.
       * Timer Display: A large, digital clock-style display shows the remaining time in the current session (e.g., "24:59").
       * Session Display: Shows the current Pomodoro cycle (e.g., "1 / 4").
       * Input Fields: For setting the duration of focus and break sessions, and the number of cycles.
       * Buttons:
           * Start/Pause: Starts or pauses the timer. The button text toggles between "Start" and "Pause."
           * Skip: Skips the current session. If in a focus session, it skips to the break. If in a break, it skips to the next focus session.
           * Reset: Resets the timer to its initial state for the current task.
           * Close: Hides the Pomodoro timer panel.

  3. Timer States: Focus and Break

   * Logic:
       * The timer alternates between "focus" and "break" modes.
       * When a focus session ends, a break session automatically begins, and vice versa.
   * UI Change: The UI provides visual feedback for the current mode. For example, the timer's border or background color could change (e.g., red for
     focus, green for break).

  4. Overdue Tasks

   * Logic:
       * If the total focused time on a task exceeds its estimated duration, the task is marked as "overdue."
   * UI Change:
       * The overdue task is visually distinguished in the to-do list (e.g., with a red border or an icon).
       * When the Pomodoro timer is active for an overdue task, an "Overdue" indicator is displayed in the timer panel.

  User Authentication

   * Logic:
       * The app uses Google for user authentication.
       * If a user is not logged in, the to-do list is hidden, and a "Login with Google" button is displayed.
       * Upon successful login, the user's to-do list is fetched from the server, and their name is displayed.
       * A "Logout" button is available for logged-in users.

  Notifications and Sounds

   * Logic: The app provides audio-visual cues for important events.
   * Browser Notifications:
       * When a focus or break session starts.
       * When a task is completed.
       * When a task becomes overdue.
   * Sound Effects:
       * A distinct sound effect is played for each type of notification (e.g., a "tick-tock" for the start of a session, a "chime" for completion).

  Modals and Pop-ups

   * Overdue Task Prompt:
       * Trigger: When a task's focused time equals its estimated duration, a modal pops up.
       * Content: The modal asks the user, "Planned time is completed. Mark complete or continue working on the overdue task?"
       * Actions:
           * Mark Complete: Marks the task as complete.
           * Continue: Closes the modal and allows the user to continue the focus session, now in "overdue" mode.
   * Completion Prompt:
       * Trigger: When all the planned Pomodoro cycles for a task are completed.
       * Content: A modal appears, informing the user that they have finished all cycles for the task.

  Data Persistence

   * Backend (Server-side):
       * The user's to-do list (task names, durations, completion status, etc.) is stored in a database on the server, linked to their Google account.
   * Frontend (Client-side):
       * The state of the Pomodoro timer for each task (e.g., the current cycle, remaining time) is saved in the browser's local storage. This ensures
         that if the user accidentally refreshes the page, the timer's state is not lost.
</file>

<file path="logs.txt">
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
Restarted application in 1,844ms.
I/flutter (18177): Using API baseUrl: http://10.0.2.2:5000
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
I/flutter (18177): Loaded ${m.length} timer states
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:b50da38d: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:b332cf13: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:b332cf13: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/ImeTracker(18177): system_server:977961ab: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/ImeTracker(18177): com.example.flutter_app:5b432b8: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/AssistStructure(18177): Flattened final assist data: 520 bytes, containing 1 windows, 3 views
I/ImeTracker(18177): com.example.flutter_app:5b432b8: onShown
I/ImeTracker(18177): com.example.flutter_app:de927bd2: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:de927bd2: onCancelled at PHASE_CLIENT_APPLY_ANIMATION
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/AssistStructure(18177): Flattened final assist data: 480 bytes, containing 1 windows, 3 views
I/flutter (18177): DEBUG [TODO]: Adding: "Task 1" (0h 1m)
I/flutter (18177): ApiService.addTodo response: {id: 57, text: Task 1, completed: 0, duration_hours: 0, duration_minutes: 1, focused_time: 0, was_overdue: 0, overdue_time: 0}
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/ple.flutter_app(18177): AssetManager2(0xb4000078bfd92658) locale list changing from [] to [en-US]
I/ImeTracker(18177): com.example.flutter_app:aa6129: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:aa6129: onCancelled at PHASE_CLIENT_APPLY_ANIMATION
I/AssistStructure(18177): Flattened final assist data: 520 bytes, containing 1 windows, 3 views
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:51d6e200: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:51d6e200: onCancelled at PHASE_CLIENT_APPLY_ANIMATION
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/AssistStructure(18177): Flattened final assist data: 480 bytes, containing 1 windows, 3 views
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): DEBUG [TODO]: Adding: "Task 2" (0h 1m)
I/flutter (18177): ApiService.addTodo response: {id: 58, text: Task 2, completed: 0, duration_hours: 0, duration_minutes: 1, focused_time: 0, was_overdue: 0, overdue_time: 0}
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:a1009908: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/ImeTracker(18177): system_server:90782d86: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): Play tapped for 57
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:null remaining:null running:null active:false mode:null planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:null timeRemaining:0 isRunning:false isTimerActive:false currentMode:focus
I/flutter (18177): Loaded state: {taskId: 57, timerState: paused, currentMode: focus, timeRemaining: 1500, totalCycles: 4, currentCycle: 0, lastFocusedTime: 0, focusDuration: 1500, breakDuration: 300, completedSessions: 0, isProgressBarFull: false, allSessionsComplete: false}
I/flutter (18177): LOAD STATE: wasCompleted=false, hasStoredState=true
I/ImeTracker(18177): com.example.flutter_app:de19a76: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:de19a76: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): POMODORO: suppression window ended, will react to service updates
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/ImeTracker(18177): com.example.flutter_app:fdb7d71a: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
I/AssistStructure(18177): Flattened final assist data: 428 bytes, containing 1 windows, 3 views
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/ImeTracker(18177): com.example.flutter_app:fdb7d71a: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/ImeTracker(18177): com.example.flutter_app:7baf6dd6: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/ImeTracker(18177): system_server:41227a41: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=true
I/flutter (18177): Auto-calc: taskMinutes=1 focusMinutes=1 calculated=1
I/flutter (18177): Starting timer.
I/flutter (18177): POMODORO: stack when user tapped start
I/flutter (18177): #0      debugPrintStack (package:flutter/src/foundation/assertions.dart:1223:29)
I/flutter (18177): #1      _PomodoroScreenState.build.<anonymous closure> (package:flutter_app/screens/pomodoro_screen.dart:1593:33)
I/flutter (18177): <asynchronous suspension>
I/flutter (18177): Starting ticker...
I/flutter (18177): POMODORO: _startTicker state before update. lastFocusedTime=0
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 1 remaining:60 running:true active:false mode:focus planned:60
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:null timeRemaining:0 isRunning:false isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 1
I/flutter (18177): - Current task: Task 1
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 1 timeRemaining:60 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): TASK_CARD: id=57 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): POMODORO: _startTicker state after update. lastFocusedTime=0
I/ple.flutter_app(18177): AssetManager2(0xb4000078bfd92658) locale list changing from [] to [en-US]
I/flutter (18177): POMODORO: _tick called. state.lastFocusedTime=0
I/flutter (18177): Tick: 59s remaining
I/flutter (18177): Saving state to local store tick block check
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 1 : null -> 1
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 1
I/flutter (18177): - Current task: Task 1
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 1 remaining:59 running:true active:null mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:60 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 1
I/flutter (18177): - Current task: Task 1
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 1 timeRemaining:59 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.016666666666666666, calculatedWidth=6.057142857142857, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=true mode=focus
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 1 remaining:59 running:true active:true mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:59 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 1
I/flutter (18177): - Current task: Task 1
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 1 timeRemaining:59 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=true mode=focus
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 1 remaining:59 running:true active:true mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:59 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): POMODORO SHEET CLOSED: Reloading list.
I/flutter (18177): MINI BAR[build]: task=Task 1 remaining=59 running=true active=true mode=focus
I/ImeTracker(18177): com.example.flutter_app:372da190: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
I/AssistStructure(18177): Flattened final assist data: 480 bytes, containing 1 windows, 3 views
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): MINI BAR[build]: task=Task 1 remaining=59 running=true active=true mode=focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): POMODORO: disposing, saved focused time for Task 1: 1s (base: 0s + session: 1s)
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 1 : 1 -> 1
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): MINI BAR[build]: task=Task 1 remaining=59 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:372da190: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 1
I/flutter (18177): TASK_CARD: id=57 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=58, focused=2
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 2
I/flutter (18177): TASK_CARD: id=57 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:6de87c99: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 2
I/flutter (18177): TASK_CARD: id=57 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 2
I/flutter (18177): TASK_CARD: id=57 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 2
I/flutter (18177): TASK_CARD: id=57 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 2
I/flutter (18177): TASK_CARD: id=57 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): MINI BAR[build]: task=Task 1 remaining=58 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/ImeTracker(18177): system_server:93642a71: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=57, focused=3
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 1 remaining=57 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): Play tapped for 58
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:null remaining:null running:null active:false mode:null planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:57 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 1 timeRemaining:57 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): Loaded state: {taskId: 58, timerState: paused, currentMode: focus, timeRemaining: 1500, totalCycles: 4, currentCycle: 0, lastFocusedTime: 0, focusDuration: 1500, breakDuration: 300, completedSessions: 0, isProgressBarFull: false, allSessionsComplete: false}
I/flutter (18177): LOAD STATE: wasCompleted=false, hasStoredState=true
I/flutter (18177): POMODORO: pausing timer for different task (Task 1) when switching to Task 2
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:null remaining:null running:false active:null mode:null planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:57 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 1
I/flutter (18177): - Current task: Task 2
I/flutter (18177): POMODORO: ignoring update for different task (Task 1 vs Task 2)
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 1 timeRemaining:57 isRunning:false isTimerActive:false currentMode:focus
I/flutter (18177): TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)
I/flutter (18177): POMODORO: ensuring current task Task 2 starts paused after task switch
I/ImeTracker(18177): com.example.flutter_app:4b8665bd: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:4b8665bd: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): POMODORO: suppression window ended, will react to service updates
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/ImeTracker(18177): com.example.flutter_app:3b55093c: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/AssistStructure(18177): Flattened final assist data: 428 bytes, containing 1 windows, 3 views
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/ImeTracker(18177): com.example.flutter_app:3b55093c: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=false
I/flutter (18177): Auto-calc: user provided cycles, skipping auto-calculation.
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:ae4ebdf9: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): system_server:2d66c1dd: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): Auto-calc: current cycles input="1" parsed=1 force=true
I/flutter (18177): Auto-calc: taskMinutes=1 focusMinutes=1 calculated=1
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): Starting timer.
I/flutter (18177): POMODORO: stack when user tapped start
I/flutter (18177): #0      debugPrintStack (package:flutter/src/foundation/assertions.dart:1223:29)
I/flutter (18177): #1      _PomodoroScreenState.build.<anonymous closure> (package:flutter_app/screens/pomodoro_screen.dart:1593:33)
I/flutter (18177): <asynchronous suspension>
I/flutter (18177): Starting ticker...
I/flutter (18177): POMODORO: _startTicker state before update. lastFocusedTime=0
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 2 remaining:60 running:true active:false mode:focus planned:60
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 1 timeRemaining:57 isRunning:false isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 2 timeRemaining:60 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): TASK_CARD: id=58 cachedFocused=0 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> null
I/flutter (18177): PROGRESS_BAR: focused=0 planned=60 progress=0.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.0, calculatedWidth=0.0, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.0, calculatedWidth=0.0, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): POMODORO: _startTicker state after update. lastFocusedTime=0
I/ple.flutter_app(18177): AssetManager2(0xb4000078bfdc8b18) locale list changing from [] to [en-US]
I/ImeTracker(18177): com.example.flutter_app:a10bc17a: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:a10bc17a: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): POMODORO: _tick called. state.lastFocusedTime=0
I/flutter (18177): Tick: 59s remaining
I/flutter (18177): Saving state to local store tick block check
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 2 : null -> 1
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 2 remaining:59 running:true active:null mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 2 timeRemaining:60 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 2 timeRemaining:59 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 1
I/flutter (18177): TASK_CARD: id=58 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 1
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.016666666666666666, calculatedWidth=6.057142857142857, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=true mode=focus
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 2 remaining:59 running:true active:true mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 2 timeRemaining:59 isRunning:true isTimerActive:false currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 2 timeRemaining:59 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=true mode=focus
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 2 remaining:59 running:true active:true mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 2 timeRemaining:59 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): POMODORO SHEET CLOSED: Reloading list.
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=59 running=true active=true mode=focus
I/ImeTracker(18177): com.example.flutter_app:d75b25eb: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=59 running=true active=true mode=focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 1
I/flutter (18177): TASK_CARD: id=58 cachedFocused=1 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=1 planned=60 progress=0.016666666666666666
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.016666666666666666, calculatedWidth=5.580952380952381, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/AssistStructure(18177): Flattened final assist data: 480 bytes, containing 1 windows, 3 views
I/flutter (18177): POMODORO: _tick called. state.lastFocusedTime=1
I/flutter (18177): Tick: 58s remaining
I/flutter (18177): Saving state to local store tick block check
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 2 : 1 -> 2
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:Task 2 remaining:58 running:true active:null mode:focus planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:Task 2 timeRemaining:59 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: Task 2
I/flutter (18177): - Current task: Task 2
I/flutter (18177): TIMER SERVICE: state changed -> activeTaskName:Task 2 timeRemaining:58 isRunning:true isTimerActive:true currentMode:focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=58 running=true active=true mode=focus
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=0.03333333333333333, calculatedWidth=12.114285714285714, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): POMODORO: disposing, saved focused time for Task 2: 2s (base: 0s + session: 2s)
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 2 : 2 -> 2
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=58 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:d75b25eb: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=2 planned=60 progress=0.03333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.03333333333333333, calculatedWidth=11.161904761904761, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=57, focused=3
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 3
I/flutter (18177): TASK_CARD: id=58 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:c3fffcf0: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 3
I/flutter (18177): TASK_CARD: id=58 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 3
I/flutter (18177): TASK_CARD: id=58 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 3
I/flutter (18177): TASK_CARD: id=58 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 3
I/flutter (18177): TASK_CARD: id=58 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=57 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): system_server:a35e7ee6: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=56, focused=4
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 4
I/flutter (18177): TASK_CARD: id=58 cachedFocused=4 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=4 planned=60 progress=0.06666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=56 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.06666666666666667, calculatedWidth=22.323809523809523, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=55, focused=5
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 5
I/flutter (18177): TASK_CARD: id=58 cachedFocused=5 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=5 planned=60 progress=0.08333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=55 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.08333333333333333, calculatedWidth=27.9047619047619, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=54, focused=6
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 6
I/flutter (18177): TASK_CARD: id=58 cachedFocused=6 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=6 planned=60 progress=0.1
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=54 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.1, calculatedWidth=33.48571428571429, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:c8822f5a: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:c8822f5a: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=53, focused=7
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 7
I/flutter (18177): TASK_CARD: id=58 cachedFocused=7 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=7 planned=60 progress=0.11666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=53 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.11666666666666667, calculatedWidth=39.06666666666666, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:94d9160b: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=52, focused=8
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=52 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:94d9160b: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 8
I/flutter (18177): TASK_CARD: id=58 cachedFocused=8 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=8 planned=60 progress=0.13333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.13333333333333333, calculatedWidth=44.647619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=51, focused=9
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:e5aa62b: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 9
I/flutter (18177): TASK_CARD: id=58 cachedFocused=9 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=9 planned=60 progress=0.15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=51 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.15, calculatedWidth=50.22857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): system_server:66d4f5c0: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=50, focused=10
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 10
I/flutter (18177): TASK_CARD: id=58 cachedFocused=10 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=10 planned=60 progress=0.16666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=50 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.16666666666666666, calculatedWidth=55.8095238095238, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=49, focused=11
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 11
I/flutter (18177): TASK_CARD: id=58 cachedFocused=11 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=11 planned=60 progress=0.18333333333333332
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=49 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.18333333333333332, calculatedWidth=61.39047619047618, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=48, focused=12
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 12
I/flutter (18177): TASK_CARD: id=58 cachedFocused=12 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=12 planned=60 progress=0.2
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=48 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.2, calculatedWidth=66.97142857142858, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=47, focused=13
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 13
I/flutter (18177): TASK_CARD: id=58 cachedFocused=13 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=13 planned=60 progress=0.21666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=47 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.21666666666666667, calculatedWidth=72.55238095238094, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=46, focused=14
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 14
I/flutter (18177): TASK_CARD: id=58 cachedFocused=14 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=14 planned=60 progress=0.23333333333333334
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=46 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.23333333333333334, calculatedWidth=78.13333333333333, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=45, focused=15
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 15
I/flutter (18177): TASK_CARD: id=58 cachedFocused=15 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=15 planned=60 progress=0.25
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=45 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.25, calculatedWidth=83.71428571428571, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=44, focused=16
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 16
I/flutter (18177): TASK_CARD: id=58 cachedFocused=16 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=16 planned=60 progress=0.26666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=44 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.26666666666666666, calculatedWidth=89.29523809523809, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=false
I/flutter (18177): TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 16
I/flutter (18177): TASK_CARD: id=58 cachedFocused=16 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=16 planned=60 progress=0.26666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=44 running=false active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.26666666666666666, calculatedWidth=89.29523809523809, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=true
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 16
I/flutter (18177): TASK_CARD: id=58 cachedFocused=16 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=16 planned=60 progress=0.26666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=44 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.26666666666666666, calculatedWidth=89.29523809523809, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=43, focused=17
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 17
I/flutter (18177): TASK_CARD: id=58 cachedFocused=17 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=17 planned=60 progress=0.2833333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=43 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.2833333333333333, calculatedWidth=94.87619047619047, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=42, focused=18
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 18
I/flutter (18177): TASK_CARD: id=58 cachedFocused=18 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=18 planned=60 progress=0.3
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=42 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.3, calculatedWidth=100.45714285714284, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=41, focused=19
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 19
I/flutter (18177): TASK_CARD: id=58 cachedFocused=19 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=19 planned=60 progress=0.31666666666666665
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=41 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.31666666666666665, calculatedWidth=106.03809523809522, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=40, focused=20
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 20
I/flutter (18177): TASK_CARD: id=58 cachedFocused=20 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=20 planned=60 progress=0.3333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=40 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.3333333333333333, calculatedWidth=111.6190476190476, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=false
I/flutter (18177): TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 20
I/flutter (18177): TASK_CARD: id=58 cachedFocused=20 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=20 planned=60 progress=0.3333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=40 running=false active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.3333333333333333, calculatedWidth=111.6190476190476, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=true
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 20
I/flutter (18177): TASK_CARD: id=58 cachedFocused=20 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=20 planned=60 progress=0.3333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=40 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.3333333333333333, calculatedWidth=111.6190476190476, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=39, focused=21
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 21
I/flutter (18177): TASK_CARD: id=58 cachedFocused=21 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=21 planned=60 progress=0.35
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=39 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.35, calculatedWidth=117.19999999999999, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=38, focused=22
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 22
I/flutter (18177): TASK_CARD: id=58 cachedFocused=22 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=22 planned=60 progress=0.36666666666666664
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=38 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.36666666666666664, calculatedWidth=122.78095238095236, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=false
I/flutter (18177): TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 22
I/flutter (18177): TASK_CARD: id=58 cachedFocused=22 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=22 planned=60 progress=0.36666666666666664
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=38 running=false active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.36666666666666664, calculatedWidth=122.78095238095236, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=true
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 22
I/flutter (18177): TASK_CARD: id=58 cachedFocused=22 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=22 planned=60 progress=0.36666666666666664
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=38 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.36666666666666664, calculatedWidth=122.78095238095236, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=37, focused=23
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 23
I/flutter (18177): TASK_CARD: id=58 cachedFocused=23 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=23 planned=60 progress=0.38333333333333336
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=37 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.38333333333333336, calculatedWidth=128.36190476190475, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=36, focused=24
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 24
I/flutter (18177): TASK_CARD: id=58 cachedFocused=24 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=24 planned=60 progress=0.4
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=36 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.4, calculatedWidth=133.94285714285715, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=false
I/flutter (18177): TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 24
I/flutter (18177): TASK_CARD: id=58 cachedFocused=24 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=24 planned=60 progress=0.4
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=36 running=false active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.4, calculatedWidth=133.94285714285715, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()
I/flutter (18177): TIMER SERVICE: toggleRunning -> isRunning=true
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 24
I/flutter (18177): TASK_CARD: id=58 cachedFocused=24 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=24 planned=60 progress=0.4
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=36 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.4, calculatedWidth=133.94285714285715, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=35, focused=25
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 25
I/flutter (18177): TASK_CARD: id=58 cachedFocused=25 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=25 planned=60 progress=0.4166666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=35 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.4166666666666667, calculatedWidth=139.52380952380952, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=34, focused=26
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 26
I/flutter (18177): TASK_CARD: id=58 cachedFocused=26 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=26 planned=60 progress=0.43333333333333335
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=34 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.43333333333333335, calculatedWidth=145.1047619047619, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=33, focused=27
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 27
I/flutter (18177): TASK_CARD: id=58 cachedFocused=27 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=27 planned=60 progress=0.45
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=33 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.45, calculatedWidth=150.68571428571428, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=32, focused=28
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 28
I/flutter (18177): TASK_CARD: id=58 cachedFocused=28 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=28 planned=60 progress=0.4666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=32 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.4666666666666667, calculatedWidth=156.26666666666665, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=31, focused=29
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 29
I/flutter (18177): TASK_CARD: id=58 cachedFocused=29 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=29 planned=60 progress=0.48333333333333334
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=31 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.48333333333333334, calculatedWidth=161.84761904761905, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=30, focused=30
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 30
I/flutter (18177): TASK_CARD: id=58 cachedFocused=30 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=30 planned=60 progress=0.5
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=30 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.5, calculatedWidth=167.42857142857142, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=29, focused=31
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 31
I/flutter (18177): TASK_CARD: id=58 cachedFocused=31 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=31 planned=60 progress=0.5166666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=29 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.5166666666666667, calculatedWidth=173.0095238095238, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=28, focused=32
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 32
I/flutter (18177): TASK_CARD: id=58 cachedFocused=32 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=32 planned=60 progress=0.5333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=28 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.5333333333333333, calculatedWidth=178.59047619047618, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=27, focused=33
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 33
I/flutter (18177): TASK_CARD: id=58 cachedFocused=33 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=33 planned=60 progress=0.55
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=27 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.55, calculatedWidth=184.17142857142858, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=26, focused=34
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 34
I/flutter (18177): TASK_CARD: id=58 cachedFocused=34 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=34 planned=60 progress=0.5666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=26 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.5666666666666667, calculatedWidth=189.75238095238095, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=25, focused=35
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 35
I/flutter (18177): TASK_CARD: id=58 cachedFocused=35 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=35 planned=60 progress=0.5833333333333334
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=25 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.5833333333333334, calculatedWidth=195.33333333333334, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=24, focused=36
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 36
I/flutter (18177): TASK_CARD: id=58 cachedFocused=36 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=36 planned=60 progress=0.6
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=24 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.6, calculatedWidth=200.91428571428568, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=23, focused=37
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 37
I/flutter (18177): TASK_CARD: id=58 cachedFocused=37 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=37 planned=60 progress=0.6166666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=23 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.6166666666666667, calculatedWidth=206.49523809523808, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=22, focused=38
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 38
I/flutter (18177): TASK_CARD: id=58 cachedFocused=38 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=38 planned=60 progress=0.6333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=22 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.6333333333333333, calculatedWidth=212.07619047619045, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=21, focused=39
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 39
I/flutter (18177): TASK_CARD: id=58 cachedFocused=39 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=39 planned=60 progress=0.65
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=21 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.65, calculatedWidth=217.65714285714284, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=20, focused=40
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 40
I/flutter (18177): TASK_CARD: id=58 cachedFocused=40 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=40 planned=60 progress=0.6666666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=20 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.6666666666666666, calculatedWidth=223.2380952380952, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=19, focused=41
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 41
I/flutter (18177): TASK_CARD: id=58 cachedFocused=41 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=41 planned=60 progress=0.6833333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=19 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.6833333333333333, calculatedWidth=228.8190476190476, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=18, focused=42
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 42
I/flutter (18177): TASK_CARD: id=58 cachedFocused=42 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=42 planned=60 progress=0.7
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=18 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.7, calculatedWidth=234.39999999999998, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=17, focused=43
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 43
I/flutter (18177): TASK_CARD: id=58 cachedFocused=43 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=43 planned=60 progress=0.7166666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=17 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.7166666666666667, calculatedWidth=239.98095238095237, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=16, focused=44
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 44
I/flutter (18177): TASK_CARD: id=58 cachedFocused=44 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=44 planned=60 progress=0.7333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=16 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.7333333333333333, calculatedWidth=245.5619047619047, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=15, focused=45
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 45
I/flutter (18177): TASK_CARD: id=58 cachedFocused=45 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=45 planned=60 progress=0.75
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=15 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.75, calculatedWidth=251.1428571428571, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=14, focused=46
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 46
I/flutter (18177): TASK_CARD: id=58 cachedFocused=46 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=46 planned=60 progress=0.7666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=14 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.7666666666666667, calculatedWidth=256.7238095238095, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=13, focused=47
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 47
I/flutter (18177): TASK_CARD: id=58 cachedFocused=47 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=47 planned=60 progress=0.7833333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=13 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.7833333333333333, calculatedWidth=262.3047619047619, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=12, focused=48
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 48
I/flutter (18177): TASK_CARD: id=58 cachedFocused=48 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=48 planned=60 progress=0.8
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=12 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.8, calculatedWidth=267.8857142857143, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=11, focused=49
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 49
I/flutter (18177): TASK_CARD: id=58 cachedFocused=49 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=49 planned=60 progress=0.8166666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=11 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.8166666666666667, calculatedWidth=273.46666666666664, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=10, focused=50
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 50
I/flutter (18177): TASK_CARD: id=58 cachedFocused=50 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=50 planned=60 progress=0.8333333333333334
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=10 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.8333333333333334, calculatedWidth=279.04761904761904, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=9, focused=51
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 51
I/flutter (18177): TASK_CARD: id=58 cachedFocused=51 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=51 planned=60 progress=0.85
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=9 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.85, calculatedWidth=284.6285714285714, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=8, focused=52
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 52
I/flutter (18177): TASK_CARD: id=58 cachedFocused=52 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=52 planned=60 progress=0.8666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=8 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.8666666666666667, calculatedWidth=290.2095238095238, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=7, focused=53
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 53
I/flutter (18177): TASK_CARD: id=58 cachedFocused=53 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=53 planned=60 progress=0.8833333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=7 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.8833333333333333, calculatedWidth=295.79047619047617, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=6, focused=54
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 54
I/flutter (18177): TASK_CARD: id=58 cachedFocused=54 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=54 planned=60 progress=0.9
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=6 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.9, calculatedWidth=301.37142857142857, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=5, focused=55
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 55
I/flutter (18177): TASK_CARD: id=58 cachedFocused=55 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=55 planned=60 progress=0.9166666666666666
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=5 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.9166666666666666, calculatedWidth=306.9523809523809, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=4, focused=56
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 56
I/flutter (18177): TASK_CARD: id=58 cachedFocused=56 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=56 planned=60 progress=0.9333333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=4 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.9333333333333333, calculatedWidth=312.5333333333333, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=3, focused=57
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 57
I/flutter (18177): TASK_CARD: id=58 cachedFocused=57 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=57 planned=60 progress=0.95
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=3 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.95, calculatedWidth=318.1142857142857, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=2, focused=58
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 58
I/flutter (18177): TASK_CARD: id=58 cachedFocused=58 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=58 planned=60 progress=0.9666666666666667
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=2 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.9666666666666667, calculatedWidth=323.6952380952381, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal tick -> timeRemaining=1, focused=59
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 59
I/flutter (18177): TASK_CARD: id=58 cachedFocused=59 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=59 planned=60 progress=0.9833333333333333
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=1 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.9833333333333333, calculatedWidth=329.27619047619044, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: Task crossed planned duration (mini-bar). marking for prompt.
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=0 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=1.0, calculatedWidth=334.85714285714283, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
E/flutter (18177): [ERROR:flutter/runtime/dart_vm_initializer.cc(40)] Unhandled Exception: Unable to load asset: "assets/assets/sounds/progress_bar_full.wav".
E/flutter (18177): The asset does not exist or has empty data.
E/flutter (18177): #0      PlatformAssetBundle.load.<anonymous closure> (package:flutter/src/services/asset_bundle.dart:332:13)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #1      AudioCache.fetchToMemory (package:audioplayers/src/audio_cache.dart:99:22)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #2      AudioCache.load (package:audioplayers/src/audio_cache.dart:130:31)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #3      AudioCache.loadPath (package:audioplayers/src/audio_cache.dart:139:26)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #4      AudioPlayer.setSourceAsset (package:audioplayers/src/audioplayer.dart:425:23)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #5      AudioPlayer.setSource (package:audioplayers/src/audioplayer.dart:352:5)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #6      AudioPlayer.play (package:audioplayers/src/audioplayer.dart:218:5)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177): #7      NotificationService.playSound (package:flutter_app/services/notification_service.dart:42:5)
E/flutter (18177): <asynchronous suspension>
E/flutter (18177):
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): MINI BAR[build]: task=Task 2 remaining=0 running=true active=true mode=focus
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=1.0, calculatedWidth=334.85714285714283, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:c376c45a: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.example.flutter_app:c376c45a: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=1.0, calculatedWidth=334.85714285714283, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ple.flutter_app(18177): AssetManager2(0xb4000078bfdad8b8) locale list changing from [] to [en-US]
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=1.0, calculatedWidth=334.85714285714283, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=1.0, calculatedWidth=334.85714285714283, maxHeight=12.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:9cbdc582: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:9cbdc582: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): Play tapped for 58
I/flutter (18177): TIMER SERVICE: update() called with -> taskName:null remaining:null running:null active:false mode:null planned:null
I/flutter (18177): TIMER SERVICE: before -> activeTaskName:null timeRemaining:0 isRunning:false isTimerActive:false currentMode:focus
I/flutter (18177): Loaded state: {taskId: 58, timerState: running, currentMode: focus, timeRemaining: 58, totalCycles: 1, currentCycle: 0, lastFocusedTime: 2, focusDuration: 60, breakDuration: 300, completedSessions: 0, isProgressBarFull: false, allSessionsComplete: false}
I/flutter (18177): LOAD STATE: wasCompleted=false, hasStoredState=true
I/ImeTracker(18177): com.example.flutter_app:e4b99a80: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=1.0, calculatedWidth=363.42857142857144, maxHeight=32.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=1.0, calculatedWidth=363.42857142857144, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=1.0, calculatedWidth=363.42857142857144, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=1.0, calculatedWidth=363.42857142857144, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): PROGRESS_BAR: focused=60 planned=60 progress=1.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=363.42857142857144, progress=1.0, calculatedWidth=363.42857142857144, maxHeight=32.0
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ple.flutter_app(18177): Background concurrent mark compact GC freed 2657KB AllocSpace bytes, 0(0B) LOS objects, 49% free, 2667KB/5334KB, paused 339us,5.712ms total 61.544ms
I/ImeTracker(18177): system_server:d00c01f: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): POMODORO: suppression window ended, will react to service updates
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: null
I/flutter (18177): - Current task: Task 2
I/flutter (18177): POMODORO: ignoring update for different task (null vs Task 2)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: null
I/flutter (18177): - Current task: Task 2
I/flutter (18177): POMODORO: ignoring update for different task (null vs Task 2)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=false mode=focus
I/flutter (18177): POMODORO: minibar suppressed because service cleared
I/flutter (18177): POMODORO: Transitioning to mini-bar - running=false mode=focus
I/flutter (18177): POMODORO: minibar suppressed because service cleared
I/flutter (18177): POMODORO SHEET CLOSED: Reloading list.
I/ImeTracker(18177): com.example.flutter_app:343b963e: onRequestShow at ORIGIN_CLIENT reason SHOW_SOFT_INPUT fromUser false
D/InsetsController(18177): show(ime(), fromIme=false)
D/InsetsController(18177): Setting requestedVisibleTypes to -1 (was -9)
D/InputConnectionAdaptor(18177): The input method toggled cursor monitoring on
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): POMODORO: service update received, checking conditions:
I/flutter (18177): - Suppression active: false
I/flutter (18177): - State exists: true
I/flutter (18177): - Service task: null
I/flutter (18177): - Current task: Task 2
I/flutter (18177): POMODORO: ignoring update for different task (null vs Task 2)
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 60
I/flutter (18177): TASK_CARD: id=58 cachedFocused=60 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ple.flutter_app(18177): AssetManager2(0xb4000078bfdd94b8) locale list changing from [] to [en-US]
I/flutter (18177): POMODORO: disposing, saved focused time for Task 2: 2s (base: 0s + session: 2s)
I/flutter (18177): TIMER SERVICE: setFocusedTime -> Task 2 : 60 -> 2
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): com.example.flutter_app:343b963e: onShown
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
D/InsetsController(18177): hide(ime(), fromIme=false)
W/WindowOnBackDispatcher(18177): sendCancelIfRunning: isInProgress=false callback=android.view.ImeBackAnimationController@c8214fc
D/InsetsController(18177): Setting requestedVisibleTypes to -9 (was -1)
D/InsetsController(18177): hide(ime(), fromIme=false)
I/ImeTracker(18177): com.google.android.inputmethod.latin:1bacc282: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/ImeTracker(18177): system_server:57a77b0a: onCancelled at PHASE_CLIENT_ON_CONTROLS_CHANGED
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
I/flutter (18177): TIMER SERVICE: starting internal ticker (mini-bar mode)
I/flutter (18177): TIMER SERVICE: internal ticker reached 0, clearing
I/flutter (18177): TIMER SERVICE: clear() called - resetting central timer state
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 2) -> 2
I/flutter (18177): TASK_CARD: id=58 cachedFocused=2 planned=60 isOverdue=false
I/flutter (18177): TIMER SERVICE: getFocusedTime(Task 1) -> 3
I/flutter (18177): TASK_CARD: id=57 cachedFocused=3 planned=60 isOverdue=false
I/flutter (18177): PROGRESS_BAR: focused=3 planned=60 progress=0.05
I/flutter (18177): PROGRESS_BAR_UI: maxWidth=334.85714285714283, progress=0.05, calculatedWidth=16.742857142857144, maxHeight=12.0
</file>

<file path=".github/copilot-instructions.md">
# Follow these suggestions always 

# MAIN RULE - MUST FOLLOW - always run the temrinal command 
    afplay "/Users/pustak/Documents/VS code projects/Todoapp flutter copy gemini code/static/sounds/Focus timer start.wav" 
    When you FINISH your response. RUN THIS IN THE PROJECT'S TERMINAL WIHTOUT ASKING USER FOR PERMISSION  

# General debug rule : 
    Whenever you are building a new feature in the app always add debugging code that shows up in the DEBUG CONSOLE in the IDE (VS CODE) [it should NOT show in my app GUI though] - which will give you good information of how the features are working or not (for debugging purpose) 



# SEELCTIVE FIXING OF ERRORS
Only fix the most importnat errors after running flutter analzye - only the ones that are marked as ERROR - not the ones marked as WARNING - those can be fixed later and only the ERROS that won't let the app run (I donot want the error - there are still errors in your file while I run the app)
</file>

<file path="flutter_app/lib/widgets/pomodoro_bottom_sheet.dart">
import 'package:flutter/material.dart';
import '../models/todo.dart';
import '../services/pomodoro_controller.dart';
import '../theme/app_colors.dart';

class PomodoroBottomSheet extends StatelessWidget {
  final Todo todo;
  final PomodoroController controller;
  final Future<void> Function(int taskId, int addedSeconds) onFlushToServer;

  const PomodoroBottomSheet({
    required this.todo,
    required this.controller,
    required this.onFlushToServer,
    super.key,
  });

  String _format(int seconds) {
    final m = (seconds ~/ 60).toString().padLeft(2, '0');
    final s = (seconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (ctx, _) {
        final ctl = controller;
        return Container(
          padding: const EdgeInsets.all(8),
          decoration: const BoxDecoration(
            color: AppColors.cardBg,
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Container(
                width: 48,
                height: 4,
                decoration: BoxDecoration(
                  color: AppColors.midGray,
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              const SizedBox(height: 8),
              // Styled task title with yellow outline
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 8,
                ),
                decoration: BoxDecoration(
                  border: Border.all(color: AppColors.brightYellow, width: 1.5),
                  borderRadius: BorderRadius.circular(12.0),
                ),
                child: Text(
                  todo.text,
                  style: const TextStyle(
                    color: AppColors.brightYellow,
                    fontSize: 20,
                    fontWeight: FontWeight.w800,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
              const SizedBox(height: 10),
              Text(
                ctl.mode == PomodoroMode.focus ? 'Focus' : 'Break',
                style: const TextStyle(color: AppColors.lightGray),
              ),
              const SizedBox(height: 8),
              IntrinsicWidth(
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: ctl.isRunning
                          ? (ctl.mode == PomodoroMode.focus
                                ? Colors.redAccent
                                : Colors.greenAccent)
                          : Colors.transparent,
                      width: 3.0,
                    ),
                    borderRadius: BorderRadius.circular(8.0),
                  ),
                  child: Padding(
                    // a small breathing room on all sides
                    padding: const EdgeInsets.symmetric(
                      horizontal: 10.0,
                      vertical: 6.0,
                    ),
                    child: Transform.translate(
                      offset: const Offset(0, -3),
                      child: Text(
                        _format(ctl.timeRemaining),
                        style: const TextStyle(
                          color: AppColors.lightGray,
                          fontSize: 48,
                          fontWeight: FontWeight.w800,
                          height: 1.0,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  ElevatedButton(
                    onPressed: ctl.isRunning
                        ? () async {
                            await ctl.pause();
                          }
                        : () async {
                            ctl.start(
                              todo.id,
                              focusSec: ctl.focusDuration,
                              breakSec: ctl.breakDuration,
                              cycles: ctl.totalCycles,
                              plannedDurationSec:
                                  (todo.durationHours * 3600) +
                                  (todo.durationMinutes * 60),
                              initialFocusedSeconds: todo.focusedTime,
                            );
                          },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.brightYellow,
                      elevation: 6,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 14,
                      ),
                    ),
                    child: Text(
                      ctl.isRunning ? 'Pause' : 'Start',
                      style: const TextStyle(
                        color: Colors.black,
                        fontWeight: FontWeight.w900,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  OutlinedButton(
                    onPressed: () async {
                      await ctl.skip();
                    },
                    style: OutlinedButton.styleFrom(
                      side: const BorderSide(
                        color: AppColors.brightYellow,
                        width: 1.5,
                      ),
                      foregroundColor: AppColors.brightYellow,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    child: const Text('Skip'),
                  ),
                  const SizedBox(width: 12),
                  OutlinedButton(
                    onPressed: () async {
                      final partial = ctl.reset();
                      if (partial > 0) {
                        await onFlushToServer(todo.id, partial);
                      }
                    },
                    style: OutlinedButton.styleFrom(
                      side: const BorderSide(
                        color: AppColors.brightYellow,
                        width: 1.5,
                      ),
                      foregroundColor: AppColors.brightYellow,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    child: const Text('Reset'),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }
}
</file>

<file path="flutter_app/lib/services/api_service.dart">
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

// For local development the Dart backend accepts a simple header 'x-user-id'
// to simulate a logged-in user (the original Flask app used OAuth). When the
// ApiService is constructed with a local baseUrl we add that header so the
// client can talk to the Dart server without an OAuth flow.

class ApiService {
  final Dio _dio;

  ApiService(String baseUrl)
    : _dio = Dio(
        BaseOptions(
          baseUrl: baseUrl,
          connectTimeout: const Duration(seconds: 5),
        ),
      ) {
    final lower = baseUrl.toLowerCase();
    if (lower.contains('127.0.0.1') ||
        lower.contains('localhost') ||
        lower.contains('10.0.2.2')) {
      // default dev user id
      _dio.options.headers['x-user-id'] = 'dev';
    }
  }

  void setAuthToken(String? token) {
    if (token != null) {
      _dio.options.headers['Authorization'] = 'Bearer $token';
    } else {
      _dio.options.headers.remove('Authorization');
    }
  }

  Future<Map<String, dynamic>> authWithIdToken(String idToken) async {
    final resp = await _dio.post('/api/auth', data: {'id_token': idToken});
    return resp.data as Map<String, dynamic>;
  }

  Future<List<dynamic>> fetchTodos() async {
    final resp = await _dio.get('/api/todos');
    return resp.data as List<dynamic>;
  }

  Future<dynamic> addTodo(String text, int hours, int minutes) async {
    final resp = await _dio.post(
      '/add',
      data: {
        'text': text,
        'duration_hours': hours,
        'duration_minutes': minutes,
      },
    );
    // log server response for debugging duplicate issues
    try {
      if (kDebugMode) debugPrint('ApiService.addTodo response: ${resp.data}');
    } catch (_) {}
    return resp.data;
  }

  Future<dynamic> deleteTodo(int id) async {
    final resp = await _dio.post('/delete', data: {'id': id});
    return resp.data;
  }

  Future<dynamic> updateTodo(
    int id, {
    String? text,
    int? hours,
    int? minutes,
  }) async {
    final Map<String, dynamic> data = {'id': id};
    if (text != null) data['text'] = text;
    if (hours != null) data['duration_hours'] = hours;
    if (minutes != null) data['duration_minutes'] = minutes;
    final resp = await _dio.post('/update', data: data);
    return resp.data;
  }

  Future<dynamic> toggleTodo(int id) async {
    final resp = await _dio.post('/toggle', data: {'id': id});
    return resp.data;
  }

  Future<dynamic> updateFocusTime(int id, int focusedTime) async {
    final resp = await _dio.post(
      '/update_focus_time',
      data: {'id': id, 'focused_time': focusedTime},
    );
    return resp.data;
  }
}
</file>

<file path="flutter_app/lib/main.dart">
import 'package:flutter/material.dart';
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart';
import 'package:google_fonts/google_fonts.dart';
import 'models/todo.dart';
import 'services/api_service.dart';
import 'services/auth_service.dart';
import 'services/local_timer_store.dart';
import 'screens/login_screen.dart';
import 'screens/todo_list_screen.dart';
import 'theme/app_colors.dart';
import 'services/notification_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final notificationService = NotificationService();
  await notificationService.init();
  // Allow overriding the API host at build/run time with --dart-define=API_BASE_URL
  const envBase = String.fromEnvironment('API_BASE_URL', defaultValue: '');
  String chooseBaseUrl() {
    if (envBase.isNotEmpty) return envBase;
    // Android emulator -> host machine is reachable at 10.0.2.2
    if (Platform.isAndroid) return 'http://10.0.2.2:5000';
    // iOS simulator and other platforms can use localhost
    return 'http://127.0.0.1:5000';
  }

  final baseUrl = chooseBaseUrl();
  // show chosen base for easier debugging during development
  if (kDebugMode) debugPrint('Using API baseUrl: $baseUrl');
  final api = ApiService(baseUrl);
  final auth = AuthService(api);
  await auth.loadSavedToken();
  runApp(MyApp(api: api, auth: auth, notificationService: notificationService));
}

class MyApp extends StatelessWidget {
  final ApiService? api;
  final AuthService? auth;
  final NotificationService? notificationService;
  const MyApp({this.api, this.auth, this.notificationService, super.key});

  @override
  Widget build(BuildContext context) {
    final ApiService apiClient = api ?? ApiService('http://127.0.0.1:5000');
    final AuthService authService = auth ?? AuthService(apiClient);
    final NotificationService notificationManager =
        notificationService ?? NotificationService();
    return MaterialApp(
      title: 'Todo Flutter',
      theme: ThemeData.dark().copyWith(
        primaryColor: AppColors.brightYellow,
        scaffoldBackgroundColor: AppColors.scaffoldBg,
        textTheme: GoogleFonts.interTextTheme(
          ThemeData.dark().textTheme,
        ).apply(bodyColor: AppColors.lightGray),
      ),
      initialRoute: '/todos',
      routes: {
        '/': (c) => HomeScreen(api: apiClient, auth: authService),
        '/login': (c) => LoginScreen(api: apiClient, auth: authService),
        '/todos': (c) => TodoListScreen(
          api: apiClient,
          auth: authService,
          notificationService: notificationManager,
        ),
      },
    );
  }
}

class HomeScreen extends StatefulWidget {
  final ApiService api;
  final AuthService auth;
  const HomeScreen({required this.api, required this.auth, super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final LocalTimerStore _store = LocalTimerStore();
  List<Todo> todos = [];

  @override
  void initState() {
    super.initState();
    // Load persisted task timer states (keeps _store referenced so analyzer won't warn).
    _store.loadAll().then(
      (m) => debugPrint('Loaded \${m.length} timer states'),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('To-Do App (Flutter)'),
        actions: [
          IconButton(
            icon: const Icon(Icons.login),
            onPressed: () async {
              // Sign-in flow to be implemented: Google Sign-In + backend exchange.
              showDialog(
                context: context,
                builder: (_) => AlertDialog(
                  title: const Text('Sign-in'),
                  content: const Text(
                    'Sign-in flow not implemented in scaffold yet.',
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('OK'),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
      body: const Center(
        child: Text('Flutter skeleton created  next: implement UI & logic'),
      ),
    );
  }
}
</file>

<file path="app.py">
from flask import Flask, render_template, session, redirect, url_for, request, jsonify
from authlib.integrations.flask_client import OAuth
import os
import sqlite3
import click
from flask.cli import with_appcontext
from dotenv import load_dotenv

load_dotenv() # Load environment variables from .env file

app = Flask(__name__)
app.debug = True

app.secret_key = os.urandom(24)

# Database setup
DATABASE = 'database.db'

def get_db():
    db = sqlite3.connect(DATABASE)
    db.row_factory = sqlite3.Row
    return db


def current_user():
    """Return the logged-in user dict from session. When running in debug mode
    and no session exists, return a default dev user so local clients can work
    without OAuth during development.
    """
    user = session.get('user')
    if user:
        return user
    if app.debug:
        # Development fallback user id
        return {'sub': 'dev'}
    return None


def ensure_was_overdue_column():
    db = get_db()
    cursor = db.cursor()
    # Check if column exists
    cols = cursor.execute("PRAGMA table_info('todos')").fetchall()
    col_names = [c['name'] for c in cols]
    if 'was_overdue' not in col_names:
        cursor.execute('ALTER TABLE todos ADD COLUMN was_overdue INTEGER NOT NULL DEFAULT 0')
        db.commit()
    if 'overdue_time' not in col_names:
        cursor.execute('ALTER TABLE todos ADD COLUMN overdue_time INTEGER NOT NULL DEFAULT 0')
        db.commit()
    db.close()

def init_db():
    db = get_db()
    with app.open_resource('schema.sql') as f:
        db.executescript(f.read().decode('utf8'))
    db.close()

@click.command('init-db')
@with_appcontext
def init_db_command():
    """Clear the existing data and create new tables."""
    init_db()
    click.echo('Initialized the database.')

app.cli.add_command(init_db_command)


# Safe limits for session increments (one day)
MAX_SESSION_SECONDS = 24 * 3600


@click.command('fix-focused-times')
@with_appcontext
def fix_focused_times():
    """Scan todos and fix obviously-bad focused_time / overdue_time values (e.g. milliseconds written as seconds).
    This converts values > 1_000_000 by dividing by 1000 and recomputes overdue flags.
    """
    db = get_db()
    cursor = db.cursor()
    rows = cursor.execute('SELECT id, focused_time, overdue_time FROM todos').fetchall()
    fixed = 0
    for r in rows:
        tid = r['id']
        ft = int(r['focused_time'] or 0)
        ot = int(r['overdue_time'] or 0)
        # Heuristic: very large values likely milliseconds
        if ft > 1000000:
            new_ft = ft // 1000
            new_ot = ot // 1000 if ot and ot > 1000000 else ot
            # recompute overdue based on duration
            meta = cursor.execute('SELECT duration_hours, duration_minutes FROM todos WHERE id = ?', (tid,)).fetchone()
            dh = int(meta['duration_hours'] or 0)
            dm = int(meta['duration_minutes'] or 0)
            total = (dh * 3600) + (dm * 60)
            was_overdue = 1 if total > 0 and new_ft > total else 0
            overdue_time = max(0, new_ft - total) if total > 0 else new_ot
            cursor.execute('UPDATE todos SET focused_time = ?, overdue_time = ?, was_overdue = ? WHERE id = ?', (new_ft, overdue_time, was_overdue, tid))
            fixed += 1
    db.commit()
    db.close()
    click.echo(f'Fixed {fixed} todos.')


app.cli.add_command(fix_focused_times)

# OAuth setup
oauth = OAuth(app)
google = oauth.register(
    name='google',
    client_id=os.environ.get('GOOGLE_CLIENT_ID'),
    client_secret=os.environ.get('GOOGLE_CLIENT_SECRET'),
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'},
)

@app.route('/')
def index():
    user = session.get('user')
    if user:
        ensure_was_overdue_column()
        db = get_db()
        todos = db.execute('SELECT * FROM todos WHERE user_id = ?', (user['sub'],)).fetchall()
        db.close()
        return render_template('index.html', user=user, todos=todos)
    return render_template('index.html', user=user)


@app.route('/api/todos')
def api_todos():
    user = current_user()
    if not user:
        return jsonify([])
    ensure_was_overdue_column()
    db = get_db()
    rows = db.execute('SELECT * FROM todos WHERE user_id = ?', (user['sub'],)).fetchall()
    result = []
    for r in rows:
        result.append({
            'id': r['id'],
            'user_id': r['user_id'],
            'text': r['text'],
            'completed': r['completed'],
            'duration_hours': r['duration_hours'],
            'duration_minutes': r['duration_minutes'],
            'focused_time': r['focused_time'],
            'was_overdue': r.get('was_overdue', 0) if isinstance(r, dict) else r['was_overdue'],
            'overdue_time': r.get('overdue_time', 0) if isinstance(r, dict) else r['overdue_time'],
        })
    db.close()
    return jsonify(result)

@app.route('/login')
def login():
    redirect_uri = url_for('authorize', _external=True)
    return google.authorize_redirect(redirect_uri)

@app.route('/authorize')
def authorize():
    token = google.authorize_access_token()
    user_info = token['userinfo']
    session['user'] = user_info
    return redirect('/')

@app.route('/logout')
def logout():
    session.pop('user', None)
    return redirect('/')

@app.route('/add', methods=['POST'])
def add_todo():
    user = current_user()
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401

    data = request.get_json() or {}
    todo_text = data.get('text', '').strip()
    try:
        duration_hours = int(data.get('duration_hours') or 0)
    except Exception:
        duration_hours = 0
    try:
        duration_minutes = int(data.get('duration_minutes') or 0)
    except Exception:
        duration_minutes = 0

    if not todo_text:
        return jsonify({'error': 'Text is required'}), 400

    db = get_db()
    cursor = db.cursor()
    cursor.execute(
        'INSERT INTO todos (user_id, text, duration_hours, duration_minutes, focused_time, was_overdue, overdue_time) VALUES (?, ?, ?, ?, 0, 0, 0)',
        (user['sub'], todo_text, duration_hours, duration_minutes),
    )
    new_todo_id = cursor.lastrowid
    db.commit()
    db.close()

    return jsonify({
        'id': new_todo_id,
        'text': todo_text,
        'completed': 0,
        'duration_hours': duration_hours,
        'duration_minutes': duration_minutes,
        'focused_time': 0,
        'was_overdue': 0,
        'overdue_time': 0,
    })

@app.route('/delete', methods=['POST'])
def delete_todo():
    user = current_user()
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401

    data = request.get_json() or {}
    todo_id = data.get('id')

    db = get_db()
    db.execute('DELETE FROM todos WHERE id = ? AND user_id = ?', (todo_id, user['sub']))
    db.commit()
    db.close()

    return jsonify({'result': 'success'})

@app.route('/toggle', methods=['POST'])
def toggle_todo():
    user = current_user()
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401

    data = request.get_json() or {}
    todo_id = data.get('id')

    db = get_db()
    todo = db.execute('SELECT completed FROM todos WHERE id = ? AND user_id = ?', (todo_id, user['sub'])).fetchone()
    if todo:
        new_completed_status = 0 if todo['completed'] else 1
        db.execute('UPDATE todos SET completed = ? WHERE id = ? AND user_id = ?', (new_completed_status, todo_id, user['sub']))
        db.commit()
    db.close()

    return jsonify({'result': 'success'})


@app.route('/update', methods=['POST'])
def update_todo():
    user = session.get('user')
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401

    data = request.get_json()
    todo_id = data.get('id')
    text = data.get('text')
    duration_hours = data.get('duration_hours')
    duration_minutes = data.get('duration_minutes')

    if todo_id is None:
        return jsonify({'error': 'Missing id'}), 400

    db = get_db()
    cursor = db.cursor()
    # Only update provided fields
    if text is not None:
        cursor.execute('UPDATE todos SET text = ? WHERE id = ? AND user_id = ?', (text, todo_id, user['sub']))
    if duration_hours is not None:
        cursor.execute('UPDATE todos SET duration_hours = ? WHERE id = ? AND user_id = ?', (duration_hours, todo_id, user['sub']))
    if duration_minutes is not None:
        cursor.execute('UPDATE todos SET duration_minutes = ? WHERE id = ? AND user_id = ?', (duration_minutes, todo_id, user['sub']))
    db.commit()
    db.close()
    return jsonify({'result': 'success'})

@app.route('/update_focus_time', methods=['POST'])
def update_focus_time():
    user = session.get('user')
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401

    data = request.get_json()
    todo_id = data.get('id')
    focused_time = data.get('focused_time')
    # normalize and clamp focused_time
    try:
        ft = int(focused_time or 0)
    except Exception:
        ft = 0
    # If value is unreasonably large, it might be milliseconds -> convert
    if ft > 1000000:
        ft = ft // 1000
    # clamp to a sane maximum (1 day)
    if ft > MAX_SESSION_SECONDS:
        ft = MAX_SESSION_SECONDS

    db = get_db()
    # update focused_time with normalized value
    db.execute('UPDATE todos SET focused_time = ? WHERE id = ? AND user_id = ?', (ft, todo_id, user['sub']))

    # compute was_overdue and overdue_time: compare focused_time with total duration
    row = db.execute('SELECT duration_hours, duration_minutes FROM todos WHERE id = ? AND user_id = ?', (todo_id, user['sub'])).fetchone()
    was_overdue = 0
    overdue_time = 0
    if row:
        duration_hours = row['duration_hours'] or 0
        duration_minutes = row['duration_minutes'] or 0
        total_seconds = (duration_hours * 3600) + (duration_minutes * 60)
        if total_seconds > 0 and ft > total_seconds:
            was_overdue = 1
            overdue_time = ft - total_seconds

    db.execute('UPDATE todos SET was_overdue = ?, overdue_time = ? WHERE id = ? AND user_id = ?', (was_overdue, overdue_time, todo_id, user['sub']))
    db.commit()
    db.close()

    # Return normalized focused_time so client can sync
    return jsonify({'result': 'success', 'was_overdue': was_overdue, 'overdue_time': overdue_time, 'focused_time': ft})

if __name__ == '__main__':
    # Bind to 0.0.0.0 for development so mobile emulators and devices can reach the host
    app.run(debug=True, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))
</file>

<file path="flutter_app/lib/services/timer_service.dart">
import 'package:flutter/foundation.dart';
import 'dart:async';

class TimerService extends ChangeNotifier {
  TimerService._();
  static final TimerService instance = TimerService._();

  String? activeTaskName;
  int timeRemaining = 0; // seconds
  bool isRunning = false;
  bool isTimerActive = false; // whether mini-bar should show
  String currentMode = 'focus';
  int? plannedDurationSeconds;
  // Session (focus/break) durations so mini-bar ticker can handle transitions
  int? focusDurationSeconds;
  int? breakDurationSeconds;
  int currentCycle = 1;
  int totalCycles = 1;
  // Name of a task that just crossed its planned duration and requires prompting
  String? overdueCrossedTaskName;
  // Track which tasks have already had the overdue prompt shown so we don't spam the user
  final Set<String> _overduePromptShown = {};
  // Track tasks for which the user chose to continue working when overdue
  final Set<String> _overdueContinued = {};
  Timer? _ticker;
  // cache of latest focused time per task (seconds) for UI sync
  final Map<String, int> _focusedTimeCache = {};

  void update({
    String? taskName,
    int? remaining,
    bool? running,
    bool? active,
    int? plannedDuration,
    String? mode,
    int? focusDuration,
    int? breakDuration,
    int? setTotalCycles,
    int? setCurrentCycle,
  }) {
    if (kDebugMode) {
      debugPrint(
        'TIMER SERVICE: update() called with -> taskName:$taskName remaining:$remaining running:$running active:$active mode:$mode planned:$plannedDuration',
      );
      debugPrint(
        'TIMER SERVICE: before -> activeTaskName:$activeTaskName timeRemaining:$timeRemaining isRunning:$isRunning isTimerActive:$isTimerActive currentMode:$currentMode',
      );
    }
    var changed = false;
    if (taskName != null && taskName != activeTaskName) {
      activeTaskName = taskName;
      changed = true;
    }
    if (remaining != null && remaining != timeRemaining) {
      timeRemaining = remaining;
      changed = true;
    }
    // Only update running state if explicitly set (not during view transitions)
    if (running != null && running != isRunning) {
      isRunning = running;
      changed = true;
    }
    if (active != null && active != isTimerActive) {
      isTimerActive = active;
      // Do not affect the running state when just toggling active state
      changed = true;
    }
    if (mode != null && mode != currentMode) {
      currentMode = mode;
      changed = true;
    }
    if (plannedDuration != null && plannedDuration != plannedDurationSeconds) {
      plannedDurationSeconds = plannedDuration;
      changed = true;
    }
    if (focusDuration != null && focusDuration != focusDurationSeconds) {
      focusDurationSeconds = focusDuration;
      changed = true;
    }
    if (breakDuration != null && breakDuration != breakDurationSeconds) {
      breakDurationSeconds = breakDuration;
      changed = true;
    }
    if (setTotalCycles != null && setTotalCycles != totalCycles) {
      totalCycles = setTotalCycles;
      changed = true;
    }
    if (setCurrentCycle != null && setCurrentCycle != currentCycle) {
      currentCycle = setCurrentCycle;
      changed = true;
    }
    if (changed) {
      notifyListeners();
    }
    if (changed && kDebugMode) {
      debugPrint(
        'TIMER SERVICE: state changed -> activeTaskName:$activeTaskName timeRemaining:$timeRemaining isRunning:$isRunning isTimerActive:$isTimerActive currentMode:$currentMode',
      );
    }
    // Only manage ticker when running state explicitly changes
    if (running != null) {
      _manageTicker();
    }
  }

  bool hasOverduePromptBeenShown(String taskName) {
    return _overduePromptShown.contains(taskName);
  }

  void markOverduePromptShown(String taskName) {
    if (taskName.isEmpty) return;
    _overduePromptShown.add(taskName);
    // clear the crossed marker if it matches
    if (overdueCrossedTaskName == taskName) overdueCrossedTaskName = null;
    notifyListeners();
  }

  bool hasUserContinuedOverdue(String taskName) {
    return _overdueContinued.contains(taskName);
  }

  void markUserContinuedOverdue(String taskName) {
    if (taskName.isEmpty) return;
    _overdueContinued.add(taskName);
    // also mark prompt shown so we won't show it again
    _overduePromptShown.add(taskName);
    notifyListeners();
  }

  void toggleRunning() {
    isRunning = !isRunning;
    if (kDebugMode) {
      debugPrint('TIMER SERVICE: toggleRunning -> isRunning=$isRunning');
    }
    notifyListeners();
    _manageTicker();
  }

  void _manageTicker() {
    // If the mini-bar should be active and running, start a local ticker.
    if (isTimerActive && isRunning) {
      _ticker ??= Timer.periodic(const Duration(seconds: 1), (_) {
        if (_ticker != null && kDebugMode) {
          // This debug print confirms the ticker is running
          debugPrint('TIMER SERVICE: starting internal ticker (mini-bar mode)');
        }
        if (timeRemaining > 0) {
          timeRemaining -= 1;
          // Also increment focused time if in focus mode
          if (currentMode == 'focus' && activeTaskName != null) {
            final taskName = activeTaskName!;
            final currentFocus = _focusedTimeCache[taskName] ?? 0;
            _focusedTimeCache[taskName] = currentFocus + 1;
            final totalFocusedTime = _focusedTimeCache[taskName] ?? 0;

            // Check for overdue condition while running in mini-bar
            if (plannedDurationSeconds != null &&
                plannedDurationSeconds! > 0 &&
                totalFocusedTime >= plannedDurationSeconds!) {
              if (kDebugMode) {
                debugPrint(
                  'TIMER SERVICE: Task crossed planned duration (mini-bar). marking for prompt.',
                );
              }
              // Mark the crossed task; don't toggle running here  let UI decide how to prompt.
              overdueCrossedTaskName = taskName;
              notifyListeners();
              return;
            }
            if (kDebugMode) {
              debugPrint(
                'TIMER SERVICE: internal tick -> timeRemaining=$timeRemaining, focused=${_focusedTimeCache[taskName]}',
              );
            }
          } else if (kDebugMode) {
            debugPrint(
              'TIMER SERVICE: internal tick -> timeRemaining=$timeRemaining',
            );
          }
          notifyListeners();
        } else {
          // timeRemaining == 0
          // Handle automatic transition instead of clearing to avoid restart loop
          if (currentMode == 'focus' && breakDurationSeconds != null) {
            // Transition to break
            currentMode = 'break';
            timeRemaining = breakDurationSeconds!;
            currentCycle +=
                1; // increment cycle after a focus session completes
            if (kDebugMode) {
              debugPrint(
                'TIMER SERVICE: focus session complete -> switching to BREAK (cycle=$currentCycle/${totalCycles})',
              );
            }
            notifyListeners();
            return; // next tick will count down break
          } else if (currentMode == 'break' && focusDurationSeconds != null) {
            // Transition back to focus
            currentMode = 'focus';
            timeRemaining = focusDurationSeconds!;
            if (kDebugMode) {
              debugPrint(
                'TIMER SERVICE: break complete -> switching to FOCUS (cycle=$currentCycle/${totalCycles})',
              );
            }
            notifyListeners();
            return;
          } else {
            if (kDebugMode) {
              debugPrint(
                'TIMER SERVICE: no durations to transition, clearing.',
              );
            }
            clear();
          }
        }
      });
    } else {
      if (_ticker != null && kDebugMode) {
        debugPrint(
          'TIMER SERVICE: stopping internal ticker (mini-bar inactive or paused)',
        );
      }
      _ticker?.cancel();
      _ticker = null;
    }
  }

  void clear() {
    if (kDebugMode) {
      debugPrint(
        'TIMER SERVICE: clear() called - resetting central timer state',
      );
    }
    activeTaskName = null;
    timeRemaining = 0;
    isRunning = false;
    isTimerActive = false;
    currentMode = 'focus';
    plannedDurationSeconds = null;
    notifyListeners();
  }

  // Focused time cache helpers - used to sync progress across UI without
  // requiring immediate backend refresh.
  void setFocusedTime(String taskName, int seconds) {
    if (taskName.isEmpty) return;
    final prev = _focusedTimeCache[taskName];
    _focusedTimeCache[taskName] = seconds;
    if (kDebugMode) {
      debugPrint(
        'TIMER SERVICE: setFocusedTime -> $taskName : $prev -> $seconds',
      );
    }
    notifyListeners();
  }

  int? getFocusedTime(String taskName) {
    final v = _focusedTimeCache[taskName];
    if (kDebugMode) {
      debugPrint('TIMER SERVICE: getFocusedTime($taskName) -> $v');
    }
    return v;
  }
}
</file>

<file path="flutter_app/lib/widgets/mini_timer_bar.dart">
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import '../services/timer_service.dart';
import '../theme/app_colors.dart';
import '../services/api_service.dart';
import '../services/notification_service.dart';
import '../models/todo.dart';
import '../screens/pomodoro_screen.dart';

class MiniTimerBar extends StatefulWidget {
  final ApiService api;
  final NotificationService notificationService;
  final Todo? activeTodo;
  final Future<void> Function(int) onComplete;

  const MiniTimerBar({
    required this.api,
    required this.notificationService,
    this.activeTodo,
    required this.onComplete,
    super.key,
  });

  @override
  State<MiniTimerBar> createState() => _MiniTimerBarState();
}

class _MiniTimerBarState extends State<MiniTimerBar> {
  String _format(int seconds) {
    final m = (seconds ~/ 60).toString().padLeft(2, '0');
    final s = (seconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: TimerService.instance,
      builder: (context, _) {
        final svc = TimerService.instance;
        if (!svc.isTimerActive || svc.activeTaskName == null) {
          return const SizedBox.shrink();
        }
        // Hide the mini-timer when the keyboard is visible so it doesn't
        // float on top of the keyboard and obstruct typing.
        final keyboardVisible = MediaQuery.of(context).viewInsets.bottom > 0;
        if (keyboardVisible) {
          if (kDebugMode) {
            debugPrint('MINI BAR: hiding because keyboard is visible');
          }
          return const SizedBox.shrink();
        }
        final mode = svc.currentMode;
        final borderColor = mode == 'focus'
            ? Colors.redAccent
            : Colors.greenAccent;

        if (kDebugMode) {
          debugPrint(
            'MINI BAR[build]: task=${svc.activeTaskName} remaining=${svc.timeRemaining} running=${svc.isRunning} active=${svc.isTimerActive} mode=${svc.currentMode}',
          );
        }

        // Schedule a post-frame prompt if the central service indicates the planned duration
        // was crossed while running in the mini-bar. This ensures the dialog appears even
        // when the full Pomodoro sheet is not open.
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final svcAfter = TimerService.instance;
          if (svcAfter.overdueCrossedTaskName != null &&
              svcAfter.overdueCrossedTaskName ==
                  (svcAfter.activeTaskName ?? '') &&
              !svcAfter.hasOverduePromptBeenShown(
                svcAfter.overdueCrossedTaskName!,
              )) {
            if (context.mounted) {
              _showOverduePromptFromMiniBar(
                context,
                widget.activeTodo ??
                    Todo(
                      id: 0,
                      userId: '',
                      text: svcAfter.activeTaskName ?? '',
                      completed: false,
                      durationHours: 0,
                      durationMinutes: 0,
                      focusedTime: 0,
                      wasOverdue: 0,
                      overdueTime: 0,
                    ),
                widget.onComplete,
                widget.notificationService,
              );
            }
          }
        });

        // (No-op) post-frame work already scheduled earlier in this builder.

        return GestureDetector(
          onTap: () async {
            if (kDebugMode) {
              debugPrint(
                'MINI BAR: opening full Pomodoro sheet; deactivating mini-bar internal ticker first',
              );
            }
            TimerService.instance.update(active: false);
            await PomodoroScreen.showAsBottomSheet(
              context,
              widget.api,
              widget.activeTodo ??
                  Todo(
                    id: 0,
                    userId: '',
                    text: svc.activeTaskName ?? '',
                    completed: false,
                    durationHours: 0,
                    durationMinutes: 0,
                    focusedTime: 0,
                    wasOverdue: 0,
                    overdueTime: 0,
                  ),
              widget.notificationService,
              () async {
                if (widget.activeTodo != null) {
                  await widget.onComplete(widget.activeTodo!.id);
                }
              },
            );
          },
          child: Container(
            decoration: BoxDecoration(
              color: AppColors.cardBg,
              // Revert from pill shape to a standard rounded rectangle
              borderRadius: BorderRadius.circular(12.0),
              border: Border.all(color: borderColor, width: 3),
            ),
            // Keep padding consistent but slightly reduced vertical padding
            // so the bar sits comfortably when visible.
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            child: Row(
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _format(svc.timeRemaining),
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.w700,
                        fontSize: 16,
                      ),
                    ),
                    const SizedBox(height: 6),
                    SizedBox(
                      width: 200,
                      child: Text(
                        svc.activeTaskName ?? '',
                        style: const TextStyle(
                          color: Color(0xFFFFD54F), // yellow
                          fontWeight: FontWeight.w700,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const Spacer(),
                IconButton(
                  onPressed: () {
                    if (kDebugMode) {
                      debugPrint(
                        'MINI BAR: play/pause pressed, delegating to TimerService.toggleRunning()',
                      );
                    }
                    TimerService.instance.toggleRunning();
                  },
                  icon: Icon(
                    TimerService.instance.isRunning
                        ? Icons.pause_rounded
                        : Icons.play_arrow_rounded,
                    color: AppColors.brightYellow,
                  ),
                ),
                IconButton(
                  onPressed: () async {
                    if (kDebugMode) {
                      debugPrint('MINI BAR: expand pressed');
                    }
                    await PomodoroScreen.showAsBottomSheet(
                      context,
                      widget.api,
                      widget.activeTodo ??
                          Todo(
                            id: 0,
                            userId: '',
                            text: svc.activeTaskName ?? '',
                            completed: false,
                            durationHours: 0,
                            durationMinutes: 0,
                            focusedTime: 0,
                            wasOverdue: 0,
                            overdueTime: 0,
                          ),
                      widget.notificationService,
                      () async {
                        if (widget.activeTodo != null) {
                          await widget.onComplete(widget.activeTodo!.id);
                        }
                      },
                    );
                    TimerService.instance.update(active: false);
                  },
                  icon: const Icon(
                    Icons.keyboard_arrow_up_rounded,
                    color: Colors.white,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// Helper to show overdue prompt when mini-bar detects a crossed planned duration
Future<void> _showOverduePromptFromMiniBar(
  BuildContext context,
  Todo todo,
  Future<void> Function(int) onComplete,
  NotificationService notificationService,
) async {
  final svc = TimerService.instance;
  final taskName = svc.overdueCrossedTaskName;
  if (taskName == null || taskName != (svc.activeTaskName ?? '')) return;
  if (svc.hasOverduePromptBeenShown(taskName)) return;

  // mark as shown so it won't repeat
  svc.markOverduePromptShown(taskName);

  notificationService.showNotification(
    title: 'Task Overdue',
    body: 'Planned time for "${todo.text}" is complete.',
  );
  try {
    // Use standardized asset path (directory declared in pubspec: assets/sounds/)
    notificationService.playSound('sounds/progress bar full.wav');
  } catch (_) {}

  final res = await showDialog<String>(
    context: context,
    barrierDismissible: false,
    builder: (ctx) => AlertDialog(
      title: Text('"${todo.text}" Overdue'),
      content: const Text(
        'Planned time is complete. Mark task as done or continue working?',
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(ctx).pop('continue'),
          child: const Text('Continue'),
        ),
        ElevatedButton(
          onPressed: () => Navigator.of(ctx).pop('complete'),
          child: const Text('Mark Complete'),
        ),
      ],
    ),
  );

  if (res == 'complete') {
    await onComplete(todo.id);
    TimerService.instance.clear();
  } else {
    // keep running; record that the user chose to continue so UI can reflect it
    try {
      TimerService.instance.markUserContinuedOverdue(taskName);
    } catch (_) {}
  }
}
</file>

<file path="flutter_app/lib/widgets/task_card.dart">
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'dart:math' as math;
import '../models/todo.dart';
import '../theme/app_colors.dart';
import 'progress_bar.dart';
import '../services/timer_service.dart';

typedef PlayCallback = Future<void> Function(Todo todo);

class TaskCard extends StatelessWidget {
  final Todo todo;
  final PlayCallback onPlay;
  final Future<void> Function() onDelete;
  final Future<void> Function() onToggle;
  final Future<void> Function(String) onUpdateText;
  final Future<void> Function(int hours, int minutes) onUpdateDuration;
  // UI-only flag; parent can set this when the task is active (timer running)
  final bool isActive;

  const TaskCard({
    required this.todo,
    required this.onPlay,
    required this.onDelete,
    required this.onToggle,
    required this.onUpdateText,
    required this.onUpdateDuration,
    this.isActive = false,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final totalMins = (todo.durationHours * 60) + todo.durationMinutes;
    final progress = totalMins == 0
        ? 0.0
        : (todo.focusedTime / totalMins).clamp(0.0, 1.0);
    final plannedSeconds =
        (todo.durationHours * 3600) + (todo.durationMinutes * 60);
    // Use TimerService cache when a live focused value exists for immediate UI sync
    final cachedFocused =
        TimerService.instance.getFocusedTime(todo.text) ?? todo.focusedTime;
    final isOverdue = plannedSeconds > 0 && todo.focusedTime >= plannedSeconds;
    final editController = TextEditingController(text: todo.text);

    if (kDebugMode) {
      debugPrint(
        'TASK_CARD: id=${todo.id} cachedFocused=$cachedFocused planned=$plannedSeconds isOverdue=$isOverdue',
      );
    }
    return AnimatedBuilder(
      animation: TimerService.instance,
      builder: (context, _) {
        final isContinuedOverdue = TimerService.instance
            .hasUserContinuedOverdue(todo.text);
        return Opacity(
          opacity: todo.completed ? 0.5 : 1.0,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 8),
              LayoutBuilder(
                builder: (ctx, constraints) {
                  final cardWidth = constraints.maxWidth;
                  final fillWidth =
                      (cardWidth *
                      (isOverdue
                          ? (todo.focusedTime / math.max(1, totalMins))
                          : progress));
                  const fillColor = Colors.transparent; // Remove yellow hue
                  return Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 6,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: AppColors.midGray,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Stack(
                      alignment: Alignment.centerLeft,
                      children: [
                        // Base background - allow height to expand to fit content (status label)
                        Container(
                          decoration: BoxDecoration(
                            color: AppColors.midGray,
                            borderRadius: BorderRadius.circular(10),
                          ),
                        ),
                        Positioned.fill(
                          child: Align(
                            alignment: Alignment.centerLeft,
                            child: OverflowBox(
                              maxWidth: double.infinity,
                              alignment: Alignment.centerLeft,
                              child: AnimatedContainer(
                                duration: const Duration(milliseconds: 400),
                                width: fillWidth.clamp(0.0, cardWidth * 2),
                                // stretch to parent height so overlay covers the whole card
                                height: double.infinity,
                                decoration: BoxDecoration(
                                  color: fillColor,
                                  borderRadius: BorderRadius.circular(10),
                                ),
                              ),
                            ),
                          ),
                        ),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Title row with editable text and optional red-dot
                            Container(
                              decoration: isActive
                                  ? BoxDecoration(
                                      border: Border.all(
                                        color: AppColors.brightYellow,
                                        width: 1.5,
                                      ),
                                      borderRadius: BorderRadius.circular(8.0),
                                    )
                                  : null,
                              child: Focus(
                                child: Builder(
                                  builder: (ctx) {
                                    return Row(
                                      children: [
                                        Expanded(
                                          child: TextField(
                                            controller: editController,
                                            style: TextStyle(
                                              color: AppColors.lightGray,
                                              fontSize: 15,
                                              fontWeight: FontWeight.w700,
                                              fontStyle: todo.completed
                                                  ? FontStyle.italic
                                                  : FontStyle.normal,
                                            ),
                                            decoration: InputDecoration(
                                              isDense: true,
                                              contentPadding:
                                                  const EdgeInsets.symmetric(
                                                    horizontal: 6,
                                                    vertical: 2,
                                                  ),
                                              filled: false,
                                              border: InputBorder.none,
                                            ),
                                            onSubmitted: (v) async {
                                              final newText = v.trim();
                                              if (newText.isEmpty) return;
                                              await onUpdateText(newText);
                                            },
                                          ),
                                        ),
                                        if (!todo.completed &&
                                            TimerService.instance
                                                .hasUserContinuedOverdue(
                                                  todo.text,
                                                ))
                                          const Padding(
                                            padding: EdgeInsets.only(left: 8.0),
                                            child: Text(''),
                                          ),
                                      ],
                                    );
                                  },
                                ),
                              ),
                            ),
                            // Small gap then status label directly under the title (global rule)
                            const SizedBox(height: 4),
                            // Show overdue/underdue tag below the task name for any task that has one
                            Builder(
                              builder: (ctx) {
                                final isActiveOverdue =
                                    (plannedSeconds > 0 &&
                                    cachedFocused >= plannedSeconds);
                                final showTag =
                                    isActiveOverdue ||
                                    isContinuedOverdue ||
                                    (todo.overdueTime > 0) ||
                                    (todo.completed &&
                                        plannedSeconds > 0 &&
                                        ((cachedFocused / plannedSeconds) * 100)
                                                .round() <
                                            100);
                                if (!showTag) return const SizedBox.shrink();
                                return Padding(
                                  padding: const EdgeInsets.only(
                                    left: 6.0,
                                    bottom: 4.0,
                                  ),
                                  child: _buildStatusDisplay(
                                    todo,
                                    cachedFocused,
                                    plannedSeconds,
                                    isContinuedOverdue,
                                  ),
                                );
                              },
                            ),
                            // Row with duration (wrapped in Flexible to prevent overflow) and controls
                            Row(
                              children: [
                                Flexible(
                                  child: GestureDetector(
                                    onTap: () async {
                                      final tmpHours = TextEditingController(
                                        text: '${todo.durationHours}',
                                      );
                                      final tmpMins = TextEditingController(
                                        text: '${todo.durationMinutes}',
                                      );
                                      final ok = await showDialog<bool>(
                                        context: context,
                                        builder: (dctx) => AlertDialog(
                                          title: const Text('Edit duration'),
                                          content: Row(
                                            children: [
                                              Expanded(
                                                child: TextField(
                                                  controller: tmpHours,
                                                  keyboardType:
                                                      TextInputType.number,
                                                  decoration:
                                                      const InputDecoration(
                                                        labelText: 'Hours',
                                                      ),
                                                ),
                                              ),
                                              const SizedBox(width: 8),
                                              Expanded(
                                                child: TextField(
                                                  controller: tmpMins,
                                                  keyboardType:
                                                      TextInputType.number,
                                                  decoration:
                                                      const InputDecoration(
                                                        labelText: 'Minutes',
                                                      ),
                                                ),
                                              ),
                                            ],
                                          ),
                                          actions: [
                                            TextButton(
                                              onPressed: () =>
                                                  Navigator.of(dctx).pop(false),
                                              child: const Text('Cancel'),
                                            ),
                                            ElevatedButton(
                                              onPressed: () =>
                                                  Navigator.of(dctx).pop(true),
                                              child: const Text('Save'),
                                            ),
                                          ],
                                        ),
                                      );
                                      if (ok == true) {
                                        final h =
                                            int.tryParse(tmpHours.text) ?? 0;
                                        final m =
                                            int.tryParse(tmpMins.text) ?? 0;
                                        await onUpdateDuration(h, m);
                                      }
                                    },
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 8,
                                        vertical: 4,
                                      ),
                                      decoration: BoxDecoration(
                                        color: Colors.grey[800],
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Row(
                                        children: [
                                          const Icon(
                                            Icons.timer,
                                            size: 16,
                                            color: AppColors.lightGray,
                                          ),
                                          const SizedBox(width: 6),
                                          Text(
                                            '${todo.durationHours}h ${todo.durationMinutes}m',
                                            style: const TextStyle(
                                              color: AppColors.lightGray,
                                              fontWeight: FontWeight.w600,
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 6),
                                // Controls
                                if (!todo.completed)
                                  Hero(
                                    tag: 'play_${todo.id}',
                                    child: Material(
                                      color: Colors.transparent,
                                      child: IconButton(
                                        icon: const Icon(Icons.play_arrow),
                                        color: AppColors.lightGray,
                                        onPressed: () async {
                                          if (kDebugMode) {
                                            debugPrint(
                                              'Play tapped for ${todo.id}',
                                            );
                                          }
                                          await onPlay(todo);
                                        },
                                      ),
                                    ),
                                  ),
                                const SizedBox(width: 6),
                                IconButton(
                                  icon: Icon(
                                    todo.completed
                                        ? Icons.undo
                                        : Icons.check_circle_outline,
                                  ),
                                  color: AppColors.lightGray,
                                  onPressed: () async {
                                    if (kDebugMode) {
                                      debugPrint(
                                        'Toggle tapped for ${todo.id}',
                                      );
                                    }
                                    // When marking completed, also clear the minibar if this task was active
                                    try {
                                      if (todo.completed == false &&
                                          TimerService
                                                  .instance
                                                  .activeTaskName ==
                                              todo.text) {
                                        TimerService.instance.clear();
                                      }
                                    } catch (_) {}
                                    await onToggle();
                                  },
                                  tooltip: todo.completed
                                      ? 'Mark incomplete'
                                      : 'Mark completed',
                                ),
                                const SizedBox(width: 6),
                                IconButton(
                                  icon: const Icon(Icons.delete_outline),
                                  color: AppColors.lightGray,
                                  onPressed: () async {
                                    if (kDebugMode) {
                                      debugPrint(
                                        'Delete tapped for ${todo.id}',
                                      );
                                    }
                                    await onDelete();
                                  },
                                  tooltip: 'Delete',
                                ),
                              ],
                            ),
                            // Live progress bar was moved below the card for full visibility
                            const SizedBox(height: 4),
                          ],
                        ),
                      ],
                    ),
                  );
                },
              ),
              // Progress bar below the task card (full-width and easy to see)
              // Do not show progress bars for completed tasks or tasks the user continued while overdue
              if (!todo.completed && !isContinuedOverdue)
                Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: SizedBox(
                    height: 14,
                    child: ProgressBar(
                      focusedSeconds: cachedFocused,
                      plannedSeconds: plannedSeconds,
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildStatusDisplay(
    Todo todo,
    int cachedFocused,
    int plannedSeconds,
    bool isContinuedOverdue,
  ) {
    // For continued overdue tasks, show overdue time
    final isActiveOverdue =
        plannedSeconds > 0 && cachedFocused >= plannedSeconds;
    if (isContinuedOverdue || (todo.overdueTime > 0) || isActiveOverdue) {
      // Calculate overdue seconds - prefer real-time calculation for active tasks
      int overdueSeconds = 0;
      if ((isContinuedOverdue || isActiveOverdue) && plannedSeconds > 0) {
        overdueSeconds = math.max(0, cachedFocused - plannedSeconds);
      } else if (todo.overdueTime > 0) {
        overdueSeconds = todo.overdueTime * 60; // convert minutes to seconds
      }

      if (overdueSeconds > 0) {
        final formattedTime = _formatOverdueTime(overdueSeconds);
        return Text(
          'Overdue: $formattedTime',
          style: const TextStyle(
            color: Colors.redAccent,
            fontSize: 12,
            fontWeight: FontWeight.w500,
          ),
        );
      }
    }

    // For completed tasks that are underdue, show percentage
    if (todo.completed && plannedSeconds > 0) {
      final percentage = ((cachedFocused / plannedSeconds) * 100).round();
      if (percentage < 100) {
        return Text(
          'Underdue task $percentage%',
          style: const TextStyle(
            color: Colors.orangeAccent,
            fontSize: 12,
            fontWeight: FontWeight.w500,
          ),
        );
      }
    }
    // If task is completed and has neither overdue nor underdue label (percentage >=100 means already handled as overdue earlier), show green Completed
    if (todo.completed) {
      return const Text(
        'Completed',
        style: TextStyle(
          color: Colors.greenAccent,
          fontSize: 12,
          fontWeight: FontWeight.w600,
        ),
      );
    }

    return const SizedBox.shrink();
  }

  String _formatOverdueTime(int seconds) {
    final hours = seconds ~/ 3600;
    final minutes = (seconds % 3600) ~/ 60;
    final secs = seconds % 60;

    if (hours > 0) {
      return '$hours:${minutes.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
    } else {
      return '$minutes:${secs.toString().padLeft(2, '0')}';
    }
  }
}
</file>

<file path="flutter_app/lib/screens/todo_list_screen.dart">
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';
import '../models/todo.dart';
import '../theme/app_colors.dart';
import '../utils/debug_logger.dart';
import '../widgets/task_card.dart';
import 'pomodoro_screen.dart';
import '../services/timer_service.dart';
import '../widgets/mini_timer_bar.dart';

import '../services/notification_service.dart';

class TodoListScreen extends StatefulWidget {
  final ApiService api;
  final AuthService auth;
  final NotificationService notificationService;
  const TodoListScreen({
    required this.api,
    required this.auth,
    required this.notificationService,
    super.key,
  });

  @override
  State<TodoListScreen> createState() => _TodoListScreenState();
}

class _TodoListScreenState extends State<TodoListScreen> {
  final TextEditingController _newText = TextEditingController();
  final TextEditingController _hours = TextEditingController(text: '0');
  final TextEditingController _mins = TextEditingController(text: '25');
  List<Todo> _todos = [];
  bool _loading = true;
  bool _completedExpanded = false;
  bool _adding = false;

  @override
  void initState() {
    super.initState();
    _reload();
    TimerService.instance.addListener(_onTimerServiceUpdate);
  }

  @override
  void dispose() {
    TimerService.instance.removeListener(_onTimerServiceUpdate);
    _newText.dispose();
    _hours.dispose();
    _mins.dispose();
    super.dispose();
  }

  void _onTimerServiceUpdate() {
    // Rebuild to find the active todo and pass it to the mini-bar
    if (mounted) setState(() {});
  }

  Future<void> _reload() async {
    setState(() {
      _loading = true;
    });
    try {
      final list = await widget.api.fetchTodos();
      final raw = list
          .map<Todo>((e) => Todo.fromJson(Map<String, dynamic>.from(e)))
          .toList();
      // Deduplicate by id (first-seen kept) then sort newest-first by id so newest tasks appear on top
      final seen = <int>{};
      final unique = <Todo>[];
      for (final t in raw) {
        if (!seen.contains(t.id)) {
          unique.add(t);
          seen.add(t.id);
        }
      }
      unique.sort((a, b) => b.id.compareTo(a.id));
      _todos = unique;
    } catch (_) {
      _todos = [];
    } finally {
      setState(() {
        _loading = false;
      });
    }
  }

  Future<void> _addTodo() async {
    if (_adding) return;
    final text = _newText.text.trim();
    final h = int.tryParse(_hours.text) ?? 0;
    final m = int.tryParse(_mins.text) ?? 0;
    if (text.isEmpty) return;
    _adding = true;
    try {
      debugLog('TODO', 'Adding: "$text" (${h}h ${m}m)');
      await widget.api.addTodo(text, h, m);
      // NOTE: Removed sound on task creation per user request to avoid distraction.
      _newText.clear();
      _hours.text = '0';
      _mins.text = '25';
      await _reload();
    } catch (err, st) {
      debugLog('TODO', 'Add failed: $err\n$st');
      // optimistic local insert to keep UX responsive
      final localId = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      final todo = Todo(
        id: localId,
        userId: '',
        text: text,
        completed: false,
        durationHours: h,
        durationMinutes: m,
        focusedTime: 0,
        wasOverdue: 0,
        overdueTime: 0,
      );
      setState(() {
        if (!_todos.any((t) => t.id == todo.id)) _todos = [todo, ..._todos];
        _newText.clear();
        _hours.text = '0';
        _mins.text = '25';
      });
    } finally {
      _adding = false;
    }
  }

  // _pickNumber removed - hours/minutes are edited inline now.

  Future<void> _deleteTodo(int id) async {
    debugLog('TODO', 'Deleting todo $id');

    // Find the todo being deleted to check if it has an active timer
    final todoToDelete = _todos.firstWhere(
      (todo) => todo.id == id,
      orElse: () => Todo(
        id: -1,
        userId: '',
        text: '',
        completed: false,
        durationHours: 0,
        durationMinutes: 0,
        focusedTime: 0,
        wasOverdue: 0,
        overdueTime: 0,
      ),
    );

    // Check if this task has an active timer in TimerService
    final svc = TimerService.instance;
    bool shouldClearTimer = false;

    if (todoToDelete.id != -1 && svc.activeTaskName == todoToDelete.text) {
      shouldClearTimer = true;
      if (kDebugMode) {
        debugPrint(
          'TODO DELETE: Task "${todoToDelete.text}" has active timer - will clear minibar',
        );
      }
    }

    try {
      await widget.api.deleteTodo(id);
      try {
        // Retain delete auditory feedback (break sound)  path standardized.
        await widget.notificationService.playSound(
          'sounds/Break timer start.wav',
        );
      } catch (_) {}

      // Clear timer service if this was the active task
      if (shouldClearTimer) {
        svc.clear();
        if (kDebugMode) {
          debugPrint('TODO DELETE: Cleared timer service for deleted task');
        }
      }

      await _reload();
    } catch (err, st) {
      debugLog('TODO', 'Delete failed: $err\n$st');
    }
  }

  Future<void> _toggleTodo(int id) async {
    debugLog('TODO', 'Toggling todo $id');
    try {
      // Find current todo state before toggle to detect restoring from completed
      final existing = _todos.firstWhere(
        (t) => t.id == id,
        orElse: () => Todo(
          id: -1,
          userId: '',
          text: '',
          completed: false,
          durationHours: 0,
          durationMinutes: 0,
          focusedTime: 0,
          wasOverdue: 0,
          overdueTime: 0,
        ),
      );
      final wasCompleted = existing.completed;
      final plannedSeconds =
          (existing.durationHours * 3600) + (existing.durationMinutes * 60);
      final wasUnderdue = wasCompleted && existing.focusedTime < plannedSeconds;
      // Perform toggle
      await widget.api.toggleTodo(id);
      await _reload();
      // After reload, if we restored a previously completed task that had the green Completed label
      // (i.e., it was not overdue and not underdue label was shown), treat it now as overdue.
      if (wasCompleted && !wasUnderdue) {
        try {
          final restored = _todos.firstWhere((t) => t.id == id);
          // Mark in TimerService so UI treats as continued overdue scenario
          TimerService.instance.markUserContinuedOverdue(restored.text);
          try {
            // Standardized progress bar full sound path (no assets/ prefix, keep spaces).
            await widget.notificationService.playSound(
              'sounds/progress bar full.wav',
            );
          } catch (_) {}
          if (kDebugMode) {
            debugPrint(
              'RESTORE: Marked restored completed task as overdue (continued) -> ${restored.text}',
            );
          }
        } catch (_) {}
      }
    } catch (err, st) {
      debugLog('TODO', 'Toggle failed: $err\n$st');
    }
  }

  Future<void> _clearCompleted() async {
    final completed = _todos.where((t) => t.completed).toList();
    for (final t in completed) {
      await widget.api.deleteTodo(t.id);
    }
    await _reload();
  }

  Widget _buildTaskCard(Todo t) {
    final svc = TimerService.instance;
    // Show highlight for the task that is currently active in the timer service
    // even when the timer is paused. Previously this only showed while running.
    final isActive = svc.activeTaskName == t.text;
    return TaskCard(
      todo: t,
      isActive: isActive,
      onPlay: (todo) async {
        await PomodoroScreen.showAsBottomSheet(
          context,
          widget.api,
          todo,
          widget.notificationService,
          () => _toggleTodo(todo.id),
        );
        debugPrint("POMODORO SHEET CLOSED: Reloading list.");
        await _reload(); // This reloads the list after the sheet is closed
      },
      onDelete: () async {
        final confirm = await showDialog<bool>(
          context: context,
          builder: (dctx) => AlertDialog(
            title: const Text('Delete task?'),
            content: const Text('This will remove the task permanently.'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(dctx).pop(false),
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () => Navigator.of(dctx).pop(true),
                child: const Text('Delete'),
              ),
            ],
          ),
        );
        if (confirm == true) await _deleteTodo(t.id);
      },
      onToggle: () async {
        await _toggleTodo(t.id);
      },
      onUpdateText: (newText) async {
        await widget.api.updateTodo(t.id, text: newText);
        await _reload();
      },
      onUpdateDuration: (h, m) async {
        await widget.api.updateTodo(t.id, hours: h, minutes: m);
        await _reload();
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final maxCardWidth = min(screenWidth * 0.95, 520.0);

    final activeTaskName = TimerService.instance.activeTaskName;
    Todo? activeTodo;
    if (activeTaskName != null) {
      // Use a simple loop to find the todo to avoid exceptions
      for (final todo in _todos) {
        if (todo.text == activeTaskName) {
          activeTodo = todo;
          break;
        }
      }
    }
    return Scaffold(
      backgroundColor: AppColors.scaffoldBg,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: maxCardWidth),
            child: Container(
              decoration: BoxDecoration(
                color: AppColors.cardBg,
                borderRadius: BorderRadius.circular(22),
              ),
              child: Padding(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 18,
                ),
                child: Stack(
                  children: [
                    Column(
                      mainAxisAlignment: _todos.isEmpty
                          ? MainAxisAlignment.center
                          : MainAxisAlignment.start,
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        const SizedBox(height: 20),
                        Text(
                          'TO-DO APP',
                          style: TextStyle(
                            color: AppColors.brightYellow,
                            fontSize: 48,
                            fontWeight: FontWeight.w900,
                            letterSpacing: 1.4,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 14),
                        const Text(
                          'Welcome, prayas new!',
                          style: TextStyle(
                            color: AppColors.lightGray,
                            fontSize: 16,
                          ),
                          textAlign: TextAlign.center,
                        ),

                        const SizedBox(height: 22),

                        // Centered content block: add area + list
                        Expanded(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            children: [
                              // Add area (multiline auto-expanding input)
                              Container(
                                decoration: BoxDecoration(
                                  color: AppColors.midGray,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 12,
                                  vertical: 8,
                                ),
                                child: TextField(
                                  controller: _newText,
                                  keyboardType: TextInputType.multiline,
                                  minLines: 1,
                                  maxLines: null,
                                  style: const TextStyle(
                                    color: AppColors.lightGray,
                                    fontSize: 16,
                                  ),
                                  decoration: const InputDecoration(
                                    hintText: 'What do you need to do?',
                                    hintStyle: TextStyle(
                                      color: AppColors.mediumGray,
                                    ),
                                    border: InputBorder.none,
                                  ),
                                ),
                              ),
                              const SizedBox(height: 12),

                              // Time selectors (inline editable) and Add button
                              Row(
                                children: [
                                  SizedBox(
                                    width: 100,
                                    child: TextField(
                                      controller: _hours,
                                      keyboardType: TextInputType.number,
                                      decoration: InputDecoration(
                                        filled: true,
                                        fillColor: AppColors.midGray,
                                        contentPadding:
                                            const EdgeInsets.symmetric(
                                              horizontal: 12,
                                              vertical: 12,
                                            ),
                                        border: OutlineInputBorder(
                                          borderRadius: BorderRadius.circular(
                                            10,
                                          ),
                                          borderSide: BorderSide.none,
                                        ),
                                        hintText: '0',
                                        suffixText: 'h',
                                      ),
                                      style: const TextStyle(
                                        color: AppColors.lightGray,
                                        fontWeight: FontWeight.w600,
                                      ),
                                      onSubmitted: (_) => setState(() {}),
                                    ),
                                  ),
                                  const SizedBox(width: 10),
                                  SizedBox(
                                    width: 100,
                                    child: TextField(
                                      controller: _mins,
                                      keyboardType: TextInputType.number,
                                      decoration: InputDecoration(
                                        filled: true,
                                        fillColor: AppColors.midGray,
                                        contentPadding:
                                            const EdgeInsets.symmetric(
                                              horizontal: 12,
                                              vertical: 12,
                                            ),
                                        border: OutlineInputBorder(
                                          borderRadius: BorderRadius.circular(
                                            10,
                                          ),
                                          borderSide: BorderSide.none,
                                        ),
                                        hintText: '25',
                                        suffixText: 'm',
                                      ),
                                      style: const TextStyle(
                                        color: AppColors.lightGray,
                                        fontWeight: FontWeight.w600,
                                      ),
                                      onSubmitted: (_) => setState(() {}),
                                    ),
                                  ),
                                  const Spacer(),
                                  SizedBox(
                                    height: 44,
                                    child: ElevatedButton(
                                      onPressed: _addTodo,
                                      style: ElevatedButton.styleFrom(
                                        backgroundColor: AppColors.brightYellow,
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(
                                            10,
                                          ),
                                        ),
                                      ),
                                      child: const Padding(
                                        padding: EdgeInsets.symmetric(
                                          horizontal: 12,
                                        ),
                                        child: Text(
                                          'Add',
                                          style: TextStyle(
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),

                              const SizedBox(height: 18),

                              // Scrolling area
                              Expanded(
                                child: _loading
                                    ? const Center(
                                        child: CircularProgressIndicator(),
                                      )
                                    : ListView(
                                        padding: EdgeInsets.zero,
                                        children: [
                                          // Active tasks
                                          ..._todos
                                              .where((t) => !t.completed)
                                              .map((t) => _buildTaskCard(t)),
                                          const SizedBox(height: 18),
                                          Container(
                                            height: 2,
                                            color: AppColors.brightYellow,
                                          ),
                                          const SizedBox(height: 8),
                                          Theme(
                                            data: Theme.of(context).copyWith(
                                              dividerColor: Colors.transparent,
                                            ),
                                            child: ExpansionTile(
                                              backgroundColor:
                                                  Colors.transparent,
                                              collapsedBackgroundColor:
                                                  Colors.transparent,
                                              childrenPadding: EdgeInsets.zero,
                                              initiallyExpanded:
                                                  _completedExpanded,
                                              onExpansionChanged: (v) =>
                                                  setState(
                                                    () =>
                                                        _completedExpanded = v,
                                                  ),
                                              title: Row(
                                                mainAxisAlignment:
                                                    MainAxisAlignment
                                                        .spaceBetween,
                                                children: [
                                                  Row(
                                                    children: [
                                                      Icon(
                                                        Icons.check,
                                                        color:
                                                            AppColors.lightGray,
                                                        size: 18,
                                                      ),
                                                      const SizedBox(width: 8),
                                                      Text(
                                                        'Completed',
                                                        style: TextStyle(
                                                          color: AppColors
                                                              .lightGray,
                                                          fontSize: 14,
                                                          fontWeight:
                                                              FontWeight.w500,
                                                        ),
                                                      ),
                                                    ],
                                                  ),
                                                  if (_completedExpanded)
                                                    Tooltip(
                                                      message:
                                                          'Clear completed',
                                                      child: ElevatedButton(
                                                        onPressed: () async {
                                                          final confirm = await showDialog<bool>(
                                                            context: context,
                                                            builder: (dctx) => AlertDialog(
                                                              title: const Text(
                                                                'Clear completed?',
                                                              ),
                                                              content: const Text(
                                                                'This will permanently delete all completed tasks.',
                                                              ),
                                                              actions: [
                                                                TextButton(
                                                                  onPressed: () =>
                                                                      Navigator.of(
                                                                        dctx,
                                                                      ).pop(
                                                                        false,
                                                                      ),
                                                                  child:
                                                                      const Text(
                                                                        'Cancel',
                                                                      ),
                                                                ),
                                                                ElevatedButton(
                                                                  onPressed: () =>
                                                                      Navigator.of(
                                                                        dctx,
                                                                      ).pop(
                                                                        true,
                                                                      ),
                                                                  child:
                                                                      const Text(
                                                                        'Clear',
                                                                      ),
                                                                ),
                                                              ],
                                                            ),
                                                          );
                                                          if (confirm == true) {
                                                            await _clearCompleted();
                                                          }
                                                        },
                                                        child: const Icon(
                                                          Icons.delete_outline,
                                                          color: AppColors
                                                              .lightGray,
                                                        ),
                                                        style: ElevatedButton.styleFrom(
                                                          backgroundColor:
                                                              AppColors.midGray,
                                                          shape: RoundedRectangleBorder(
                                                            borderRadius:
                                                                BorderRadius.circular(
                                                                  8,
                                                                ),
                                                          ),
                                                          padding:
                                                              const EdgeInsets.all(
                                                                10,
                                                              ),
                                                          minimumSize:
                                                              const Size(
                                                                40,
                                                                40,
                                                              ),
                                                        ),
                                                      ),
                                                    ),
                                                ],
                                              ),
                                              children: [
                                                ..._todos
                                                    .where((t) => t.completed)
                                                    .map(
                                                      (t) => _buildTaskCard(t),
                                                    ),
                                              ],
                                            ),
                                          ),

                                          const SizedBox(height: 24),
                                        ],
                                      ),
                              ),
                            ],
                          ),
                        ),

                        const SizedBox(height: 12),

                        // Subtle logout at bottom-left - hide when keyboard is visible
                        if (MediaQuery.of(context).viewInsets.bottom == 0)
                          Align(
                            alignment: Alignment.centerLeft,
                            child: TextButton.icon(
                              onPressed: () async {
                                final nav = Navigator.of(context);
                                final confirm = await showDialog<bool>(
                                  context: context,
                                  builder: (dctx) => AlertDialog(
                                    title: const Text('Logout?'),
                                    content: const Text(
                                      'You will be signed out of the app.',
                                    ),
                                    actions: [
                                      TextButton(
                                        onPressed: () =>
                                            Navigator.of(dctx).pop(false),
                                        child: const Text('Cancel'),
                                      ),
                                      ElevatedButton(
                                        onPressed: () =>
                                            Navigator.of(dctx).pop(true),
                                        child: const Text('Logout'),
                                      ),
                                    ],
                                  ),
                                );
                                if (confirm == true) {
                                  await widget.auth.signOut();
                                  if (!mounted) return;
                                  nav.pushReplacementNamed('/login');
                                }
                              },
                              icon: Container(
                                width: 36,
                                height: 36,
                                decoration: BoxDecoration(
                                  color: Colors.transparent,
                                  shape: BoxShape.circle,
                                  border: Border.all(
                                    color: AppColors.lightGray.withAlpha(
                                      31,
                                    ), // ~0.12 opacity
                                  ),
                                ),
                                child: const Icon(
                                  Icons.logout,
                                  color: AppColors.lightGray,
                                ),
                              ),
                              label: Text(
                                'Logout',
                                style: TextStyle(
                                  color: AppColors.lightGray.withAlpha(
                                    179,
                                  ), // ~0.7 opacity
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              style: TextButton.styleFrom(
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 6,
                                ),
                              ),
                            ),
                          ),
                        // main column end
                      ],
                    ),
                    // Positioned mini-timer overlay that covers bottom controls (e.g., logout)
                    // Only show the mini-timer when the keyboard is not visible.
                    if (MediaQuery.of(context).viewInsets.bottom == 0)
                      Positioned(
                        left: 0,
                        right: 0,
                        bottom: 0,
                        child: MiniTimerBar(
                          api: widget.api,
                          notificationService: widget.notificationService,
                          activeTodo: activeTodo,
                          onComplete: _toggleTodo,
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
</file>

<file path="flutter_app/lib/screens/pomodoro_screen.dart">
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import '../services/api_service.dart';
import '../models/todo.dart';
import '../theme/app_colors.dart';
import '../services/local_timer_store.dart';
import '../models/task_timer_state.dart';
import '../services/notification_service.dart';
import 'package:google_fonts/google_fonts.dart';
import '../services/timer_service.dart';
import '../widgets/progress_bar.dart';

// Callback to let the parent (TodoListScreen) know the task was completed.
typedef TaskCompletedCallback = Future<void> Function();

class PomodoroScreen extends StatefulWidget {
  final ApiService api;
  final Todo todo;
  final NotificationService notificationService;
  final bool asSheet;
  final TaskCompletedCallback onTaskCompleted;

  const PomodoroScreen({
    required this.api,
    required this.todo,
    required this.notificationService,
    this.asSheet = false,
    required this.onTaskCompleted,
    super.key,
  });

  static Future<void> showAsBottomSheet(
    BuildContext context,
    ApiService api,
    Todo todo,
    NotificationService notificationService,
    TaskCompletedCallback onTaskCompleted,
  ) async {
    // Function to handle sheet dismissal and update minibar
    void updateMinibar() {
      final svc = TimerService.instance;
      if (kDebugMode) {
        debugPrint(
          'POMODORO: Transitioning to mini-bar - running=${svc.isRunning} mode=${svc.currentMode}',
        );
      }
      // If the central service has just been cleared (no active task and not running),
      // do not re-open the mini-bar. This prevents the close (X) button from hiding
      // the sheet then immediately re-showing the minibar.
      if (svc.activeTaskName == null && svc.isRunning == false) {
        if (kDebugMode) {
          debugPrint('POMODORO: minibar suppressed because service cleared');
        }
        return;
      }

      // Otherwise, update the mini-bar with current state to ensure smooth transition
      svc.update(
        taskName: todo.text,
        remaining: svc.timeRemaining,
        running: svc.isRunning, // Preserve the running state
        mode: svc.currentMode, // Preserve focus/break mode
        active: true, // Show the mini-bar
      );
    }

    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      // Keep the system sheet background transparent so our container
      // can render a fully opaque styled surface at 80% height.
      backgroundColor: Colors.transparent,
      builder: (context) => FractionallySizedBox(
        heightFactor: 0.8,
        alignment: Alignment.bottomCenter,
        child: Container(
          decoration: BoxDecoration(
            color: AppColors.cardBg,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: PopScope(
            canPop: true,
            onPopInvoked: (didPop) {
              if (didPop) {
                updateMinibar();
              }
            },
            child: GestureDetector(
              onTap: () {},
              child: PomodoroScreen(
                api: api,
                todo: todo,
                notificationService: notificationService,
                asSheet: true,
                onTaskCompleted: onTaskCompleted,
              ),
            ),
          ),
        ),
      ),
    );

    // Handle swipe-to-dismiss
    updateMinibar();
  }

  @override
  State<PomodoroScreen> createState() => _PomodoroScreenState();
}

class _PomodoroScreenState extends State<PomodoroScreen> {
  final LocalTimerStore _store = LocalTimerStore();
  TaskTimerState? _state;
  Timer? _ticker;
  bool _overduePromptShown = false;
  bool _suppressServiceReactions = false;

  late TextEditingController _focusController;
  late TextEditingController _breakController;
  late TextEditingController _cyclesController;

  @override
  void initState() {
    super.initState();
    _loadState();
    // Post all service interactions to avoid setState during build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      // mark the mini-bar inactive while the full sheet is open
      TimerService.instance.update(active: false);
      // listen to central timer service so mini-bar controls can affect this screen
      TimerService.instance.addListener(_onServiceUpdate);
    });
  }

  @override
  void dispose() {
    _ticker?.cancel();
    _focusController.dispose();
    _breakController.dispose();
    _cyclesController.dispose();
    TimerService.instance.removeListener(_onServiceUpdate);

    // Save current state when screen is disposed to preserve state between task switches
    if (_state != null) {
      _store.save(widget.todo.id.toString(), _state!);

      // FIX: Get current service focused time instead of using lastFocusedTime from state
      // This prevents progress bar reset when transitioning to minibar
      final currentServiceFocusedTime = TimerService.instance.getFocusedTime(
        widget.todo.text,
      );

      if (_state!.currentMode == 'focus' && currentServiceFocusedTime != null) {
        // Use service's current focused time as it has the latest cumulative value
        WidgetsBinding.instance.addPostFrameCallback((_) {
          TimerService.instance.setFocusedTime(
            widget.todo.text,
            currentServiceFocusedTime,
          );
        });

        if (kDebugMode) {
          debugPrint(
            'POMODORO: disposing, preserved focused time for ${widget.todo.text}: ${currentServiceFocusedTime}s from service',
          );
        }
      }
    }

    super.dispose();
  }

  void _onServiceUpdate() {
    if (kDebugMode) {
      debugPrint('POMODORO: service update received, checking conditions:');
      debugPrint('- Suppression active: $_suppressServiceReactions');
      debugPrint('- State exists: ${_state != null}');
      debugPrint('- Service task: ${TimerService.instance.activeTaskName}');
      debugPrint('- Current task: ${widget.todo.text}');
    }

    // Optionally suppress rapid service reactions right after load/open to avoid races
    if (_suppressServiceReactions) {
      if (kDebugMode) {
        debugPrint(
          'POMODORO: ignoring service update due to suppression window',
        );
      }
      return;
    }

    // React to play/pause toggles from the mini-bar only when this screen is active
    final svc = TimerService.instance;
    if (_state == null) {
      if (kDebugMode) {
        debugPrint('POMODORO: ignoring update, state is null');
      }
      return;
    }

    // Only apply if the service refers to this task
    if (svc.activeTaskName != widget.todo.text) {
      if (kDebugMode) {
        debugPrint(
          'POMODORO: ignoring update for different task (${svc.activeTaskName} vs ${widget.todo.text})',
        );
      }
      return;
    }

    // If running changed, start/stop our local ticker accordingly
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      final shouldBeRunning = svc.isRunning;
      final isCurrentlyRunning = _state!.timerState == 'running';
      if (shouldBeRunning && !isCurrentlyRunning) {
        setState(() {
          _state = TaskTimerState(
            taskId: _state!.taskId,
            timerState: 'running',
            currentMode: _state!.currentMode,
            timeRemaining: svc.timeRemaining,
            focusDuration: _state!.focusDuration,
            breakDuration: _state!.breakDuration,
            currentCycle: _state!.currentCycle,
            totalCycles: _state!.totalCycles,
            completedSessions: _state!.completedSessions,
            isProgressBarFull: _state!.isProgressBarFull,
            allSessionsComplete: _state!.allSessionsComplete,
          );
        });
        _startTicker();
      } else if (!shouldBeRunning && isCurrentlyRunning) {
        if (kDebugMode) {
          debugPrint(
            'POMODORO: onServiceUpdate - service requested pause for this task',
          );
          debugPrintStack(
            label: 'POMODORO: stack when service requested pause',
          );
        }
        setState(() {
          _state = TaskTimerState(
            taskId: _state!.taskId,
            timerState: 'paused',
            currentMode: _state!.currentMode,
            timeRemaining: svc.timeRemaining,
            focusDuration: _state!.focusDuration,
            breakDuration: _state!.breakDuration,
            currentCycle: _state!.currentCycle,
            totalCycles: _state!.totalCycles,
            completedSessions: _state!.completedSessions,
            isProgressBarFull: _state!.isProgressBarFull,
            allSessionsComplete: _state!.allSessionsComplete,
          );
        });
        _ticker?.cancel();
      }
    });
  }

  Future<void> _loadState() async {
    final s = await _store.load(widget.todo.id.toString());
    if (kDebugMode) {
      debugPrint("Loaded state: ${s?.toJson()}");
    }

    // Check if this is a reverted completed task - if so, reset to setup screen
    final wasCompleted = widget.todo.completed;
    final hasStoredState = s != null;

    if (kDebugMode) {
      debugPrint(
        "LOAD STATE: wasCompleted=$wasCompleted, hasStoredState=$hasStoredState",
      );
    }

    // Validate stored state for corruption or invalid values
    bool hasCorruptedState = false;
    if (s != null) {
      // Check for corrupted durations (extremely large values)
      if ((s.focusDuration ?? 0) > 24 * 3600 || // More than 24 hours
          (s.breakDuration ?? 0) > 24 * 3600 ||
          (s.timeRemaining ?? 0) > 24 * 3600 ||
          (s.focusDuration ?? 0) < 60 || // Less than 1 minute
          (s.breakDuration ?? 0) < 60) {
        hasCorruptedState = true;
        if (kDebugMode) {
          debugPrint(
            "LOAD STATE: Detected corrupted state with invalid durations",
          );
        }
      }
    }

    // If task was recently reverted from completed, force reset to setup screen
    bool shouldResetToSetup = false;
    if (!widget.todo.completed && s != null) {
      // Check if this task was previously completed by looking at stored metadata
      shouldResetToSetup = s.allSessionsComplete || s.isProgressBarFull;
    }

    // For NEW tasks (no focused time), always show setup screen
    // Only treat as new task if there's truly no progress anywhere
    bool isNewTask =
        widget.todo.focusedTime == 0 &&
        (s == null || s.lastFocusedTime == 0) &&
        TimerService.instance.activeTaskName != widget.todo.text &&
        (s == null ||
            s.timerState == 'idle' ||
            s.timerState == 'paused'); // Allow setup for new/idle tasks

    // SPECIAL CASE: For overdue tasks where user chose to continue and no saved state exists,
    // treat as new task to force setup screen
    // Treat an overdue task that the user opted to "continue" as a fresh setup
    // regardless of whether a stored state exists. Previously this only triggered
    // when there was no stored state (s == null), which caused the UI to reopen
    // directly in the running view instead of the setup screen until the user
    // manually pressed reset. This fixes the reported issue: the setup page
    // should appear immediately after continuing an overdue task.
    bool isOverdueTaskRestart =
        TimerService.instance.hasUserContinuedOverdue(widget.todo.text) &&
        TimerService.instance.activeTaskName != widget.todo.text;

    if (kDebugMode) {
      debugPrint(
        "LOAD STATE DEBUG: focusedTime=${widget.todo.focusedTime}, "
        "hasStoredState=${s != null}, "
        "isNewTask=$isNewTask, "
        "isOverdueTaskRestart=$isOverdueTaskRestart, "
        "hasUserContinuedOverdue=${TimerService.instance.hasUserContinuedOverdue(widget.todo.text)}",
      );
    }

    // Additional check: if there's no stored state and no service state, definitely show setup
    if (s == null && TimerService.instance.activeTaskName != widget.todo.text) {
      isNewTask = true;
      if (kDebugMode) {
        debugPrint(
          "LOAD STATE: No stored state and no active service state - treating as new task",
        );
      }
    }

    setState(() {
      if (shouldResetToSetup ||
          hasCorruptedState ||
          isNewTask ||
          isOverdueTaskRestart) {
        // Force reset to initial setup state
        if (kDebugMode) {
          String reason = shouldResetToSetup
              ? "reverted completed task"
              : hasCorruptedState
              ? "corrupted state detected"
              : isOverdueTaskRestart
              ? "overdue task restart after continue"
              : "new task requiring setup";
          debugPrint("LOAD STATE: Resetting to setup screen - $reason");
        }
        _state = TaskTimerState(
          taskId: widget.todo.id.toString(),
          timerState: 'idle', // Use 'idle' for setup screen
          currentMode: 'focus',
          timeRemaining: 25 * 60, // Default 25 minutes
          focusDuration: 25 * 60,
          breakDuration: 5 * 60,
          totalCycles: _calculateCycles(25),
          completedSessions: 0,
          isProgressBarFull: false,
          allSessionsComplete: false,
          lastFocusedTime: 0, // Start fresh
        );
        if (kDebugMode) {
          debugPrint(
            "LOAD STATE: Created fresh setup state with timerState='idle' for new task",
          );
        }
      } else {
        _state =
            s ??
            TaskTimerState(
              taskId: widget.todo.id.toString(),
              timerState: 'idle', // Default to setup screen if no saved state
              currentMode: 'focus',
              timeRemaining: 25 * 60,
              focusDuration: 25 * 60,
              breakDuration: 5 * 60,
              totalCycles: _calculateCycles(25),
              completedSessions: 0,
              isProgressBarFull: false,
              allSessionsComplete: false,
              lastFocusedTime: 0,
            );
      }
      // Set up suppression window in post-frame callback to avoid race conditions
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        // briefly suppress reacting to service updates to avoid races with the
        // minibar's ticker
        _suppressServiceReactions = true;
        Future.delayed(const Duration(milliseconds: 600), () {
          if (mounted) {
            _suppressServiceReactions = false;
            if (kDebugMode) {
              debugPrint(
                'POMODORO: suppression window ended, will react to service updates',
              );
            }
          }
        });
      });
      _focusController = TextEditingController(
        text: (_state!.focusDuration! ~/ 60).toString(),
      );
      // Recalculate cycles live as the user edits focus duration
      _focusController.addListener(() {
        if (!mounted) return;
        // Update state focusDuration preview immediately
        final intVal =
            int.tryParse(_focusController.text.trim()) ??
            (_state!.focusDuration! ~/ 60);
        setState(() {
          _state = _createUpdatedState(
            focusDuration: intVal * 60,
            totalCycles: _calculateCycles(intVal),
          );
          _cyclesController.text = _state!.totalCycles.toString();
        });

        // Save state immediately when user changes focus duration
        _store.save(widget.todo.id.toString(), _state!);
      });
      _breakController = TextEditingController(
        text: (_state!.breakDuration! ~/ 60).toString(),
      );
      _cyclesController = TextEditingController(
        text: _state!.totalCycles.toString(),
      );
      // If TimerService has an active timer for this task, prefer its remaining
      final svc = TimerService.instance;
      // Prefer central service state for this task when available
      if (svc.activeTaskName == widget.todo.text) {
        if (kDebugMode) {
          debugPrint(
            'POMODORO: preferring TimerService state for this task during load, isRunning=${svc.isRunning}',
          );
        }
        // Get the total focused time from the service, which is the most up-to-date
        final serviceFocusedTime =
            svc.getFocusedTime(widget.todo.text) ?? widget.todo.focusedTime;

        // CRITICAL FIX: When service has current task, calculate session time properly
        // The session time should be: service_total - todo_base_time
        final todoBaseFocusedTime = widget.todo.focusedTime;
        final currentSessionTime = serviceFocusedTime > todoBaseFocusedTime
            ? serviceFocusedTime - todoBaseFocusedTime
            : (_state!.lastFocusedTime > 0 ? _state!.lastFocusedTime : 0);

        if (kDebugMode) {
          debugPrint(
            'POMODORO: serviceFocusedTime=$serviceFocusedTime, todo.focusedTime=$todoBaseFocusedTime, calculated session time=$currentSessionTime',
          );
        }

        // pull remaining and running state from the central service
        // AND preserve the calculated session time to avoid progress reset
        _state = _createUpdatedState(
          timerState: svc.isRunning ? 'running' : 'paused',
          currentMode: svc.currentMode,
          timeRemaining: svc.timeRemaining,
          lastFocusedTime: currentSessionTime, // Use calculated session time
        );
        // If the timer was running in minibar, start it here too
        if (svc.isRunning) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            _startTicker();
          });
        }

        // Also check for overdue state immediately upon load
        final totalFocusedTime =
            svc.getFocusedTime(widget.todo.text) ?? widget.todo.focusedTime;
        final plannedSeconds =
            (widget.todo.durationHours * 3600) +
            (widget.todo.durationMinutes * 60);

        if (kDebugMode) {
          debugPrint(
            "OVERDUE CHECK ON LOAD: task=${widget.todo.text}, "
            "totalFocused=$totalFocusedTime, planned=$plannedSeconds, "
            "isOverdue=${totalFocusedTime >= plannedSeconds}, "
            "promptShown=$_overduePromptShown, "
            "servicePromptShown=${TimerService.instance.hasOverduePromptBeenShown(widget.todo.text)}",
          );
        }

        if (plannedSeconds > 0 &&
            totalFocusedTime >= plannedSeconds &&
            !_overduePromptShown &&
            !TimerService.instance.hasOverduePromptBeenShown(
              widget.todo.text,
            )) {
          _showOverduePrompt();
        }
      } else if (svc.activeTaskName != null &&
          svc.activeTaskName != widget.todo.text) {
        // If there's an active timer for a different task, pause it when switching to this task
        if (kDebugMode) {
          debugPrint(
            'POMODORO: pausing timer for different task (${svc.activeTaskName}) when switching to ${widget.todo.text}',
          );
        }
        // Pause the previous task's timer and preserve its state
        svc.update(running: false);

        // Start current task in its previous state (running or paused based on stored state)
        if (_state != null) {
          final shouldStartRunning = _state!.timerState == 'running';
          if (kDebugMode) {
            debugPrint(
              'POMODORO: starting current task ${widget.todo.text} in ${shouldStartRunning ? 'running' : 'paused'} state after task switch',
            );
          }
          setState(() {
            _state = _createUpdatedState(
              timerState: shouldStartRunning ? 'running' : 'paused',
            );
          });

          // If the stored state was running, start the ticker for this task
          if (shouldStartRunning) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (!mounted) return;
              _startTicker();
            });
          }
        }
      }
    });
  }

  void _startTicker() {
    if (kDebugMode) {
      debugPrint("Starting ticker...");
    }
    if (kDebugMode) {
      debugPrint(
        'POMODORO: _startTicker state before update. lastFocusedTime=${_state?.lastFocusedTime}',
      );
    }
    _ticker?.cancel();
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());

    // DO NOT reset the focused time cache here - this causes progress bar reset!
    // The focused time should only be updated during ticks, not at start

    // Update service state but preserve running state during transitions
    setState(() {
      _state = TaskTimerState(
        taskId: _state!.taskId,
        timerState: 'running',
        currentMode: _state!.currentMode,
        timeRemaining: _state!.timeRemaining,
        focusDuration: _state!.focusDuration,
        breakDuration: _state!.breakDuration,
        currentCycle: _state!.currentCycle,
        totalCycles: _state!.totalCycles,
        lastFocusedTime: _state!.lastFocusedTime, // Preserve last focused time
        completedSessions: _state!.completedSessions,
        isProgressBarFull: _state!.isProgressBarFull,
        allSessionsComplete: _state!.allSessionsComplete,
      );
    });
    // Play focus start only when entering a fresh focus session (not resume) and mode is focus
    try {
      if (_state?.currentMode == 'focus' &&
          (_state?.timeRemaining == _state?.focusDuration)) {
        if (kDebugMode) debugPrint('SOUND: Focus timer start (fresh session).');
        widget.notificationService.showNotification(
          title: 'Focus Started',
          body: 'Stay on task: "${widget.todo.text}"',
        );
        widget.notificationService.playSound('sounds/Focus timer start.wav');
      }
    } catch (e) {
      if (kDebugMode) debugPrint('SOUND ERROR (focus start fresh): $e');
    }
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (kDebugMode && mounted) {
        debugPrint(
          'POMODORO: _startTicker state after update. lastFocusedTime=${_state?.lastFocusedTime}',
        );
      }
    });

    TimerService.instance.update(
      taskName: widget.todo.text,
      running: true,
      remaining: _state?.timeRemaining ?? (_state?.focusDuration ?? 1500),
      active: false, // full screen open
      plannedDuration:
          (widget.todo.durationHours * 3600) +
          (widget.todo.durationMinutes * 60),
      // Provide planned duration to service
      mode: _state?.currentMode,
      focusDuration: _state?.focusDuration ?? 1500,
      breakDuration: _state?.breakDuration ?? 300,
      setTotalCycles: _state?.totalCycles ?? 4,
      setCurrentCycle: _state?.currentCycle ?? 1,
    );
  }

  void _stopTicker() {
    if (kDebugMode) {
      debugPrint("Stopping ticker.");
    }
    _ticker?.cancel();
    _ticker = null;
    TimerService.instance.update(
      running: false,
      remaining: _state?.timeRemaining,
      active: false,
      mode: _state?.currentMode,
      focusDuration: _state?.focusDuration,
      breakDuration: _state?.breakDuration,
      setTotalCycles: _state?.totalCycles,
      setCurrentCycle: _state?.currentCycle,
    );
    if (_state != null) {
      final totalFocusedTime =
          widget.todo.focusedTime + _state!.lastFocusedTime;
      widget.api.updateFocusTime(widget.todo.id, totalFocusedTime);
    }
  }

  Future<void> _tick() async {
    if (_state == null) return;
    if (kDebugMode) {
      debugPrint(
        'POMODORO: _tick called. state.lastFocusedTime=${_state?.lastFocusedTime}',
      );
    }

    if ((_state!.timeRemaining ?? 0) > 0) {
      final isFocus = _state!.currentMode == 'focus';
      final newLastFocused = isFocus
          ? _state!.lastFocusedTime + 1
          : _state!.lastFocusedTime;

      setState(() {
        _state = _createUpdatedState(
          timeRemaining: (_state!.timeRemaining ?? 0) - 1,
          lastFocusedTime: newLastFocused,
        );
      });
      final rem = _state!.timeRemaining ?? 0;
      if (kDebugMode) {
        debugPrint('Tick: ${rem}s remaining');
      }
      // save every 10s but update the mini-bar every tick for smooth reflection
      if (kDebugMode) {
        debugPrint('Saving state to local store tick block check');
      }
      // If we are in focus mode, increment the task's focused time and sync
      if (isFocus) {
        // CRITICAL FIX: Calculate total focused time correctly during timer resumption
        // Get the current cached focused time from TimerService (which already includes previous sessions)
        final currentCachedTime =
            TimerService.instance.getFocusedTime(widget.todo.text) ??
            widget.todo.focusedTime;

        // If we're resuming (cached time > base time), add just 1 second to cached time
        // If we're starting fresh, calculate as base + session time
        final totalFocusedTime = currentCachedTime > widget.todo.focusedTime
            ? currentCachedTime +
                  1 // Resume: increment cached time
            : widget.todo.focusedTime +
                  newLastFocused; // Fresh start: base + session

        if (kDebugMode) {
          debugPrint(
            'TICK DEBUG: cachedTime=$currentCachedTime, baseTime=${widget.todo.focusedTime}, sessionTime=$newLastFocused, totalTime=$totalFocusedTime',
          );
        }
        final plannedSeconds =
            (widget.todo.durationHours * 3600) +
            (widget.todo.durationMinutes * 60);

        // Check for overdue condition before updating UI
        if (kDebugMode) {
          debugPrint(
            "OVERDUE CHECK IN TICK: task=${widget.todo.text}, "
            "totalFocused=$totalFocusedTime, planned=$plannedSeconds, "
            "isOverdue=${totalFocusedTime >= plannedSeconds}, "
            "promptShown=$_overduePromptShown, "
            "servicePromptShown=${TimerService.instance.hasOverduePromptBeenShown(widget.todo.text)}",
          );
        }

        if (plannedSeconds > 0 &&
            totalFocusedTime >= plannedSeconds &&
            !_overduePromptShown &&
            !TimerService.instance.hasOverduePromptBeenShown(
              widget.todo.text,
            )) {
          _showOverduePrompt();
          return; // Stop further processing in this tick
        }

        // Check for progress bar full condition (but NOT for overdue tasks that user chose to continue)
        if (plannedSeconds > 0 &&
            totalFocusedTime >= plannedSeconds &&
            !_state!.isProgressBarFull &&
            !TimerService.instance.hasUserContinuedOverdue(widget.todo.text)) {
          _showProgressBarFullDialog();
          return; // Stop further processing in this tick
        }
        // update TimerService cache immediately for UI sync
        TimerService.instance.setFocusedTime(
          widget.todo.text,
          totalFocusedTime,
        );

        // persist every 10s to store and occasionally to server
        if (rem % 10 == 0) {
          await _store.save(widget.todo.id.toString(), _state!);
          try {
            // Send the new *total* focused time to the server.
            await widget.api.updateFocusTime(widget.todo.id, totalFocusedTime);
          } catch (_) {
            // ignore network errors; local store keeps the truth
          }
        }
      } else {
        // for break mode, just save state periodically
        if (rem % 10 == 0) {
          await _store.save(widget.todo.id.toString(), _state!);
        }
      }

      TimerService.instance.update(
        taskName: widget.todo.text,
        running: _state!.timerState == 'running',
        remaining: _state!.timeRemaining,
        mode: _state!.currentMode,
      );
      return;
    }

    _ticker?.cancel();
    if (kDebugMode) {
      debugPrint(
        'DEBUG: Timer reached 0. Current mode: ${_state!.currentMode}',
      );
    }

    if (_state!.currentMode == 'focus') {
      final newCycle = _state!.currentCycle + 1;
      final newCompletedSessions = _state!.completedSessions + 1;

      setState(() {
        _state = _createUpdatedState(
          timerState: 'running',
          currentMode: 'break',
          timeRemaining: _state!.breakDuration,
          currentCycle: newCycle,
          completedSessions: newCompletedSessions,
        );
      });

      widget.notificationService.showNotification(
        title: 'Focus session ended',
        body: 'Time for a break!',
      );
      // Play break start sound if asset exists
      try {
        if (kDebugMode) debugPrint('SOUND: Break timer start.');
        widget.notificationService.playSound('sounds/Break timer start.wav');
      } catch (e) {
        if (kDebugMode) debugPrint('SOUND ERROR (break start): $e');
      }

      // Check if all sessions are complete - but only if progress bar is not already full
      // Progress bar full dialog takes priority over session completion
      if (kDebugMode) {
        debugPrint(
          'SESSION CHECK: newCompletedSessions=$newCompletedSessions, totalCycles=${_state!.totalCycles}, isProgressBarFull=${_state!.isProgressBarFull}',
        );
      }
      if (newCompletedSessions >= (_state!.totalCycles ?? 0) &&
          !_state!.isProgressBarFull) {
        if (kDebugMode) {
          debugPrint('All focus sessions completed.');
        }
        widget.notificationService.showNotification(
          title: 'All Sessions Completed!',
          body: 'Great job focusing on "${widget.todo.text}".',
        );
        _showSessionCompletionDialog();
        return;
      }
    } else {
      setState(() {
        _state = _createUpdatedState(
          timerState: 'running',
          currentMode: 'focus',
          timeRemaining: _state!.focusDuration,
        );
      });

      widget.notificationService.showNotification(
        title: 'Break ended',
        body: 'Time to focus!',
      );
      try {
        if (kDebugMode) debugPrint('SOUND: Focus timer start (after break).');
        widget.notificationService.playSound('sounds/Focus timer start.wav');
      } catch (e) {
        if (kDebugMode) debugPrint('SOUND ERROR (focus start after break): $e');
      }
    }

    if (kDebugMode) {
      debugPrint(
        'DEBUG: New state: Mode=${_state!.currentMode}, Time=${_state!.timeRemaining}',
      );
    }
    await _store.save(widget.todo.id.toString(), _state!);

    // update mini-bar after mode switch
    TimerService.instance.update(
      taskName: widget.todo.text,
      running: _state!.timerState == 'running',
      remaining: _state!.timeRemaining,
      active: true,
      mode: _state!.currentMode,
      focusDuration: _state!.focusDuration,
      breakDuration: _state!.breakDuration,
      setTotalCycles: _state!.totalCycles,
      setCurrentCycle: _state!.currentCycle,
    );

    _startTicker();
  }

  Future<void> _showOverduePrompt() async {
    if (kDebugMode) {
      debugPrint('POMODORO: Task is now overdue. Showing prompt.');
    }
    _overduePromptShown = true; // Prevent showing it again
    // Also inform the central TimerService that this task's overdue prompt has been shown
    try {
      TimerService.instance.markOverduePromptShown(widget.todo.text);
    } catch (_) {}
    _stopTicker(); // Pause the timer

    widget.notificationService.showNotification(
      title: 'Task Overdue',
      body: 'Planned time for "${widget.todo.text}" is complete.',
    );
    // Corrected filename (no spaces) and wrapped in a try-catch
    try {
      try {
        widget.notificationService.playSound('sounds/progress bar full.wav');
      } catch (_) {}
    } catch (e) {
      if (kDebugMode) {
        debugPrint('Failed to play sound: $e');
      }
    }

    final result = await showDialog<String>(
      context: context,
      barrierDismissible: false, // User must make a choice
      builder: (ctx) => AlertDialog(
        title: Text('"${widget.todo.text}" Overdue'),
        content: const Text(
          'Planned time is complete. Mark task as done or continue working?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop('continue'),
            child: const Text('Continue'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(ctx).pop('complete'),
            child: const Text('Mark Complete'),
          ),
        ],
      ),
    );

    if (result == 'complete') {
      // Use the callback to let the parent handle the API call and UI refresh
      await widget.onTaskCompleted();
      TimerService.instance.clear();
      if (mounted) {
        Navigator.of(context).pop();
      }
    } else {
      if (kDebugMode) {
        debugPrint('POMODORO: User chose to continue overdue task.');
      }
      // Mark centrally that the user chose to continue working on this overdue task
      try {
        TimerService.instance.markUserContinuedOverdue(widget.todo.text);
      } catch (_) {}
      // Immediately transition this screen back to the setup state so the
      // user can reconfigure durations before starting a new session.
      if (mounted && _state != null) {
        setState(() {
          _state = TaskTimerState(
            taskId: _state!.taskId,
            timerState: 'idle', // ensures setup UI path
            currentMode: 'focus',
            timeRemaining: _state!.focusDuration ?? 25 * 60,
            focusDuration: _state!.focusDuration ?? 25 * 60,
            breakDuration: _state!.breakDuration ?? 5 * 60,
            totalCycles: _state!.totalCycles ?? _calculateCycles(25),
            completedSessions: 0,
            isProgressBarFull: false,
            allSessionsComplete: false,
            lastFocusedTime: 0,
          );
        });
        // Persist so that reopening also shows setup without requiring a manual reset
        try {
          await _store.save(widget.todo.id.toString(), _state!);
        } catch (_) {}
        if (kDebugMode) {
          debugPrint(
            'POMODORO: Reset to setup after continue-overdue selection. Showing setup screen.',
          );
        }
      }
    }
  }

  // Helper method to create a new state with updated fields
  TaskTimerState _createUpdatedState({
    String? timerState,
    String? currentMode,
    int? timeRemaining,
    int? focusDuration,
    int? breakDuration,
    int? currentCycle,
    int? totalCycles,
    int? lastFocusedTime,
    int? completedSessions,
    bool? isProgressBarFull,
    bool? allSessionsComplete,
  }) {
    return TaskTimerState(
      taskId: _state!.taskId,
      timerState: timerState ?? _state!.timerState,
      currentMode: currentMode ?? _state!.currentMode,
      timeRemaining: timeRemaining ?? _state!.timeRemaining,
      focusDuration: focusDuration ?? _state!.focusDuration,
      breakDuration: breakDuration ?? _state!.breakDuration,
      currentCycle: currentCycle ?? _state!.currentCycle,
      totalCycles: totalCycles ?? _state!.totalCycles,
      lastFocusedTime: lastFocusedTime ?? _state!.lastFocusedTime,
      completedSessions: completedSessions ?? _state!.completedSessions,
      isProgressBarFull: isProgressBarFull ?? _state!.isProgressBarFull,
      allSessionsComplete: allSessionsComplete ?? _state!.allSessionsComplete,
    );
  }

  // Show progress bar full dialog
  void _showProgressBarFullDialog() {
    if (kDebugMode) {
      debugPrint('POMODORO: Progress bar full - implementing HARD RESET');
    }

    // HARD RESET when progress bar full dialog appears
    _ticker?.cancel();

    // Clear service state but do NOT call TimerService.clear() which causes overdue timer
    TimerService.instance.update(
      taskName: widget.todo.text,
      running: false,
      remaining: 1500, // Reset to default 25 minutes
      active: false,
    );

    setState(() {
      _state = _createUpdatedState(
        timerState: 'idle', // Back to initial idle state
        currentMode: 'focus', // Reset to focus mode
        timeRemaining: 1500, // Fresh focus duration (25 minutes)
        focusDuration: 1500, // Default 25 minutes
        breakDuration: 300, // Default 5 minutes
        currentCycle: 1, // Reset to first cycle
        totalCycles: 4,
        lastFocusedTime: 0, // Reset focused time for fresh start
        isProgressBarFull: true, // Show dialog state
        allSessionsComplete: false, // Reset completion state
      );
    });

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Progress Bar Full!'),
        content: const Text(
          'You have completed your planned time for this task. The timer has been reset. What would you like to do?',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              _handleContinueWorking();
            },
            child: const Text('Continue Working'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              _handleMarkComplete();
            },
            child: const Text('Mark Complete'),
          ),
        ],
      ),
    );
    // Notify user and play sound for progress bar full
    try {
      if (kDebugMode) {
        debugPrint('SOUND: Playing progress bar full sound (dialog).');
      }
      widget.notificationService.showNotification(
        title: 'Planned Time Complete',
        body: 'Decide: Continue or mark "${widget.todo.text}" complete.',
      );
      widget.notificationService.playSound('sounds/progress bar full.wav');
    } catch (e) {
      if (kDebugMode) {
        debugPrint('SOUND ERROR: $e');
      }
    }
  }

  // Handle continue working after progress bar full
  void _handleContinueWorking() {
    if (kDebugMode) {
      debugPrint(
        'POMODORO: _handleContinueWorking - clearing timer state and navigating back',
      );
    }

    // Clear timer state completely like pressing the X button
    TimerService.instance.clear();

    // For overdue tasks, remove the saved state to force setup screen on next open
    _deleteTaskState();

    if (kDebugMode) {
      debugPrint(
        'POMODORO: Continue working - cleared local state for task: ${widget.todo.text}',
      );
      debugPrint(
        'POMODORO: Task is marked as hasUserContinuedOverdue: ${TimerService.instance.hasUserContinuedOverdue(widget.todo.text)}',
      );
    }

    // Navigate back to close pomodoro screen - this should trigger setup screen on next open
    Navigator.of(context).pop();
  }

  Future<void> _deleteTaskState() async {
    final all = await _store.loadAll();
    all.remove(widget.todo.id.toString());
    await _store.saveAll(all);
  }

  Widget _buildOverdueTimeDisplay(int focusedSeconds, int plannedSeconds) {
    final overdueSeconds = focusedSeconds - plannedSeconds;
    final hours = overdueSeconds ~/ 3600;
    final minutes = (overdueSeconds % 3600) ~/ 60;
    final seconds = overdueSeconds % 60;

    String timeText;
    if (hours > 0) {
      timeText =
          '${hours}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
    } else {
      timeText = '${minutes}:${seconds.toString().padLeft(2, '0')}';
    }

    return Container(
      height: 28.0,
      decoration: BoxDecoration(
        color: Colors.red.withOpacity(0.1),
        borderRadius: BorderRadius.circular(14.0),
        border: Border.all(color: Colors.red, width: 1.0),
      ),
      child: Center(
        child: Text(
          'OVERDUE TIME: $timeText',
          style: const TextStyle(
            color: Colors.red,
            fontSize: 16.0,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  // Handle mark complete after progress bar full
  void _handleMarkComplete() async {
    TimerService.instance.clear();
    await widget.onTaskCompleted();
    Navigator.of(context).pop(); // Close the pomodoro screen
  }

  // Show session completion dialog
  void _showSessionCompletionDialog() {
    setState(() {
      _state = _createUpdatedState(
        allSessionsComplete: true,
        timerState: 'paused',
      );
    });
    _ticker?.cancel();

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('All Sessions Complete!'),
        content: Text(
          'You have completed all ${_state!.totalCycles} focus sessions for this task.',
        ),
        actions: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(); // Close dialog
              _handleDismissTimer(); // Clear timer and close pomodoro screen
            },
            child: const Text('Dismiss'),
          ),
        ],
      ),
    );
  }

  // Handle dismiss timer after session completion
  void _handleDismissTimer() {
    TimerService.instance.clear();
    Navigator.of(context).pop(); // Close the pomodoro screen
  }

  // Validate focus duration before starting timer
  bool _validateFocusDuration() {
    final focusMinutes = int.tryParse(_focusController.text.trim()) ?? 25;
    final taskTotalMinutes =
        (widget.todo.durationHours * 60) + widget.todo.durationMinutes;
    // If user continued an overdue task, allow any focus duration (skip rule)
    final continuedOverdue = TimerService.instance.hasUserContinuedOverdue(
      widget.todo.text,
    );
    if (kDebugMode) {
      debugPrint(
        'VALIDATION: focusMinutes=$focusMinutes taskTotalMinutes=$taskTotalMinutes continuedOverdue=$continuedOverdue',
      );
    }
    if (!continuedOverdue && focusMinutes > taskTotalMinutes) {
      _showFocusDurationError(focusMinutes, taskTotalMinutes);
      return false;
    }
    return true;
  }

  // Show focus duration validation error
  void _showFocusDurationError(int focusMinutes, int taskMinutes) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Invalid Focus Duration'),
        content: Text(
          'Focus duration ($focusMinutes minutes) cannot be greater than the task duration ($taskMinutes minutes). Please reduce the focus duration or increase the task duration.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  String _format(int seconds) {
    final m = (seconds ~/ 60).toString().padLeft(2, '0');
    final s = (seconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }

  int _calculateCycles(int focusMinutes) {
    final taskMinutes =
        (widget.todo.durationHours * 60) + widget.todo.durationMinutes;
    final effectiveFocus = focusMinutes > 0 ? focusMinutes : 25;
    final raw = taskMinutes ~/ effectiveFocus;
    return raw > 0 ? raw : 1;
  }

  Future<void> _applyAutoCalculateCyclesIfNeeded({bool force = false}) async {
    final curText = _cyclesController.text.trim();
    final curVal = int.tryParse(curText) ?? 0;
    if (kDebugMode) {
      debugPrint(
        'Auto-calc: current cycles input="$curText" parsed=$curVal force=$force',
      );
    }
    if (!force && curVal > 0) {
      if (kDebugMode) {
        debugPrint(
          'Auto-calc: user provided cycles, skipping auto-calculation.',
        );
      }
      return; // user provided a manual value, respect it
    }

    final focusMinutes =
        int.tryParse(_focusController.text.trim()) ??
        ((_state?.focusDuration ?? 1500) ~/ 60);
    final calculated = _calculateCycles(focusMinutes);
    if (kDebugMode) {
      debugPrint(
        'Auto-calc: taskMinutes=${(widget.todo.durationHours * 60) + widget.todo.durationMinutes} focusMinutes=$focusMinutes calculated=$calculated',
      );
    }

    setState(() {
      _cyclesController.text = calculated.toString();
      _state = TaskTimerState(
        taskId: _state!.taskId,
        timerState: _state!.timerState,
        currentMode: _state!.currentMode,
        timeRemaining: _state!.timeRemaining,
        focusDuration: _state!.focusDuration,
        breakDuration: _state!.breakDuration,
        currentCycle: _state!.currentCycle,
        totalCycles: calculated,
      );
    });
    await _store.save(widget.todo.id.toString(), _state!);
  }

  @override
  Widget build(BuildContext context) {
    final s = _state;
    if (s == null) return const Center(child: CircularProgressIndicator());

    final isRunning = s.timerState == 'running';

    // DEBUG: Log UI decision
    if (kDebugMode) {
      final showSetup =
          (s.timerState == 'paused' && s.timeRemaining == s.focusDuration) ||
          (s.timerState == 'idle');
      debugPrint(
        "UI DEBUG: timerState=${s.timerState}, timeRemaining=${s.timeRemaining}, focusDuration=${s.focusDuration}, showSetup=$showSetup",
      );
    }

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 40,
                height: 5,
                decoration: BoxDecoration(
                  color: Colors.grey[300],
                  borderRadius: BorderRadius.circular(10),
                ),
              ),
              const SizedBox(height: 16),
              Stack(
                alignment: Alignment.center,
                children: [
                  Center(
                    child: Text(
                      'Pomodoro Timer',
                      style: TextStyle(
                        color: AppColors.brightYellow,
                        fontSize: 22.0,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.centerRight,
                    child: IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () async {
                        // First pause the timer if it's running
                        if (_state?.timerState == 'running') {
                          _stopTicker();
                        }

                        // Reset timer to initial state - this ensures next opening goes to setup
                        setState(() {
                          _state = TaskTimerState(
                            taskId: widget.todo.id.toString(),
                            timerState: 'paused',
                            currentMode: 'focus',
                            timeRemaining: 25 * 60, // Default 25 minutes
                            focusDuration: 25 * 60,
                            breakDuration: 5 * 60,
                            totalCycles: _calculateCycles(25),
                            completedSessions: 0,
                            isProgressBarFull: false,
                            allSessionsComplete: false,
                          );
                        });

                        // Clear both the service state and mini-bar before closing
                        TimerService.instance.clear();

                        // Persist the reset state so reopening shows initial UI
                        await _store.save(widget.todo.id.toString(), _state!);

                        // Close the sheet
                        Navigator.of(context).pop();
                      },
                    ),
                  ),
                ],
              ),
              // Increased space between title and task box for clearer hierarchy
              const SizedBox(height: 40),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 8,
                ),
                decoration: BoxDecoration(
                  border: Border.all(color: AppColors.brightYellow, width: 1.5),
                  borderRadius: BorderRadius.circular(12.0),
                ),
                child: Text(
                  widget.todo.text,
                  textAlign: TextAlign.center,
                  style: const TextStyle(
                    fontSize: 18.0,
                    fontWeight: FontWeight.w700,
                    height: 1.1,
                  ),
                ),
              ),
              // Progress bar for overall task completion
              Builder(
                builder: (ctx) {
                  final plannedSeconds =
                      (widget.todo.durationHours * 3600) +
                      (widget.todo.durationMinutes * 60);
                  final cached =
                      TimerService.instance.getFocusedTime(widget.todo.text) ??
                      widget.todo.focusedTime;

                  // Check if this is an overdue task that user chose to continue
                  final isOverdueTask =
                      plannedSeconds > 0 &&
                      cached >= plannedSeconds &&
                      TimerService.instance.hasUserContinuedOverdue(
                        widget.todo.text,
                      );

                  return Padding(
                    // Slightly reduced top padding so the progress bar sits
                    // a bit closer to the content above and ultimately
                    // closer to the timer when the large spacer is reduced.
                    padding: const EdgeInsets.only(top: 48.0, bottom: 8.0),
                    child: SizedBox(
                      // Wrapper to control overall space. Height increased
                      // to comfortably contain a thicker progress bar.
                      height: 34,
                      child: isOverdueTask
                          ? _buildOverdueTimeDisplay(cached, plannedSeconds)
                          : ProgressBar(
                              focusedSeconds: cached,
                              plannedSeconds: plannedSeconds,
                              barHeight: 28.0, // Thicker progress bar
                            ),
                    ),
                  );
                },
              ),
              // Reduced vertical breathing room so the progress bar,
              // cycle counters and timer are visually closer together.
              const SizedBox(height: 12),
            ],
          ),
          // Settings row (Focus / Break / Cycles)
          // Show full interactive settings only in the initial pre-start state or idle state.
          if ((s.timerState == 'paused' &&
                  s.timeRemaining == s.focusDuration) ||
              (s.timerState == 'idle')) ...[
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                // Column 1: Work Duration (box, long yellow line, bottom label)
                Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Container(
                      width: 88,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 6,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.transparent,
                        border: Border.all(
                          color: Colors.grey.shade700,
                          width: 1.0,
                        ),
                        borderRadius: BorderRadius.circular(10.0),
                      ),
                      child: TextField(
                        controller: _focusController,
                        textAlign: TextAlign.center,
                        keyboardType: TextInputType.number,
                        style: const TextStyle(
                          fontSize: 18.0,
                          color: Colors.white,
                        ),
                        decoration: const InputDecoration(
                          border: InputBorder.none,
                        ),
                        onChanged: (value) async {
                          final intValue = int.tryParse(value) ?? 0;
                          setState(() {
                            _state = TaskTimerState(
                              taskId: s.taskId,
                              timerState: s.timerState,
                              currentMode: s.currentMode,
                              timeRemaining:
                                  s.currentMode == 'focus' && intValue > 0
                                  ? intValue * 60
                                  : s.timeRemaining,
                              focusDuration: intValue > 0
                                  ? intValue * 60
                                  : s.focusDuration,
                              breakDuration: s.breakDuration,
                              currentCycle: s.currentCycle,
                              totalCycles: s.totalCycles,
                            );
                            _store.save(widget.todo.id.toString(), _state!);
                          });
                          await _applyAutoCalculateCyclesIfNeeded();
                        },
                      ),
                    ),
                    const SizedBox(height: 12),
                    Container(
                      width: 2,
                      height: 56,
                      color: AppColors.brightYellow,
                    ),
                    const SizedBox(height: 12),
                    const Text(
                      'Work Duration',
                      style: TextStyle(
                        fontSize: 12.0,
                        color: AppColors.brightYellow,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),

                // Column 2: Break Time (label above, long yellow line, box)
                Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    const Text(
                      'Break Time',
                      style: TextStyle(
                        fontSize: 12.0,
                        color: AppColors.brightYellow,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Container(
                      width: 2,
                      height: 56,
                      color: AppColors.brightYellow,
                    ),
                    const SizedBox(height: 12),
                    Container(
                      width: 88,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 6,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.transparent,
                        border: Border.all(
                          color: Colors.grey.shade700,
                          width: 1.0,
                        ),
                        borderRadius: BorderRadius.circular(10.0),
                      ),
                      child: TextField(
                        controller: _breakController,
                        textAlign: TextAlign.center,
                        keyboardType: TextInputType.number,
                        style: const TextStyle(
                          fontSize: 18.0,
                          color: Colors.white,
                        ),
                        decoration: const InputDecoration(
                          border: InputBorder.none,
                        ),
                        onChanged: (value) {
                          final intValue = int.tryParse(value) ?? 0;
                          setState(() {
                            _state = TaskTimerState(
                              taskId: s.taskId,
                              timerState: s.timerState,
                              currentMode: s.currentMode,
                              timeRemaining:
                                  s.currentMode == 'break' && intValue > 0
                                  ? intValue * 60
                                  : s.timeRemaining,
                              focusDuration: s.focusDuration,
                              breakDuration: intValue > 0
                                  ? intValue * 60
                                  : s.breakDuration,
                              currentCycle: s.currentCycle,
                              totalCycles: s.totalCycles,
                            );
                            _store.save(widget.todo.id.toString(), _state!);
                          });
                        },
                      ),
                    ),
                  ],
                ),

                // Column 3: Cycles (box, long yellow line, bottom label)
                Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Container(
                      width: 88,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 6,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.transparent,
                        border: Border.all(
                          color: Colors.grey.shade700,
                          width: 1.0,
                        ),
                        borderRadius: BorderRadius.circular(10.0),
                      ),
                      child: TextField(
                        controller: _cyclesController,
                        textAlign: TextAlign.center,
                        keyboardType: TextInputType.number,
                        style: const TextStyle(
                          fontSize: 18.0,
                          color: Colors.white,
                        ),
                        decoration: const InputDecoration(
                          border: InputBorder.none,
                        ),
                        onChanged: (value) {
                          final intValue = int.tryParse(value) ?? 0;
                          if (intValue <= 0) return;
                          setState(() {
                            _state = TaskTimerState(
                              taskId: s.taskId,
                              timerState: s.timerState,
                              currentMode: s.currentMode,
                              timeRemaining: s.timeRemaining,
                              focusDuration: s.focusDuration,
                              breakDuration: s.breakDuration,
                              currentCycle: s.currentCycle,
                              totalCycles: intValue,
                            );
                            _store.save(widget.todo.id.toString(), _state!);
                          });
                        },
                      ),
                    ),
                    const SizedBox(height: 12),
                    Container(
                      width: 2,
                      height: 56,
                      color: AppColors.brightYellow,
                    ),
                    const SizedBox(height: 12),
                    const Text(
                      'Cycles',
                      style: TextStyle(
                        fontSize: 12.0,
                        color: AppColors.brightYellow,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
              ],
            ),
            // Space between settings and the main timer
            const SizedBox(height: 24),
          ] else ...[
            // Compact settings display after timer has started
            Text(
              '${(s.focusDuration! ~/ 60)} / ${(s.breakDuration! ~/ 60)} / ${s.totalCycles}',
              style: const TextStyle(
                fontSize: 16.0,
                fontWeight: FontWeight.w600,
                color: Colors.white,
              ),
            ),
            const SizedBox(height: 12),
            // Cycle counter (no icon in any state)
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  '${s.currentCycle} / ${s.totalCycles}',
                  style: const TextStyle(
                    fontSize: 28.0,
                    fontWeight: FontWeight.w900,
                    color: Colors.white,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            const Divider(color: Color(0xFF262626)),
            const SizedBox(height: 12),
            // Make the timer the dominant visual element
            Expanded(
              flex: 5,
              child: Center(
                child: IntrinsicWidth(
                  child: DecoratedBox(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color:
                            (s.timerState == 'running' ||
                                s.timerState == 'paused')
                            ? (s.currentMode == 'focus'
                                  ? Colors.redAccent
                                  : Colors.greenAccent)
                            : Colors.transparent,
                        width: 6.0, // make border slightly thicker
                      ),
                      borderRadius: BorderRadius.circular(14.0),
                    ),
                    child: Container(
                      // Give the timer box a slightly larger footprint
                      // and uniform padding so digits sit away from all edges.
                      alignment: Alignment.center,
                      padding: const EdgeInsets.all(20.0),
                      child: Text(
                        _format(s.timeRemaining!),
                        textAlign: TextAlign.center,
                        style: GoogleFonts.oswald(
                          fontSize: 120.0,
                          fontWeight: FontWeight.w700,
                          letterSpacing: -2.0,
                          height: 1.05,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 12),
            const Divider(color: Color(0xFF262626)),
          ],

          // Buttons row
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  // Left secondary circular outlined button (Reset) with yellow ring
                  Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          border: Border.all(
                            color: AppColors.brightYellow,
                            width: 2.0,
                          ),
                        ),
                        child: OutlinedButton(
                          style: OutlinedButton.styleFrom(
                            shape: const CircleBorder(),
                            side: BorderSide(color: Colors.transparent),
                            padding: const EdgeInsets.all(12),
                          ),
                          onPressed: () async {
                            if (kDebugMode) {
                              debugPrint("Resetting current session timer.");
                            }
                            _ticker
                                ?.cancel(); // Stop timer without saving progress

                            // Calculate the session progress that will be lost
                            final sessionProgress = _state!.lastFocusedTime;
                            final currentFocusedTime =
                                TimerService.instance.getFocusedTime(
                                  widget.todo.text,
                                ) ??
                                widget.todo.focusedTime;
                            final revertedFocusedTime = max(
                              0,
                              currentFocusedTime - sessionProgress,
                            );

                            if (kDebugMode) {
                              debugPrint(
                                "RESET: Session progress to revert: ${sessionProgress}s",
                              );
                              debugPrint(
                                "RESET: Current total focused: ${currentFocusedTime}s -> ${revertedFocusedTime}s",
                              );
                            }

                            // Reset the focused time in the service cache to remove session progress
                            TimerService.instance.setFocusedTime(
                              widget.todo.text,
                              revertedFocusedTime,
                            );

                            // Also update the server to reflect the reset
                            try {
                              await widget.api.updateFocusTime(
                                widget.todo.id,
                                revertedFocusedTime,
                              );
                            } catch (_) {
                              // ignore network errors; local cache keeps the truth
                            }

                            setState(() {
                              _state = _createUpdatedState(
                                timerState: 'paused',
                                timeRemaining: _state!.currentMode == 'focus'
                                    ? _state!.focusDuration
                                    : _state!.breakDuration,
                                lastFocusedTime: 0, // Reset session progress
                              );
                            });

                            await _store.save(
                              widget.todo.id.toString(),
                              _state!,
                            );

                            TimerService.instance.update(
                              taskName: widget.todo.text,
                              running: false,
                              remaining: _state?.timeRemaining,
                              mode: _state?.currentMode,
                              active: false,
                              focusDuration: _state?.focusDuration,
                              breakDuration: _state?.breakDuration,
                              setTotalCycles: _state?.totalCycles,
                              setCurrentCycle: _state?.currentCycle,
                            );
                          },
                          child: const Icon(
                            Icons.replay_rounded,
                            color: Colors.white,
                            size: 22,
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Reset',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),

                  // Center primary circular action
                  Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      SizedBox(
                        width: 72,
                        height: 72,
                        child: FloatingActionButton(
                          backgroundColor: AppColors.brightYellow,
                          onPressed: () async {
                            if (isRunning) {
                              if (kDebugMode) {
                                debugPrint("Pausing timer.");
                                debugPrintStack(
                                  label:
                                      'POMODORO: stack when user tapped pause',
                                );
                              }
                              setState(() {
                                _state = _createUpdatedState(
                                  timerState: 'paused',
                                );
                                _stopTicker();
                                _store.save(widget.todo.id.toString(), _state!);
                              });
                            } else {
                              // Validate focus duration before starting
                              if (!_validateFocusDuration()) {
                                return; // Stop if validation fails
                              }

                              await _applyAutoCalculateCyclesIfNeeded(
                                force: true,
                              );
                              if (kDebugMode) {
                                debugPrint("Starting timer.");
                                debugPrintStack(
                                  label:
                                      'POMODORO: stack when user tapped start',
                                );
                              }
                              setState(() {
                                _state = _createUpdatedState(
                                  timerState: 'running',
                                );
                                _startTicker();
                                _store.save(widget.todo.id.toString(), _state!);
                              });
                            }
                          },
                          child: Icon(
                            isRunning
                                ? Icons.pause_rounded
                                : Icons.play_arrow_rounded,
                            color: Colors.black,
                            size: 40,
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        isRunning ? 'Pause' : 'Start',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 14,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      const SizedBox(height: 4), // Space for button label
                    ],
                  ),

                  // Right secondary circular outlined button (Skip)
                  // Right secondary circular outlined button (Skip) with yellow ring
                  Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          border: Border.all(
                            color: AppColors.brightYellow,
                            width: 2.0,
                          ),
                        ),
                        child: OutlinedButton(
                          style: OutlinedButton.styleFrom(
                            shape: const CircleBorder(),
                            side: BorderSide(color: Colors.transparent),
                            padding: const EdgeInsets.all(12),
                          ),
                          onPressed: () async {
                            if (kDebugMode) {
                              debugPrint("Skipping to next phase.");
                            }
                            final bool isFocus = s.currentMode == 'focus';
                            // Persist progress from the focus session being skipped
                            if (isFocus) {
                              final totalFocusedTime =
                                  widget.todo.focusedTime + s.lastFocusedTime;
                              await widget.api.updateFocusTime(
                                widget.todo.id,
                                totalFocusedTime,
                              );
                              TimerService.instance.setFocusedTime(
                                widget.todo.text,
                                totalFocusedTime,
                              );
                            }
                            setState(() {
                              _state = _createUpdatedState(
                                timerState: 'running',
                                currentMode: isFocus ? 'break' : 'focus',
                                timeRemaining: isFocus
                                    ? s.breakDuration
                                    : s.focusDuration,
                                currentCycle: isFocus
                                    ? s.currentCycle + 1
                                    : s.currentCycle,
                                // When starting break, reset lastFocusedTime for break tracking
                                // When starting focus, keep current lastFocusedTime to preserve session progress
                                lastFocusedTime: isFocus
                                    ? 0
                                    : s.lastFocusedTime,
                              );
                              _startTicker();
                              _store.save(widget.todo.id.toString(), _state!);
                            });
                          },
                          child: const Icon(
                            Icons.fast_forward_rounded,
                            color: AppColors.brightYellow,
                            size: 22,
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Skip',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 24),
            ],
          ),
        ],
      ),
    );
  }
}
</file>

</files>
